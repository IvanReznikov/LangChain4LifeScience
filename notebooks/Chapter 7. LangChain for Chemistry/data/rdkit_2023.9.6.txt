
--------------------------------------------------------------------------------
rdkit.Avalon.pyAvalonTools.CheckMolecule((str)molstring, (bool)isSmiles) → tuple :¶

check a molecule passed in as a string.If the isSmiles argument is true, the string should represent the SMILES encoding
of the molecule, otherwise it should be encoded as an MDL molfile.
The first member of the return tuple contains the bit-encoded corrections made to the molecule.
If possible, the molecule (corrected when appropriate) is returned as the second member of 
the return tuple. Otherwise, None is returned.

C++ signature :boost::python::tuple CheckMolecule(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool)



CheckMolecule( (object)mol) -> tuple :check a molecule passed in as an RDKit molecule.
The first member of the return tuple contains the bit-encoded corrections made to the molecule.
If possible, the molecule (corrected when appropriate) is returned as the second member of 
the return tuple. Otherwise, None is returned.

C++ signature :boost::python::tuple CheckMolecule(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Avalon.pyAvalonTools.CheckMoleculeString((str)molstring, (bool)isSmiles) → tuple :¶
check a molecule passed in as a string and returns the result as a string.
If the isSmiles argument is true, the string should represent the SMILES encoding
of the molecule, otherwise it should be encoded as an MDL molfile.
The first member of the return tuple contains the bit-encoded corrections made to the molecule.
If possible, a corrected CTAB for the molecule is returned as the second member of 
the return tuple.

C++ signature :boost::python::tuple CheckMoleculeString(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool)
--------------------------------------------------------------------------------
rdkit.Avalon.pyAvalonTools.CloseCheckMolFiles() → None :¶
close open files used by molecule-checking functions.

C++ signature :void CloseCheckMolFiles()
--------------------------------------------------------------------------------
rdkit.Avalon.pyAvalonTools.Generate2DCoords((object)mol[, (bool)clearConfs=True]) → int :¶
Generates 2d coordinates for an RDKit molecule


C++ signature :unsigned int Generate2DCoords(RDKit::ROMol {lvalue} [,bool=True])




Generate2DCoords( (str)molData, (bool)isSmiles) -> str :returns an MDL mol block with 2D coordinates for some molecule data.
If the isSmiles argument is true, the data is assumed to be SMILES, otherwise
MDL mol data is assumed.

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > Generate2DCoords(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool)
--------------------------------------------------------------------------------
rdkit.Avalon.pyAvalonTools.GetAvalonCountFP((object)mol[, (int)nBits=512[, (bool)isQuery=False[, (int)bitFlags=15761407]]]) → object :¶
returns the Avalon count fingerprint for an RDKit molecule


C++ signature :RDKit::SparseIntVect<unsigned int>* GetAvalonCountFP(RDKit::ROMol [,unsigned int=512 [,bool=False [,unsigned int=15761407]]])




GetAvalonCountFP( (str)molData, (bool)isSmiles [, (int)nBits=512 [, (bool)isQuery=False [, (int)bitFlags=15761407]]]) -> object :returns the Avalon count fingerprint for some molecule data.
If the isSmiles argument is true, the data is assumed to be SMILES, otherwise
MDL mol data is assumed.

C++ signature :RDKit::SparseIntVect<unsigned int>* GetAvalonCountFP(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool [,unsigned int=512 [,bool=False [,unsigned int=15761407]]])
--------------------------------------------------------------------------------
rdkit.Avalon.pyAvalonTools.GetAvalonFP((object)mol[, (int)nBits=512[, (bool)isQuery=False[, (bool)resetVect=False[, (int)bitFlags=15761407]]]]) → object :¶
returns the Avalon fingerprint for an RDKit molecule


C++ signature :ExplicitBitVect* GetAvalonFP(RDKit::ROMol [,unsigned int=512 [,bool=False [,bool=False [,unsigned int=15761407]]]])




GetAvalonFP( (str)molData, (bool)isSmiles [, (int)nBits=512 [, (bool)isQuery=False [, (bool)resetVect=False [, (int)bitFlags=15761407]]]]) -> object :returns the Avalon fingerprint for some molecule data.
If the isSmiles argument is true, the data is assumed to be SMILES, otherwise
MDL mol data is assumed.

C++ signature :ExplicitBitVect* GetAvalonFP(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool [,unsigned int=512 [,bool=False [,bool=False [,unsigned int=15761407]]]])
--------------------------------------------------------------------------------
rdkit.Avalon.pyAvalonTools.GetAvalonFPAsWords((object)mol[, (int)nBits=512[, (bool)isQuery=False[, (bool)resetVect=False[, (int)bitFlags=15761407]]]]) → list :¶
returns the Avalon fingerprint for an RDKit molecule as a list of ints


C++ signature :boost::python::list GetAvalonFPAsWords(RDKit::ROMol [,unsigned int=512 [,bool=False [,bool=False [,unsigned int=15761407]]]])




GetAvalonFPAsWords( (str)molData, (bool)isSmiles [, (int)nBits=512 [, (bool)isQuery=False [, (bool)resetVect=False [, (int)bitFlags=15761407]]]]) -> list :returns the Avalon fingerprint for some molecule data as a list of ints.
If the isSmiles argument is true, the data is assumed to be SMILES, otherwise
MDL mol data is assumed.

C++ signature :boost::python::list GetAvalonFPAsWords(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool [,unsigned int=512 [,bool=False [,bool=False [,unsigned int=15761407]]]])
--------------------------------------------------------------------------------
rdkit.Avalon.pyAvalonTools.GetCanonSmiles((object)mol[, (int)flags=-1]) → str :¶
returns canonical smiles for an RDKit molecule


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > GetCanonSmiles(RDKit::ROMol {lvalue} [,int=-1])




GetCanonSmiles( (str)molData, (bool)isSmiles [, (int)flags=-1]) -> str :Returns canonical smiles for some molecule data.
If the isSmiles argument is true, the data is assumed to be SMILES, otherwise
MDL mol data is assumed.

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > GetCanonSmiles(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool [,int=-1])
--------------------------------------------------------------------------------
rdkit.Avalon.pyAvalonTools.GetCheckMolLog() → str :¶
Returns the Struchk log for the last molecules processed.

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > GetCheckMolLog()
--------------------------------------------------------------------------------
rdkit.Avalon.pyAvalonTools.InitializeCheckMol([(str)options='']) → int :¶
initializes the structure checker.
The argument should contain option lines separated by embedded newlines.An empty string will be used if the argument is omitted.An non-zero error code is returned in case of failure.

C++ signature :int InitializeCheckMol([ std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.CanonSmiles(smi, useChiral=1)¶
--------------------------------------------------------------------------------
rdkit.Chem.FindMolChiralCenters(mol, force=True, includeUnassigned=False, includeCIP=True, useLegacyImplementation=None)¶
>>> from rdkit import Chem
>>> mol = Chem.MolFromSmiles('[C@H](Cl)(F)Br')
>>> Chem.FindMolChiralCenters(mol)
[(0, 'R')]
>>> mol = Chem.MolFromSmiles('[C@@H](Cl)(F)Br')
>>> Chem.FindMolChiralCenters(mol)
[(0, 'S')]


>>> Chem.FindMolChiralCenters(Chem.MolFromSmiles('CCC'))
[]


By default unassigned stereo centers are not reported:
>>> mol = Chem.MolFromSmiles('C[C@H](F)C(F)(Cl)Br')
>>> Chem.FindMolChiralCenters(mol,force=True)
[(1, 'S')]


but this can be changed:
>>> Chem.FindMolChiralCenters(mol,force=True,includeUnassigned=True)
[(1, 'S'), (3, '?')]


The handling of unassigned stereocenters for dependent stereochemistry is not correct 
using the legacy implementation:
>>> Chem.FindMolChiralCenters(Chem.MolFromSmiles('C1CC(C)C(C)C(C)C1'),includeUnassigned=True)
[(2, '?'), (6, '?')]
>>> Chem.FindMolChiralCenters(Chem.MolFromSmiles('C1C[C@H](C)C(C)[C@H](C)C1'),includeUnassigned=True)
[(2, 'S'), (4, '?'), (6, 'R')]


But works with the new implementation:
>>> Chem.FindMolChiralCenters(Chem.MolFromSmiles('C1CC(C)C(C)C(C)C1'),includeUnassigned=True, useLegacyImplementation=False)
[(2, '?'), (4, '?'), (6, '?')]


Note that the new implementation also gets the correct descriptors for para-stereochemistry:
>>> Chem.FindMolChiralCenters(Chem.MolFromSmiles('C1C[C@H](C)[C@H](C)[C@H](C)C1'),useLegacyImplementation=False)
[(2, 'S'), (4, 's'), (6, 'R')]


With the new implementation, if you don’t care about the CIP labels of stereocenters, you can save
some time by disabling those:
>>> Chem.FindMolChiralCenters(Chem.MolFromSmiles('C1C[C@H](C)[C@H](C)[C@H](C)C1'), includeCIP=False, useLegacyImplementation=False)
[(2, 'Tet_CCW'), (4, 'Tet_CCW'), (6, 'Tet_CCW')]
--------------------------------------------------------------------------------
rdkit.Chem.QuickSmartsMatch(smi, sma, unique=True, display=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.SupplierFromFilename(fileN, delim='', **kwargs)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.AllChem.AssignBondOrdersFromTemplate(refmol, mol)¶
assigns bond orders to a molecule based on the
bond orders in a template molecule

Arguments
refmol: the template molecule
mol: the molecule to assign bond orders to



An example, start by generating a template from a SMILES
and read in the PDB structure of the molecule
>>> import os
>>> from rdkit.Chem import AllChem
>>> template = AllChem.MolFromSmiles("CN1C(=NC(C1=O)(c2ccccc2)c3ccccc3)N")
>>> mol = AllChem.MolFromPDBFile(os.path.join(RDConfig.RDCodeDir, 'Chem', 'test_data', '4DJU_lig.pdb'))
>>> len([1 for b in template.GetBonds() if b.GetBondTypeAsDouble() == 1.0])
8
>>> len([1 for b in mol.GetBonds() if b.GetBondTypeAsDouble() == 1.0])
22


Now assign the bond orders based on the template molecule
>>> newMol = AllChem.AssignBondOrdersFromTemplate(template, mol)
>>> len([1 for b in newMol.GetBonds() if b.GetBondTypeAsDouble() == 1.0])
8


Note that the template molecule should have no explicit hydrogens
else the algorithm will fail.
It also works if there are different formal charges (this was github issue 235):
>>> template=AllChem.MolFromSmiles('CN(C)C(=O)Cc1ccc2c(c1)NC(=O)c3ccc(cc3N2)c4ccc(c(c4)OC)[N+](=O)[O-]')
>>> mol = AllChem.MolFromMolFile(os.path.join(RDConfig.RDCodeDir, 'Chem', 'test_data', '4FTR_lig.mol'))
>>> AllChem.MolToSmiles(mol)
'COC1CC(C2CCC3C(O)NC4CC(CC(O)N(C)C)CCC4NC3C2)CCC1N(O)O'
>>> newMol = AllChem.AssignBondOrdersFromTemplate(template, mol)
>>> AllChem.MolToSmiles(newMol)
'COc1cc(-c2ccc3c(c2)Nc2ccc(CC(=O)N(C)C)cc2NC3=O)ccc1[N+](=O)[O-]'
--------------------------------------------------------------------------------
rdkit.Chem.AllChem.ComputeMolShape(mol, confId=-1, boxDim=(20, 20, 20), spacing=0.5, **kwargs)¶
returns a grid representation of the molecule’s shape
--------------------------------------------------------------------------------
rdkit.Chem.AllChem.ComputeMolVolume(mol, confId=-1, gridSpacing=0.2, boxMargin=2.0)¶
Calculates the volume of a particular conformer of a molecule
based on a grid-encoding of the molecular shape.
A bit of demo as well as a test of github #1883:
>>> from rdkit import Chem
>>> from rdkit.Chem import AllChem
>>> mol = Chem.AddHs(Chem.MolFromSmiles('C'))
>>> AllChem.EmbedMolecule(mol)
0
>>> ComputeMolVolume(mol)
28...
>>> mol = Chem.AddHs(Chem.MolFromSmiles('O'))
>>> AllChem.EmbedMolecule(mol)
0
>>> ComputeMolVolume(mol)
20...
--------------------------------------------------------------------------------
rdkit.Chem.AllChem.ConstrainedEmbed(mol, core, useTethers=True, coreConfId=-1, randomseed=2342, getForceField=<Boost.Python.function object>, **kwargs)¶
generates an embedding of a molecule where part of the molecule
is constrained to have particular coordinates

Arguments
mol: the molecule to embed
core: the molecule to use as a source of constraints

useTethers: (optional) if True, the final conformation will beoptimized subject to a series of extra forces that pull the
matching atoms to the positions of the core atoms. Otherwise
simple distance constraints based on the core atoms will be
used in the optimization.



coreConfId: (optional) id of the core conformation to use
randomSeed: (optional) seed for the random number generator



An example, start by generating a template with a 3D structure:
>>> from rdkit.Chem import AllChem
>>> template = AllChem.MolFromSmiles("c1nn(Cc2ccccc2)cc1")
>>> AllChem.EmbedMolecule(template)
0
>>> AllChem.UFFOptimizeMolecule(template)
0


Here’s a molecule:
>>> mol = AllChem.MolFromSmiles("c1nn(Cc2ccccc2)cc1-c3ccccc3")


Now do the constrained embedding
>>> mol = AllChem.ConstrainedEmbed(mol, template)


Demonstrate that the positions are nearly the same with template:
>>> import math
>>> molp = mol.GetConformer().GetAtomPosition(0)
>>> templatep = template.GetConformer().GetAtomPosition(0)
>>> all(math.isclose(v, 0.0, abs_tol=0.01) for v in molp-templatep)
True
>>> molp = mol.GetConformer().GetAtomPosition(1)
>>> templatep = template.GetConformer().GetAtomPosition(1)
>>> all(math.isclose(v, 0.0, abs_tol=0.01) for v in molp-templatep)
True
--------------------------------------------------------------------------------
rdkit.Chem.AllChem.EnumerateLibraryFromReaction(reaction, sidechainSets, returnReactants=False)¶
Returns a generator for the virtual library defined by
a reaction and a sequence of sidechain sets
>>> from rdkit import Chem
>>> from rdkit.Chem import AllChem
>>> s1=[Chem.MolFromSmiles(x) for x in ('NC','NCC')]
>>> s2=[Chem.MolFromSmiles(x) for x in ('OC=O','OC(=O)C')]
>>> rxn = AllChem.ReactionFromSmarts('[O:2]=[C:1][OH].[N:3]>>[O:2]=[C:1][N:3]')
>>> r = AllChem.EnumerateLibraryFromReaction(rxn,[s2,s1])
>>> [Chem.MolToSmiles(x[0]) for x in list(r)]
['CNC=O', 'CCNC=O', 'CNC(C)=O', 'CCNC(C)=O']


Note that this is all done in a lazy manner, so “infinitely” large libraries can
be done without worrying about running out of memory. Your patience will run out first:
Define a set of 10000 amines:
>>> amines = (Chem.MolFromSmiles('N'+'C'*x) for x in range(10000))


… a set of 10000 acids
>>> acids = (Chem.MolFromSmiles('OC(=O)'+'C'*x) for x in range(10000))


… now the virtual library (1e8 compounds in principle):
>>> r = AllChem.EnumerateLibraryFromReaction(rxn,[acids,amines])


… look at the first 4 compounds:
>>> [Chem.MolToSmiles(next(r)[0]) for x in range(4)]
['NC=O', 'CNC=O', 'CCNC=O', 'CCCNC=O']
--------------------------------------------------------------------------------
rdkit.Chem.AllChem.GetConformerRMS(mol, confId1, confId2, atomIds=None, prealigned=False)¶
Returns the RMS between two conformations.
By default, the conformers will be aligned to the first conformer
before the RMS calculation and, as a side-effect, the second will be left
in the aligned state.

Arguments:
mol:        the molecule
confId1:    the id of the first conformer
confId2:    the id of the second conformer

atomIds:    (optional) list of atom ids to use a points foralingment - defaults to all atoms




prealigned: (optional) by default the conformers are assumedbe unaligned and the second conformer be aligned
to the first
--------------------------------------------------------------------------------
rdkit.Chem.AllChem.GetConformerRMSMatrix(mol, atomIds=None, prealigned=False)¶
Returns the RMS matrix of the conformers of a molecule.
As a side-effect, the conformers will be aligned to the first
conformer (i.e. the reference) and will left in the aligned state.

Arguments:
mol:     the molecule

atomIds: (optional) list of atom ids to use a points foralingment - defaults to all atoms




prealigned: (optional) by default the conformers are assumedbe unaligned and will therefore be aligned to the
first conformer






Note that the returned RMS matrix is symmetrical, i.e. it is the
lower half of the matrix, e.g. for 5 conformers:
rmsmatrix = [ a,
              b, c,
              d, e, f,
              g, h, i, j]


where a is the RMS between conformers 0 and 1, b is the RMS between
conformers 0 and 2, etc.
This way it can be directly used as distance matrix in e.g. Butina
clustering.
--------------------------------------------------------------------------------
rdkit.Chem.AllChem.TransformMol(mol, tform, confId=-1, keepConfs=False)¶
Applies the transformation (usually a 4x4 double matrix) to a molecule
if keepConfs is False then all but that conformer are removed
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.AtomPairs.Pairs.ExplainPairScore(score, includeChirality=False)¶
>>> from rdkit import Chem
>>> m = Chem.MolFromSmiles('C=CC')
>>> score = pyScorePair(m.GetAtomWithIdx(0), m.GetAtomWithIdx(1), 1)
>>> ExplainPairScore(score)
(('C', 1, 1), 1, ('C', 2, 1))
>>> score = pyScorePair(m.GetAtomWithIdx(0), m.GetAtomWithIdx(2), 2)
>>> ExplainPairScore(score)
(('C', 1, 0), 2, ('C', 1, 1))
>>> score = pyScorePair(m.GetAtomWithIdx(1), m.GetAtomWithIdx(2), 1)
>>> ExplainPairScore(score)
(('C', 1, 0), 1, ('C', 2, 1))
>>> score = pyScorePair(m.GetAtomWithIdx(2), m.GetAtomWithIdx(1), 1)
>>> ExplainPairScore(score)
(('C', 1, 0), 1, ('C', 2, 1))


We can optionally deal with chirality too
>>> m = Chem.MolFromSmiles(‘C[C@H](F)Cl’)
>>> score = pyScorePair(m.GetAtomWithIdx(0), m.GetAtomWithIdx(1), 1)
>>> ExplainPairScore(score)
((‘C’, 1, 0), 1, (‘C’, 3, 0))
>>> score = pyScorePair(m.GetAtomWithIdx(0), m.GetAtomWithIdx(1), 1, includeChirality=True)
>>> ExplainPairScore(score, includeChirality=True)
((‘C’, 1, 0, ‘’), 1, (‘C’, 3, 0, ‘R’))
>>> m = Chem.MolFromSmiles(‘F[C@@H](Cl)[C@H](F)Cl’)
>>> score = pyScorePair(m.GetAtomWithIdx(1), m.GetAtomWithIdx(3), 1, includeChirality=True)
>>> ExplainPairScore(score, includeChirality=True)
((‘C’, 3, 0, ‘R’), 1, (‘C’, 3, 0, ‘S’))
--------------------------------------------------------------------------------
rdkit.Chem.AtomPairs.Pairs.GetAtomPairFingerprintAsBitVect(mol)¶
Returns the Atom-pair fingerprint for a molecule as
a SparseBitVect. Note that this doesn’t match the standard
definition of atom pairs, which uses counts of the
pairs, not just their presence.
Arguments:


mol: a molecule


Returns: a SparseBitVect
>>> from rdkit import Chem
>>> m = Chem.MolFromSmiles('CCC')
>>> v = [pyScorePair(m.GetAtomWithIdx(0), m.GetAtomWithIdx(1), 1),
...      pyScorePair(m.GetAtomWithIdx(0), m.GetAtomWithIdx(2), 2),
...     ]
>>> v.sort()
>>> fp = GetAtomPairFingerprintAsBitVect(m)
>>> list(fp.GetOnBits()) == v
True
--------------------------------------------------------------------------------
rdkit.Chem.AtomPairs.Pairs.pyScorePair(at1, at2, dist, atomCodes=None, includeChirality=False)¶
Returns a score for an individual atom pair.
>>> from rdkit import Chem
>>> m = Chem.MolFromSmiles('CCCCC')
>>> c1 = Utils.GetAtomCode(m.GetAtomWithIdx(0))
>>> c2 = Utils.GetAtomCode(m.GetAtomWithIdx(1))
>>> c3 = Utils.GetAtomCode(m.GetAtomWithIdx(2))
>>> t = 1 | min(c1,c2) << numPathBits | max(c1,c2) << (rdMolDescriptors.AtomPairsParameters.codeSize + numPathBits)
>>> pyScorePair(m.GetAtomWithIdx(0), m.GetAtomWithIdx(1), 1)==t
1
>>> pyScorePair(m.GetAtomWithIdx(1), m.GetAtomWithIdx(0), 1)==t
1
>>> t = 2 | min(c1,c3) << numPathBits | max(c1,c3) << (rdMolDescriptors.AtomPairsParameters.codeSize + numPathBits)
>>> pyScorePair(m.GetAtomWithIdx(0),m.GetAtomWithIdx(2),2)==t
1
>>> pyScorePair(m.GetAtomWithIdx(0),m.GetAtomWithIdx(2),2,
...  atomCodes=(Utils.GetAtomCode(m.GetAtomWithIdx(0)), Utils.GetAtomCode(m.GetAtomWithIdx(2)))) == t
1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.AtomPairs.Sheridan.AssignPattyTypes(mol, defns=None)¶
>>> from rdkit import Chem
>>> AssignPattyTypes(Chem.MolFromSmiles('OCC(=O)O'))
['POL', 'HYD', 'OTH', 'ANI', 'ANI']
--------------------------------------------------------------------------------
rdkit.Chem.AtomPairs.Sheridan.GetBPFingerprint(mol, fpfn=<Boost.Python.function object>)¶
>>> from rdkit import Chem
>>> fp = GetBPFingerprint(Chem.MolFromSmiles('OCC(=O)O'))
>>> fp.GetTotalVal()
10
>>> nze = fp.GetNonzeroElements()
>>> sorted([(k, v) for k, v in nze.items()])
[(32834, 1), (49219, 2), (98370, 2), (98401, 1), (114753, 2), (114786, 1), (114881, 1)]
--------------------------------------------------------------------------------
rdkit.Chem.AtomPairs.Sheridan.GetBTFingerprint(mol, fpfn=<Boost.Python.function object>)¶
>>> from rdkit import Chem
>>> mol = Chem.MolFromSmiles('OCC(N)O')
>>> AssignPattyTypes(mol)
['POL', 'HYD', 'HYD', 'CAT', 'POL']
>>> fp = GetBTFingerprint(mol)
>>> fp.GetTotalVal()
2
>>> nze = fp.GetNonzeroElements()
>>> sorted([(k, v) for k, v in nze.items()])
[(538446850..., 1), (538446852..., 1)]
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.AtomPairs.Torsions.ExplainPathScore(score, size=4)¶
>>> from rdkit import Chem
>>> m = Chem.MolFromSmiles('C=CC')
>>> score=pyScorePath(m, (0, 1, 2), 3)
>>> ExplainPathScore(score, 3)
(('C', 1, 0), ('C', 2, 1), ('C', 1, 1))


Again, it’s order independent:
>>> score = pyScorePath(m, (2, 1, 0), 3)
>>> ExplainPathScore(score, 3)
(('C', 1, 0), ('C', 2, 1), ('C', 1, 1))


>>> m = Chem.MolFromSmiles('C=CO')
>>> score=pyScorePath(m, (0, 1, 2), 3)
>>> ExplainPathScore(score, 3)
(('C', 1, 1), ('C', 2, 1), ('O', 1, 0))


>>> m = Chem.MolFromSmiles('OC=CO')
>>> score=pyScorePath(m, (0, 1, 2, 3), 4)
>>> ExplainPathScore(score, 4)
(('O', 1, 0), ('C', 2, 1), ('C', 2, 1), ('O', 1, 0))


>>> m = Chem.MolFromSmiles('CC=CO')
>>> score=pyScorePath(m, (0, 1, 2, 3), 4)
>>> ExplainPathScore(score, 4)
(('C', 1, 0), ('C', 2, 1), ('C', 2, 1), ('O', 1, 0))


>>> m = Chem.MolFromSmiles('C=CC(=O)O')
>>> score=pyScorePath(m, (0, 1, 2, 3), 4)
>>> ExplainPathScore(score, 4)
(('C', 1, 1), ('C', 2, 1), ('C', 3, 1), ('O', 1, 1))
>>> score=pyScorePath(m, (0, 1, 2, 4), 4)
>>> ExplainPathScore(score, 4)
(('C', 1, 1), ('C', 2, 1), ('C', 3, 1), ('O', 1, 0))


>>> m = Chem.MolFromSmiles('OOOO')
>>> score=pyScorePath(m, (0, 1, 2), 3)
>>> ExplainPathScore(score, 3)
(('O', 1, 0), ('O', 2, 0), ('O', 2, 0))
>>> score=pyScorePath(m, (0, 1, 2, 3), 4)
>>> ExplainPathScore(score, 4)
(('O', 1, 0), ('O', 2, 0), ('O', 2, 0), ('O', 1, 0))
--------------------------------------------------------------------------------
rdkit.Chem.AtomPairs.Torsions.GetTopologicalTorsionFingerprintAsIds(mol, targetSize=4)¶
--------------------------------------------------------------------------------
rdkit.Chem.AtomPairs.Torsions.pyScorePath(mol, path, size, atomCodes=None)¶
Returns a score for an individual path.
>>> from rdkit import Chem
>>> m = Chem.MolFromSmiles('CCCCC')
>>> c1 = Utils.GetAtomCode(m.GetAtomWithIdx(0), 1)
>>> c2 = Utils.GetAtomCode(m.GetAtomWithIdx(1), 2)
>>> c3 = Utils.GetAtomCode(m.GetAtomWithIdx(2), 2)
>>> c4 = Utils.GetAtomCode(m.GetAtomWithIdx(3), 1)
>>> t = c1 | (c2 << rdMolDescriptors.AtomPairsParameters.codeSize) | (c3 << (rdMolDescriptors.AtomPairsParameters.codeSize * 2)) | (c4 << (rdMolDescriptors.AtomPairsParameters.codeSize * 3))
>>> pyScorePath(m, (0, 1, 2, 3), 4) == t
1


The scores are path direction independent:
>>> pyScorePath(m, (3, 2, 1, 0), 4) == t
1


>>> m = Chem.MolFromSmiles('C=CC(=O)O')
>>> c1 = Utils.GetAtomCode(m.GetAtomWithIdx(0), 1)
>>> c2 = Utils.GetAtomCode(m.GetAtomWithIdx(1), 2)
>>> c3 = Utils.GetAtomCode(m.GetAtomWithIdx(2), 2)
>>> c4 = Utils.GetAtomCode(m.GetAtomWithIdx(4), 1)
>>> t = c1 | (c2 << rdMolDescriptors.AtomPairsParameters.codeSize) | (c3 << (rdMolDescriptors.AtomPairsParameters.codeSize * 2)) | (c4 << (rdMolDescriptors.AtomPairsParameters.codeSize * 3))
>>> pyScorePath(m, (0, 1, 2, 4), 4) == t
1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.AtomPairs.Utils.BitsInCommon(v1, v2)¶
Returns the number of bits in common between two vectors
Arguments:


two vectors (sequences of bit ids)


Returns: an integer
Notes


the vectors must be sorted
duplicate bit IDs are counted more than once


>>> BitsInCommon( (1,2,3,4,10), (2,4,6) )
2


Here’s how duplicates are handled:
>>> BitsInCommon( (1,2,2,3,4), (2,2,4,5,6) )
3
--------------------------------------------------------------------------------
rdkit.Chem.AtomPairs.Utils.CosineSimilarity(v1, v2)¶

Implements the Cosine similarity metric.This is the recommended metric in the LaSSI paper


Arguments:


two vectors (sequences of bit ids)


Returns: a float.
Notes


the vectors must be sorted


>>> print('%.3f'%CosineSimilarity( (1,2,3,4,10), (2,4,6) ))
0.516
>>> print('%.3f'%CosineSimilarity( (1,2,2,3,4), (2,2,4,5,6) ))
0.714
>>> print('%.3f'%CosineSimilarity( (1,2,2,3,4), (1,2,2,3,4) ))
1.000
>>> print('%.3f'%CosineSimilarity( (1,2,2,3,4), (5,6,7) ))
0.000
>>> print('%.3f'%CosineSimilarity( (1,2,2,3,4), () ))
0.000
--------------------------------------------------------------------------------
rdkit.Chem.AtomPairs.Utils.DiceSimilarity(v1, v2, bounds=None)¶

Implements the DICE similarity metric.This is the recommended metric in both the Topological torsions
and Atom pairs papers.


Arguments:


two vectors (sequences of bit ids)


Returns: a float.
Notes


the vectors must be sorted


>>> DiceSimilarity( (1,2,3), (1,2,3) )
1.0
>>> DiceSimilarity( (1,2,3), (5,6) )
0.0
>>> DiceSimilarity( (1,2,3,4), (1,3,5,7) )
0.5
>>> DiceSimilarity( (1,2,3,4,5,6), (1,3) )
0.5


Note that duplicate bit IDs count multiple times:
>>> DiceSimilarity( (1,1,3,4,5,6), (1,1) )
0.5


but only if they are duplicated in both vectors:
>>> DiceSimilarity( (1,1,3,4,5,6), (1,) )==2./7
True


edge case
>>> DiceSimilarity( (), () )
0.0


and bounds check
>>> DiceSimilarity( (1,1,3,4), (1,1))
0.666...
>>> DiceSimilarity( (1,1,3,4), (1,1), bounds=0.3)
0.666...
>>> DiceSimilarity( (1,1,3,4), (1,1), bounds=0.33)
0.666...
>>> DiceSimilarity( (1,1,3,4,5,6), (1,1), bounds=0.34)
0.0
--------------------------------------------------------------------------------
rdkit.Chem.AtomPairs.Utils.Dot(v1, v2)¶
Returns the Dot product between two vectors:
Arguments:


two vectors (sequences of bit ids)


Returns: an integer
Notes


the vectors must be sorted
duplicate bit IDs are counted more than once


>>> Dot( (1,2,3,4,10), (2,4,6) )
2


Here’s how duplicates are handled:
>>> Dot( (1,2,2,3,4), (2,2,4,5,6) )
5
>>> Dot( (1,2,2,3,4), (2,4,5,6) )
2
>>> Dot( (1,2,2,3,4), (5,6) )
0
>>> Dot( (), (5,6) )
0
--------------------------------------------------------------------------------
rdkit.Chem.AtomPairs.Utils.ExplainAtomCode(code, branchSubtract=0, includeChirality=False)¶
Arguments:


the code to be considered
branchSubtract: (optional) the constant that was subtracted off
the number of neighbors before integrating it into the code.
This is used by the topological torsions code.
includeChirality: (optional) Determines whether or not chirality
was included when generating the atom code.


>>> m = Chem.MolFromSmiles('C=CC(=O)O')
>>> code = GetAtomCode(m.GetAtomWithIdx(0))
>>> ExplainAtomCode(code)
('C', 1, 1)
>>> code = GetAtomCode(m.GetAtomWithIdx(1))
>>> ExplainAtomCode(code)
('C', 2, 1)
>>> code = GetAtomCode(m.GetAtomWithIdx(2))
>>> ExplainAtomCode(code)
('C', 3, 1)
>>> code = GetAtomCode(m.GetAtomWithIdx(3))
>>> ExplainAtomCode(code)
('O', 1, 1)
>>> code = GetAtomCode(m.GetAtomWithIdx(4))
>>> ExplainAtomCode(code)
('O', 1, 0)


we can do chirality too, that returns an extra element in the tuple:
>>> m = Chem.MolFromSmiles('C[C@H](F)Cl')
>>> code = GetAtomCode(m.GetAtomWithIdx(1))
>>> ExplainAtomCode(code)
('C', 3, 0)
>>> code = GetAtomCode(m.GetAtomWithIdx(1),includeChirality=True)
>>> ExplainAtomCode(code,includeChirality=True)
('C', 3, 0, 'R')


note that if we don’t ask for chirality, we get the right answer even if
the atom code was calculated with chirality:
>>> ExplainAtomCode(code)
('C', 3, 0)


non-chiral atoms return ‘’ in the 4th field:
>>> code = GetAtomCode(m.GetAtomWithIdx(0),includeChirality=True)
>>> ExplainAtomCode(code,includeChirality=True)
('C', 1, 0, '')


Obviously switching the chirality changes the results:
>>> m = Chem.MolFromSmiles('C[C@@H](F)Cl')
>>> code = GetAtomCode(m.GetAtomWithIdx(1),includeChirality=True)
>>> ExplainAtomCode(code,includeChirality=True)
('C', 3, 0, 'S')
--------------------------------------------------------------------------------
rdkit.Chem.AtomPairs.Utils.NumPiElectrons(atom)¶
DEPRECATED: please use rdMolDescriptors.GetNumPiElectrons instead.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.BRICS.BRICSBuild(fragments, onlyCompleteMols=True, seeds=None, uniquify=True, scrambleReagents=True, maxDepth=3)¶
--------------------------------------------------------------------------------
rdkit.Chem.BRICS.BRICSDecompose(mol, allNodes=None, minFragmentSize=1, onlyUseReactions=None, silent=True, keepNonLeafNodes=False, singlePass=False, returnMols=False)¶
returns the BRICS decomposition for a molecule
>>> from rdkit import Chem
>>> m = Chem.MolFromSmiles('CCCOCc1cc(c2ncccc2)ccc1')
>>> res = list(BRICSDecompose(m))
>>> sorted(res)
['[14*]c1ccccn1', '[16*]c1cccc([16*])c1', '[3*]O[3*]', '[4*]CCC', '[4*]C[8*]']


>>> res = list(BRICSDecompose(m,returnMols=True))
>>> res[0]
<rdkit.Chem.rdchem.Mol object ...>
>>> smis = [Chem.MolToSmiles(x,True) for x in res]
>>> sorted(smis)
['[14*]c1ccccn1', '[16*]c1cccc([16*])c1', '[3*]O[3*]', '[4*]CCC', '[4*]C[8*]']


nexavar, an example from the paper (corrected):
>>> m = Chem.MolFromSmiles('CNC(=O)C1=NC=CC(OC2=CC=C(NC(=O)NC3=CC(=C(Cl)C=C3)C(F)(F)F)C=C2)=C1')
>>> res = list(BRICSDecompose(m))
>>> sorted(res)
['[1*]C([1*])=O', '[1*]C([6*])=O', '[14*]c1cc([16*])ccn1', '[16*]c1ccc(Cl)c([16*])c1', '[16*]c1ccc([16*])cc1', '[3*]O[3*]', '[5*]NC', '[5*]N[5*]', '[8*]C(F)(F)F']


it’s also possible to keep pieces that haven’t been fully decomposed:
>>> m = Chem.MolFromSmiles('CCCOCC')
>>> res = list(BRICSDecompose(m,keepNonLeafNodes=True))
>>> sorted(res)
['CCCOCC', '[3*]OCC', '[3*]OCCC', '[3*]O[3*]', '[4*]CC', '[4*]CCC']


>>> m = Chem.MolFromSmiles('CCCOCc1cc(c2ncccc2)ccc1')
>>> res = list(BRICSDecompose(m,keepNonLeafNodes=True))
>>> sorted(res)
['CCCOCc1cccc(-c2ccccn2)c1', '[14*]c1ccccn1', '[16*]c1cccc(-c2ccccn2)c1', '[16*]c1cccc(COCCC)c1', '[16*]c1cccc([16*])c1', '[3*]OCCC', '[3*]OC[8*]', '[3*]OCc1cccc(-c2ccccn2)c1', '[3*]OCc1cccc([16*])c1', '[3*]O[3*]', '[4*]CCC', '[4*]C[8*]', '[4*]Cc1cccc(-c2ccccn2)c1', '[4*]Cc1cccc([16*])c1', '[8*]COCCC']


or to only do a single pass of decomposition:
>>> m = Chem.MolFromSmiles('CCCOCc1cc(c2ncccc2)ccc1')
>>> res = list(BRICSDecompose(m,singlePass=True))
>>> sorted(res)
['CCCOCc1cccc(-c2ccccn2)c1', '[14*]c1ccccn1', '[16*]c1cccc(-c2ccccn2)c1', '[16*]c1cccc(COCCC)c1', '[3*]OCCC', '[3*]OCc1cccc(-c2ccccn2)c1', '[4*]CCC', '[4*]Cc1cccc(-c2ccccn2)c1', '[8*]COCCC']


setting a minimum size for the fragments:
>>> m = Chem.MolFromSmiles('CCCOCC')
>>> res = list(BRICSDecompose(m,keepNonLeafNodes=True,minFragmentSize=2))
>>> sorted(res)
['CCCOCC', '[3*]OCC', '[3*]OCCC', '[4*]CC', '[4*]CCC']
>>> m = Chem.MolFromSmiles('CCCOCC')
>>> res = list(BRICSDecompose(m,keepNonLeafNodes=True,minFragmentSize=3))
>>> sorted(res)
['CCCOCC', '[3*]OCC', '[4*]CCC']
>>> res = list(BRICSDecompose(m,minFragmentSize=2))
>>> sorted(res)
['[3*]OCC', '[3*]OCCC', '[4*]CC', '[4*]CCC']
--------------------------------------------------------------------------------
rdkit.Chem.BRICS.BreakBRICSBonds(mol, bonds=None, sanitize=True, silent=True)¶
breaks the BRICS bonds in a molecule and returns the results
>>> from rdkit import Chem
>>> m = Chem.MolFromSmiles('CCCOCC')
>>> m2=BreakBRICSBonds(m)
>>> Chem.MolToSmiles(m2,True)
'[3*]O[3*].[4*]CC.[4*]CCC'


a more complicated case:
>>> m = Chem.MolFromSmiles('CCCOCCC(=O)c1ccccc1')
>>> m2=BreakBRICSBonds(m)
>>> Chem.MolToSmiles(m2,True)
'[16*]c1ccccc1.[3*]O[3*].[4*]CCC.[4*]CCC([6*])=O'


can also specify a limited set of bonds to work with:
>>> m = Chem.MolFromSmiles('CCCOCC')
>>> m2 = BreakBRICSBonds(m,[((3, 2), ('3', '4'))])
>>> Chem.MolToSmiles(m2,True)
'[3*]OCC.[4*]CCC'


this can be used as an alternate approach for doing a BRICS decomposition by
following BreakBRICSBonds with a call to Chem.GetMolFrags:
>>> m = Chem.MolFromSmiles('CCCOCC')
>>> m2=BreakBRICSBonds(m)
>>> frags = Chem.GetMolFrags(m2,asMols=True)
>>> [Chem.MolToSmiles(x,True) for x in frags]
['[4*]CCC', '[3*]O[3*]', '[4*]CC']
--------------------------------------------------------------------------------
rdkit.Chem.BRICS.FindBRICSBonds(mol, randomizeOrder=False, silent=True)¶
returns the bonds in a molecule that BRICS would cleave
>>> from rdkit import Chem
>>> m = Chem.MolFromSmiles('CCCOCC')
>>> res = list(FindBRICSBonds(m))
>>> res
[((3, 2), ('3', '4')), ((3, 4), ('3', '4'))]


a more complicated case:
>>> m = Chem.MolFromSmiles('CCCOCCC(=O)c1ccccc1')
>>> res = list(FindBRICSBonds(m))
>>> res
[((3, 2), ('3', '4')), ((3, 4), ('3', '4')), ((6, 8), ('6', '16'))]


we can also randomize the order of the results:
>>> random.seed(23)
>>> res = list(FindBRICSBonds(m,randomizeOrder=True))
>>> sorted(res)
[((3, 2), ('3', '4')), ((3, 4), ('3', '4')), ((6, 8), ('6', '16'))]


Note that this is a generator function :
>>> res = FindBRICSBonds(m)
>>> res
<generator object ...>
>>> next(res)
((3, 2), ('3', '4'))


>>> m = Chem.MolFromSmiles('CC=CC')
>>> res = list(FindBRICSBonds(m))
>>> sorted(res)
[((1, 2), ('7', '7'))]


make sure we don’t match ring bonds:
>>> m = Chem.MolFromSmiles('O=C1NCCC1')
>>> list(FindBRICSBonds(m))
[]


another nice one, make sure environment 8 doesn’t match something connected
to a ring atom:
>>> m = Chem.MolFromSmiles('CC1(C)CCCCC1')
>>> list(FindBRICSBonds(m))
[]
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.BuildFragmentCatalog.BuildCatalog(suppl, maxPts=-1, groupFileName=None, minPath=2, maxPath=6, reportFreq=10)¶
builds a fragment catalog from a set of molecules in a delimited text block
Arguments


suppl: a mol supplier
maxPts: (optional) if provided, this will set an upper bound on the
number of points to be considered
groupFileName: (optional) name of the file containing functional group
information
minPath, maxPath: (optional) names of the minimum and maximum path lengths
to be considered
reportFreq: (optional) how often to display status information


Returns

a FragmentCatalog
--------------------------------------------------------------------------------
rdkit.Chem.BuildFragmentCatalog.CalcGains(suppl, catalog, topN=-1, actName='', acts=None, nActs=2, reportFreq=10, biasList=None, collectFps=0)¶
calculates info gains by constructing fingerprints
DOC

Returns a 2-tuple:
gains matrix
list of fingerprints
--------------------------------------------------------------------------------
rdkit.Chem.BuildFragmentCatalog.CalcGainsFromFps(suppl, fps, topN=-1, actName='', acts=None, nActs=2, reportFreq=10, biasList=None)¶
calculates info gains from a set of fingerprints
DOC
--------------------------------------------------------------------------------
rdkit.Chem.BuildFragmentCatalog.OutputGainsData(outF, gains, cat, nActs=2)¶
--------------------------------------------------------------------------------
rdkit.Chem.BuildFragmentCatalog.ParseArgs(details)¶
--------------------------------------------------------------------------------
rdkit.Chem.BuildFragmentCatalog.ProcessGainsData(inF, delim=',', idCol=0, gainCol=1)¶
reads a list of ids and info gains out of an input file
--------------------------------------------------------------------------------
rdkit.Chem.BuildFragmentCatalog.ScoreFromLists(bitLists, suppl, catalog, maxPts=-1, actName='', acts=None, nActs=2, reportFreq=10)¶
similar to _ScoreMolecules()_, but uses pre-calculated bit lists
for the molecules (this speeds things up a lot)
Arguments


bitLists: sequence of on bit sequences for the input molecules
suppl: the input supplier (we read activities from here)
catalog: the FragmentCatalog
maxPts: (optional) the maximum number of molecules to be
considered
actName: (optional) the name of the molecule’s activity property.
If this is not provided, the molecule’s last property will be used.
nActs: (optional) number of possible activity values
reportFreq: (optional) how often to display status information


Returns

the results table (a 3D array of ints nBits x 2 x nActs)
--------------------------------------------------------------------------------
rdkit.Chem.BuildFragmentCatalog.ScoreMolecules(suppl, catalog, maxPts=-1, actName='', acts=None, nActs=2, reportFreq=10)¶
scores the compounds in a supplier using a catalog
Arguments


suppl: a mol supplier
catalog: the FragmentCatalog
maxPts: (optional) the maximum number of molecules to be
considered
actName: (optional) the name of the molecule’s activity property.
If this is not provided, the molecule’s last property will be used.
acts: (optional) a sequence of activity values (integers).
If not provided, the activities will be read from the molecules.
nActs: (optional) number of possible activity values
reportFreq: (optional) how often to display status information


Returns

a 2-tuple:


the results table (a 3D array of ints nBits x 2 x nActs)
a list containing the on bit lists for each molecule
--------------------------------------------------------------------------------
rdkit.Chem.BuildFragmentCatalog.ShowDetails(catalog, gains, nToDo=-1, outF=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>, idCol=0, gainCol=1, outDelim=', ')¶
gains should be a sequence of sequences.  The idCol entry of each
sub-sequence should be a catalog ID.  _ProcessGainsData()_ provides
suitable input.
--------------------------------------------------------------------------------
rdkit.Chem.BuildFragmentCatalog.SupplierFromDetails(details)¶
--------------------------------------------------------------------------------
rdkit.Chem.BuildFragmentCatalog.Usage()¶
--------------------------------------------------------------------------------
rdkit.Chem.BuildFragmentCatalog.message(msg, dest=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.ChemicalFeatures.MCFF_GetFeaturesForMol(self, mol, includeOnly='', confId=-1)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.ChemUtils.AlignDepict.AlignDepict(mol, core, corePattern=None, acceptFailure=False)¶

Arguments:

mol:          the molecule to be aligned, this will come backwith a single conformer.




core:         a molecule with the core atoms to align to;this should have a depiction.




corePattern:  (optional) an optional molecule to be used togenerate the atom mapping between the molecule
and the core.
--------------------------------------------------------------------------------
rdkit.Chem.ChemUtils.AlignDepict.initParser()¶
Initialize the parser
--------------------------------------------------------------------------------
rdkit.Chem.ChemUtils.AlignDepict.main()¶
Main application
--------------------------------------------------------------------------------
rdkit.Chem.ChemUtils.AlignDepict.processArgs(args)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.ChemUtils.BulkTester.TestMolecule(mol)¶
--------------------------------------------------------------------------------
rdkit.Chem.ChemUtils.BulkTester.TestSupplier(suppl, stopAfter=-1, reportInterval=100, reportTo=<_io.TextIOWrapper name='<stderr>' mode='w' encoding='utf-8'>, nameProp='_Name')¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.ChemUtils.DescriptorUtilities.setDescriptorVersion(version='1.0.0')¶
Set the version on the descriptor function.
Use as a decorator
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.ChemUtils.SDFToCSV.Convert(suppl, outFile, keyCol=None, stopAfter=-1, includeChirality=False, smilesFrom='')¶
--------------------------------------------------------------------------------
rdkit.Chem.ChemUtils.SDFToCSV.existingFile(filename)¶
‘type’ for argparse - check that filename exists
--------------------------------------------------------------------------------
rdkit.Chem.ChemUtils.SDFToCSV.initParser()¶
Initialize the parser for the CLI
--------------------------------------------------------------------------------
rdkit.Chem.ChemUtils.SDFToCSV.main()¶
Main application
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.ChemUtils.TemplateExpand.ConstructSidechains(suppl, sma=None, replace=True, useAll=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.ChemUtils.TemplateExpand.Explode(template, sidechains, outF, autoNames=True, do3D=False, useTethers=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.ChemUtils.TemplateExpand.MoveDummyNeighborsToBeginning(mol, useAll=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.ChemUtils.TemplateExpand.Usage()¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Crippen.MolLogP(*x, **y)¶
Wildman-Crippen LogP value

Uses an atom-based scheme based on the values in the paper:

Wildman and G. M. Crippen JCICS 39 868-873 (1999)





Arguments


inMol: a molecule
addHs: (optional) toggles adding of Hs to the molecule for the calculation.
If true, hydrogens will be added to the molecule and used in the calculation.
--------------------------------------------------------------------------------
rdkit.Chem.Crippen.MolMR(*x, **y)¶
Wildman-Crippen MR value

Uses an atom-based scheme based on the values in the paper:

Wildman and G. M. Crippen JCICS 39 868-873 (1999)





Arguments


inMol: a molecule
addHs: (optional) toggles adding of Hs to the molecule for the calculation.
If true, hydrogens will be added to the molecule and used in the calculation.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Descriptors.CalcMolDescriptors(mol, missingVal=None, silent=True)¶
calculate the full set of descriptors for a molecule

Parameters¶
mol : RDKit molecule
missingVal : float, optional

This will be used if a particular descriptor cannot be calculated


silentbool, optionalif True then exception messages from descriptors will be displayed




Returns¶

dict A dictionary with decriptor names as keys and the descriptor values as values
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors.ExactMolWt(*x, **y)¶
The exact molecular weight of the molecule
>>> ExactMolWt(Chem.MolFromSmiles('CC'))
30.04...
>>> ExactMolWt(Chem.MolFromSmiles('[13CH3]C'))
31.05...
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors.FpDensityMorgan1(x)¶
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors.FpDensityMorgan2(x)¶
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors.FpDensityMorgan3(x)¶
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors.HeavyAtomMolWt(x)¶
The average molecular weight of the molecule ignoring hydrogens
>>> HeavyAtomMolWt(Chem.MolFromSmiles('CC'))
24.02...
>>> HeavyAtomMolWt(Chem.MolFromSmiles('[NH4+].[Cl-]'))
49.46
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors.MaxAbsPartialCharge(mol, force=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors.MaxPartialCharge(mol, force=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors.MinAbsPartialCharge(mol, force=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors.MinPartialCharge(mol, force=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors.MolWt(*x, **y)¶
The average molecular weight of the molecule
>>> MolWt(Chem.MolFromSmiles('CC'))
30.07
>>> MolWt(Chem.MolFromSmiles('[NH4+].[Cl-]'))
53.49...
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors.NumRadicalElectrons(mol)¶

The number of radical electrons the molecule has(says nothing about spin state)


>>> NumRadicalElectrons(Chem.MolFromSmiles('CC'))
0
>>> NumRadicalElectrons(Chem.MolFromSmiles('C[CH3]'))
0
>>> NumRadicalElectrons(Chem.MolFromSmiles('C[CH2]'))
1
>>> NumRadicalElectrons(Chem.MolFromSmiles('C[CH]'))
2
>>> NumRadicalElectrons(Chem.MolFromSmiles('C[C]'))
3
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors.NumValenceElectrons(mol)¶
The number of valence electrons the molecule has
>>> NumValenceElectrons(Chem.MolFromSmiles('CC'))
14
>>> NumValenceElectrons(Chem.MolFromSmiles('C(=O)O'))
18
>>> NumValenceElectrons(Chem.MolFromSmiles('C(=O)[O-]'))
18
>>> NumValenceElectrons(Chem.MolFromSmiles('C(=O)'))
12
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors.setupAUTOCorrDescriptors()¶
Adds AUTOCORR descriptors to the default descriptor lists
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Descriptors3D.Asphericity(*x, **y)¶
molecular asphericity

from Todeschini and Consoni “Descriptors from Molecular Geometry”
Handbook of Chemoinformatics
https://doi.org/10.1002/9783527618279.ch37

Definition:0.5 * ((pm3-pm2)**2 + (pm3-pm1)**2 + (pm2-pm1)**2)/(pm1**2+pm2**2+pm3**2)



Arguments


inMol: a molecule
confId: (optional) the conformation ID to use
useAtomicMasses: (optional) toggles use of atomic masses in the
calculation. Defaults to True
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors3D.CalcMolDescriptors3D(mol, confId=None)¶
Compute all 3D descriptors of a molecule
Arguments:
- mol: the molecule to work with
- confId: conformer ID to work with. If not specified the default (-1) is used
Return:

dictA dictionary with decriptor names as keys and the descriptor values as values

raises a ValueError If the molecule does not have conformers
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors3D.Eccentricity(*x, **y)¶
molecular eccentricity

from Todeschini and Consoni “Descriptors from Molecular Geometry”
Handbook of Chemoinformatics
https://doi.org/10.1002/9783527618279.ch37

Definition:sqrt(pm3**2 -pm1**2) / pm3



Arguments


inMol: a molecule
confId: (optional) the conformation ID to use
useAtomicMasses: (optional) toggles use of atomic masses in the
calculation. Defaults to True
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors3D.InertialShapeFactor(*x, **y)¶
Inertial shape factor

from Todeschini and Consoni “Descriptors from Molecular Geometry”
Handbook of Chemoinformatics
https://doi.org/10.1002/9783527618279.ch37

Definition:pm2 / (pm1*pm3)



Arguments


inMol: a molecule
confId: (optional) the conformation ID to use
useAtomicMasses: (optional) toggles use of atomic masses in the
calculation. Defaults to True
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors3D.NPR1(*x, **y)¶
Normalized principal moments ratio 1 (=I1/I3)

from Sauer and Schwarz JCIM 43:987-1003 (2003)
https://doi.org/10.1021/ci025599w

Arguments


inMol: a molecule
confId: (optional) the conformation ID to use
useAtomicMasses: (optional) toggles use of atomic masses in the
calculation. Defaults to True
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors3D.NPR2(*x, **y)¶
Normalized principal moments ratio 2 (=I2/I3)

from Sauer and Schwarz JCIM 43:987-1003 (2003)
https://doi.org/10.1021/ci025599w

Arguments


inMol: a molecule
confId: (optional) the conformation ID to use
useAtomicMasses: (optional) toggles use of atomic masses in the
calculation. Defaults to True
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors3D.PBF(*x, **y)¶

Plane of best fitfrom: https://doi.org/10.1021/ci300293f


Arguments


inMol: a molecule
confId: (optional) the conformation ID to use
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors3D.PMI1(*x, **y)¶
First (smallest) principal moment of inertia
Arguments


inMol: a molecule
confId: (optional) the conformation ID to use
useAtomicMasses: (optional) toggles use of atomic masses in the
calculation. Defaults to True
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors3D.PMI2(*x, **y)¶
Second principal moment of inertia
Arguments


inMol: a molecule
confId: (optional) the conformation ID to use
useAtomicMasses: (optional) toggles use of atomic masses in the
calculation. Defaults to True
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors3D.PMI3(*x, **y)¶
Third (largest) principal moment of inertia
Arguments


inMol: a molecule
confId: (optional) the conformation ID to use
useAtomicMasses: (optional) toggles use of atomic masses in the
calculation. Defaults to True
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors3D.RadiusOfGyration(*x, **y)¶
Radius of gyration

from Todeschini and Consoni “Descriptors from Molecular Geometry”
Handbook of Chemoinformatics
https://doi.org/10.1002/9783527618279.ch37

Definition:for planar molecules: sqrt( sqrt(pm3*pm2)/MW )
for nonplanar molecules: sqrt( 2*pi*pow(pm3*pm2*pm1,1/3)/MW )



Arguments


inMol: a molecule
confId: (optional) the conformation ID to use
useAtomicMasses: (optional) toggles use of atomic masses in the
calculation. Defaults to True
--------------------------------------------------------------------------------
rdkit.Chem.Descriptors3D.SpherocityIndex(*x, **y)¶
Molecular spherocityIndex

from Todeschini and Consoni “Descriptors from Molecular Geometry”
Handbook of Chemoinformatics
https://doi.org/10.1002/9783527618279.ch37

Definition:3 * pm1 / (pm1+pm2+pm3) where the moments are calculated without weights



Arguments


inMol: a molecule
confId: (optional) the conformation ID to use
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Draw.DebugDraw(mol, size=(350, 350), drawer=None, asSVG=True, useBW=True, includeHLabels=True, addAtomIndices=True, addBondIndices=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.DrawMorganBit(mol, bitId, bitInfo, whichExample=0, **kwargs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.DrawMorganBits(tpls, **kwargs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.DrawMorganEnv(mol, atomId, radius, molSize=(150, 150), baseRad=0.3, useSVG=True, aromaticColor=(0.9, 0.9, 0.2), ringColor=(0.8, 0.8, 0.8), centerColor=(0.6, 0.6, 0.9), extraColor=(0.9, 0.9, 0.9), drawOptions=None, **kwargs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.DrawMorganEnvs(envs, molsPerRow=3, subImgSize=(150, 150), baseRad=0.3, useSVG=True, aromaticColor=(0.9, 0.9, 0.2), ringColor=(0.8, 0.8, 0.8), centerColor=(0.6, 0.6, 0.9), extraColor=(0.9, 0.9, 0.9), legends=None, drawOptions=None, **kwargs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.DrawRDKitBit(mol, bitId, bitInfo, whichExample=0, **kwargs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.DrawRDKitBits(tpls, **kwargs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.DrawRDKitEnv(mol, bondPath, molSize=(150, 150), baseRad=0.3, useSVG=True, aromaticColor=(0.9, 0.9, 0.2), extraColor=(0.9, 0.9, 0.9), nonAromaticColor=None, drawOptions=None, **kwargs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.DrawRDKitEnvs(envs, molsPerRow=3, subImgSize=(150, 150), baseRad=0.3, useSVG=True, aromaticColor=(0.9, 0.9, 0.2), extraColor=(0.9, 0.9, 0.9), nonAromaticColor=None, legends=None, drawOptions=None, **kwargs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.MolToFile(mol, filename, size=(300, 300), kekulize=True, wedgeBonds=True, imageType=None, fitImage=False, options=None, **kwargs)¶
Generates a drawing of a molecule and writes it to a file
--------------------------------------------------------------------------------
rdkit.Chem.Draw.MolToImage(mol, size=(300, 300), kekulize=True, wedgeBonds=True, fitImage=False, options=None, canvas=None, **kwargs)¶
Returns a PIL image containing a drawing of the molecule
ARGUMENTS:


kekulize: run kekulization routine on input mol (default True)
size: final image size, in pixel (default (300,300))
wedgeBonds: draw wedge (stereo) bonds (default True)
highlightAtoms: list of atoms to highlight (default [])
highlightBonds: list of bonds to highlight (default [])
highlightColor: RGB color as tuple (default [1, 0, 0])


NOTE:

use ‘matplotlib.colors.to_rgb()’ to convert string and
HTML color codes into the RGB tuple representation, eg.

from matplotlib.colors import ColorConverter
img = Draw.MolToImage(m, highlightAtoms=[1,2], highlightColor=ColorConverter().to_rgb(‘aqua’))
img.save(“molecule.png”)


RETURNS:

a PIL Image object
--------------------------------------------------------------------------------
rdkit.Chem.Draw.MolToImageFile(mol, filename, size=(300, 300), kekulize=True, wedgeBonds=True, **kwargs)¶
DEPRECATED:  please use MolToFile instead
--------------------------------------------------------------------------------
rdkit.Chem.Draw.MolToMPL(mol, size=(300, 300), kekulize=True, wedgeBonds=True, imageType=None, fitImage=False, options=None, **kwargs)¶
Generates a drawing of a molecule on a matplotlib canvas
--------------------------------------------------------------------------------
rdkit.Chem.Draw.MolToQPixmap(mol, size=(300, 300), kekulize=True, wedgeBonds=True, fitImage=False, options=None, **kwargs)¶
Generates a drawing of a molecule on a Qt QPixmap
--------------------------------------------------------------------------------
rdkit.Chem.Draw.MolsMatrixToGridImage(molsMatrix, subImgSize=(200, 200), legendsMatrix=None, highlightAtomListsMatrix=None, highlightBondListsMatrix=None, useSVG=False, returnPNG=False, **kwargs)¶
Creates a mol grid image from a nested data structure (where each data substructure represents a row),
padding rows as needed so all rows are the length of the longest row



ARGUMENTS:


molsMatrix: A two-deep nested data structure of RDKit molecules to draw,


iterable of iterables (for example list of lists) of RDKit molecules


subImgSize: The size of a cell in the drawing; passed through to MolsToGridImage (default (200, 200))
legendsMatrix: A two-deep nested data structure of strings to label molecules with,


iterable of iterables (for example list of lists) of strings (default None)


highlightAtomListsMatrix: A three-deep nested data structure of integers of atoms to highlight,


iterable of iterables (for example list of lists) of integers (default None)


highlightBondListsMatrix: A three-deep nested data structure of integers of bonds to highlight,


iterable of iterables (for example list of lists) of integers (default None)


useSVG: Whether to return an SVG (if true) or PNG (if false);


passed through to MolsToGridImage (default false)


returnPNG: Whether to return PNG data (if true) or a PIL object for a PNG image file (if false);


has no effect if useSVG is true; passed through to MolsToGridImage (default false)


kwargs: Any other keyword arguments are passed to MolsToGridImage


NOTES:

To include a blank cell in the middle of a row, supply None for that entry in molsMatrix.
You do not need to do that for empty cells at the end of a row; 
this function will automatically pad rows so that all rows are the same length.
This function is useful when each row has some meaning,
for example the generation in a mass spectrometry fragmentation tree–refer to 
example at https://en.wikipedia.org/wiki/Fragmentation_(mass_spectrometry).
If you want to display a set molecules where each row does not have any specific meaning,
use MolsToGridImage instead.
This function nests data structures one additional level beyond the analogous function MolsToGridImage
(in which the molecules and legends are non-nested lists, 
and the highlight parameters are two-deep nested lists)

RETURNS:

A grid of molecular images in one of these formats:

useSVG=False and returnPNG=False (default): A PIL object for a PNG image file
useSVG=False and returnPNG=True: PNG data
useSVG=True: An SVG string


EXAMPLES:

from rdkit import Chem
from rdkit.Chem.Draw import MolsMatrixToGridImage, rdMolDraw2D
FCl = Chem.MolFromSmiles(“FCl”)
molsMatrix = [[FCl, FCl], [FCl, None, FCl]]
# Minimal example: Only molsMatrix is supplied,
# result will be a drawing containing (where each row contains molecules):
# F-Cl    F-Cl
# F-Cl            F-Cl
img = MolsMatrixToGridImage(molsMatrix)
img.save(“MolsMatrixToGridImageMinimal.png”)
# img is a PIL object for a PNG image file like:
# <PIL.PngImagePlugin.PngImageFile image mode=RGB size=600x200 at 0x1648CC390>
# Drawing will be saved as PNG file MolsMatrixToGridImageMinimal.png
# Exhaustive example: All parameters are supplied,
# result will be a drawing containing (where each row of molecules is followed by a row of legends):
# 1 F-Cl 0              1 F-Cl 0
# no highlighting       bond highlighted         
# 1 F-Cl 0                                  1 F-Cl 0
# sodium highlighted                        chloride and bond highlighted
legendsMatrix = [[“no highlighting”, “bond highlighted”], 
[“F highlighted”, “”, “Cl and bond highlighted”]]
highlightAtomListsMatrix = [[[],[]], [[0], None, [1]]]
highlightBondListsMatrix = [[[],[0]], [[], None, [0]]]
dopts = rdMolDraw2D.MolDrawOptions()
dopts.addAtomIndices = True
img_binary = MolsMatrixToGridImage(molsMatrix=molsMatrix, subImgSize=(300, 400), 
legendsMatrix=legendsMatrix, highlightAtomListsMatrix=highlightAtomListsMatrix, 
highlightBondListsMatrix=highlightBondListsMatrix, useSVG=False, returnPNG=True, drawOptions=dopts)
print(img_binary[:20])
# Prints a binary string: b’x89PNGrnx1anx00x00x00rIHDRx00x00x03x84’
--------------------------------------------------------------------------------
rdkit.Chem.Draw.MolsToGridImage(mols, molsPerRow=3, subImgSize=(200, 200), legends=None, highlightAtomLists=None, highlightBondLists=None, useSVG=False, returnPNG=False, **kwargs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.MolsToImage(mols, subImgSize=(200, 200), legends=None, **kwargs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.ReactionToImage(rxn, subImgSize=(200, 200), useSVG=False, drawOptions=None, returnPNG=False, **kwargs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.SetComicMode(opts)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.ShowMol(mol, size=(300, 300), kekulize=True, wedgeBonds=True, title='RDKit Molecule', stayInFront=True, **kwargs)¶
Generates a picture of a molecule and displays it in a Tkinter window
--------------------------------------------------------------------------------
rdkit.Chem.Draw.calcAtomGaussians(mol, a=0.03, step=0.02, weights=None)¶
useful things to do with these:
fig.axes[0].imshow(z,cmap=cm.gray,interpolation=’bilinear’,origin=’lower’,extent=(0,1,0,1))
fig.axes[0].contour(x,y,z,20,colors=’k’)
fig=Draw.MolToMPL(m);
contribs=Crippen.rdMolDescriptors._CalcCrippenContribs(m)
logps,mrs=zip(*contribs)
x,y,z=Draw.calcAtomGaussians(m,0.03,step=0.01,weights=logps)
fig.axes[0].imshow(z,cmap=cm.jet,interpolation=’bilinear’,origin=’lower’,extent=(0,1,0,1))
fig.axes[0].contour(x,y,z,20,colors=’k’,alpha=0.5)
fig.savefig(‘coumlogps.colored.png’,bbox_inches=’tight’)
--------------------------------------------------------------------------------
rdkit.Chem.Draw.shouldKekulize(mol, kekulize)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Draw.IPythonConsole.DisableSubstructMatchRendering()¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.IPythonConsole.DrawMorganBit(mol, bitId, bitInfo, drawOptions=<rdkit.Chem.Draw.rdMolDraw2D.MolDrawOptions object>, **kwargs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.IPythonConsole.DrawMorganBits(*args, drawOptions=<rdkit.Chem.Draw.rdMolDraw2D.MolDrawOptions object>, **kwargs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.IPythonConsole.DrawRDKitBit(mol, bitId, bitInfo, drawOptions=<rdkit.Chem.Draw.rdMolDraw2D.MolDrawOptions object>, **kwargs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.IPythonConsole.DrawRDKitBits(*args, drawOptions=<rdkit.Chem.Draw.rdMolDraw2D.MolDrawOptions object>, **kwargs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.IPythonConsole.EnableSubstructMatchRendering()¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.IPythonConsole.InstallIPythonRenderer()¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.IPythonConsole.ShowMols(mols, maxMols=50, **kwargs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.IPythonConsole.UninstallIPythonRenderer()¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.IPythonConsole.addMolToView(mol, view, confId=-1, drawAs=None)¶
--------------------------------------------------------------------------------
rdkit.Chem.Draw.IPythonConsole.display_pil_image(img)¶
displayhook function for PIL Images, rendered as PNG
--------------------------------------------------------------------------------
rdkit.Chem.Draw.IPythonConsole.drawMol3D(m, view=None, confId=-1, drawAs=None, bgColor=None, size=None)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Draw.MolDrawing.cmp(t1, t2)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Draw.rdMolDraw2D.ContourAndDrawGaussians((MolDraw2D)drawer, (AtomPairsParameters)locs, (AtomPairsParameters)heights, (AtomPairsParameters)widths[, (int)nContours=10[, (AtomPairsParameters)levels=None[, (ContourParams)params=<rdkit.Chem.Draw.rdMolDraw2D.ContourParams object at 0x76141a9b92f0>[, (AtomPairsParameters)mol=None]]]]) → None :¶
Generates and draws contours for a set of gaussians


drawer: the MolDraw2D object to use
locs: locations of the gaussians
heights: the heights (or weights) of the gaussians
widths: the standard deviations of the gaussians
nContours: the number of contours to draw
levels: the contours to use
ps: additional parameters controlling the contouring.
mol: molecule used to help set scale.

The values are calculated on a grid with spacing params.gridResolution.
If params.setScale  is set, the grid size will be calculated based on the
locations of the gaussians and params.extraGridPadding. Otherwise the current
size of the viewport will be used.
If the levels argument is empty, the contour levels will be determined
automatically from the max and min values on the grid and levels will
be updated to include the contour levels.
If params.fillGrid is set, the data on the grid will also be drawn using
the color scheme in params.colourMap
If mol is not 0, uses the molecule to help set the scale, assuming that
it will be drawn over the plot, so needs to fit on it.

*/

C++ signature :void ContourAndDrawGaussians(RDKit::MolDraw2D {lvalue},boost::python::api::object,boost::python::api::object,boost::python::api::object [,unsigned int=10 [,boost::python::api::object=None [,RDKit::MolDraw2DUtils::ContourParams=<rdkit.Chem.Draw.rdMolDraw2D.ContourParams object at 0x76141a9b92f0> [,boost::python::api::object=None]]]])
--------------------------------------------------------------------------------
rdkit.Chem.Draw.rdMolDraw2D.ContourAndDrawGrid((MolDraw2D)drawer, (AtomPairsParameters)data, (AtomPairsParameters)xcoords, (AtomPairsParameters)ycoords[, (int)nContours=10[, (AtomPairsParameters)levels=None[, (ContourParams)params=<rdkit.Chem.Draw.rdMolDraw2D.ContourParams object at 0x76141a9b93c0>[, (AtomPairsParameters)mol=None]]]]) → None :¶
Generates and draws contours for data on a grid


drawer: the MolDraw2D object to use
data: numpy array with the data to be contoured
xcoords: the x coordinates of the grid
ycoords: the y coordinates of the grid
nContours: the number of contours to draw
levels: the contours to use
ps: additional parameters controlling the contouring
mol: molecule used to help set scale.

The values are calculated on a grid with spacing params.gridResolution.
If params.setScale  is set, the grid size will be calculated based on the
locations of the gaussians and params.extraGridPadding. Otherwise the current
size of the viewport will be used.
If the levels argument is empty, the contour levels will be determined
automatically from the max and min values on the grid and levels will
be updated to include the contour levels.
If params.fillGrid is set, the data on the grid will also be drawn using
the color scheme in params.colourMap
If mol is not 0, uses the molecule to help set the scale, assuming that
it will be drawn over the plot, so needs to fit on it.

*/

C++ signature :void ContourAndDrawGrid(RDKit::MolDraw2D {lvalue},boost::python::api::object {lvalue},boost::python::api::object {lvalue},boost::python::api::object {lvalue} [,unsigned int=10 [,boost::python::api::object {lvalue}=None [,RDKit::MolDraw2DUtils::ContourParams=<rdkit.Chem.Draw.rdMolDraw2D.ContourParams object at 0x76141a9b93c0> [,boost::python::api::object=None]]]])
--------------------------------------------------------------------------------
rdkit.Chem.Draw.rdMolDraw2D.DrawMoleculeACS1996((MolDraw2D)drawer, (Mol)mol[, (str)legend=''[, (AtomPairsParameters)highlightAtoms=None[, (AtomPairsParameters)highlightBonds=None[, (AtomPairsParameters)highlightAtomColors=None[, (AtomPairsParameters)highlightBondColors=None[, (AtomPairsParameters)highlightAtomRadii=None[, (int)confId=-1]]]]]]]) → None :¶
Draws molecule in ACS 1996 mode.

C++ signature :void DrawMoleculeACS1996(RDKit::MolDraw2D {lvalue},RDKit::ROMol [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’ [,boost::python::api::object=None [,boost::python::api::object=None [,boost::python::api::object=None [,boost::python::api::object=None [,boost::python::api::object=None [,int=-1]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.Draw.rdMolDraw2D.MeanBondLength((Mol)mol[, (int)confId=-1]) → float :¶
Calculate the mean bond length for the molecule.

C++ signature :double MeanBondLength(RDKit::ROMol [,int=-1])
--------------------------------------------------------------------------------
rdkit.Chem.Draw.rdMolDraw2D.MolToACS1996SVG((Mol)mol[, (str)legend=''[, (AtomPairsParameters)highlightAtoms=None[, (AtomPairsParameters)highlightBonds=None[, (AtomPairsParameters)highlightAtomColors=None[, (AtomPairsParameters)highlightBondColors=None[, (AtomPairsParameters)highlightAtomRadii=None[, (int)confId=-1]]]]]]]) → str :¶
Returns ACS 1996 mode svg for a molecule

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToACS1996SVG(RDKit::ROMol [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’ [,boost::python::api::object=None [,boost::python::api::object=None [,boost::python::api::object=None [,boost::python::api::object=None [,boost::python::api::object=None [,int=-1]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.Draw.rdMolDraw2D.MolToSVG((Mol)mol[, (int)width=300[, (int)height=300[, (AtomPairsParameters)highlightAtoms=None[, (bool)kekulize=True[, (int)lineWidthMult=1[, (bool)fontSize=12[, (int)includeAtomCircles=True]]]]]]]) → str :¶
Returns svg for a molecule

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToSVG(RDKit::ROMol [,unsigned int=300 [,unsigned int=300 [,boost::python::api::object=None [,bool=True [,unsigned int=1 [,bool=12 [,int=True]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.Draw.rdMolDraw2D.PrepareAndDrawMolecule((MolDraw2D)drawer, (Mol)mol[, (str)legend=''[, (AtomPairsParameters)highlightAtoms=None[, (AtomPairsParameters)highlightBonds=None[, (AtomPairsParameters)highlightAtomColors=None[, (AtomPairsParameters)highlightBondColors=None[, (AtomPairsParameters)highlightAtomRadii=None[, (int)confId=-1[, (bool)kekulize=True]]]]]]]]) → None :¶
Preps a molecule for drawing and actually draws it

C++ signature :void PrepareAndDrawMolecule(RDKit::MolDraw2D {lvalue},RDKit::ROMol [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’ [,boost::python::api::object=None [,boost::python::api::object=None [,boost::python::api::object=None [,boost::python::api::object=None [,boost::python::api::object=None [,int=-1 [,bool=True]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.Draw.rdMolDraw2D.PrepareMolForDrawing((Mol)mol[, (bool)kekulize=True[, (bool)addChiralHs=True[, (bool)wedgeBonds=True[, (bool)forceCoords=False[, (bool)wavyBonds=False]]]]]) → Mol :¶
Does some cleanup operations on the molecule to prepare it to draw nicely.
The operations include: kekulization, addition of chiral Hs (so that we can draw
wedges to them), wedging of bonds at chiral centers, and generation of a 2D
conformation if the molecule does not already have a conformation
Returns a modified copy of the molecule.

C++ signature :RDKit::ROMol* PrepareMolForDrawing(RDKit::ROMol const* [,bool=True [,bool=True [,bool=True [,bool=False [,bool=False]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.Draw.rdMolDraw2D.SetACS1996Mode((MolDrawOptions)drawOptions, (float)meanBondLength) → None :¶
Set the draw options to produce something as close as possible to
the ACS 1996 guidelines as described at
https://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style/Chemistry/Structure_drawing


MolDrawOptions opt - the options what will be changed
float meanBondLength - mean bond length of the molecule

Works best if the MolDraw2D object is created with width and height -1 (a
flexiCanvas).
The mean bond length may be calculated with MeanBondLength.
It is used to calculate the offset for the lines in multiple bonds.

Options changed are:bondLineWidth = 0.6
scaleBondWidth = false
scalingFactor = 14.4 / meanBondLen
multipleBondOffset = 0.18
highlightBondWidthMultiplier = 32
setMonochromeMode - black and white
fixedFontSize = 10
additionalAtomLabelPadding = 0.066
fontFile - if it isn’t set already, then if RDBASE is set and the file

exists, uses $RDBASE/Data/Fonts/FreeSans.ttf.  Otherwise uses
BuiltinRobotoRegular.



*/


C++ signature :void SetACS1996Mode(RDKit::MolDrawOptions {lvalue},double)
--------------------------------------------------------------------------------
rdkit.Chem.Draw.rdMolDraw2D.SetDarkMode((MolDrawOptions)d2d) → None :¶
set dark mode for a MolDrawOptions object


C++ signature :void SetDarkMode(RDKit::MolDrawOptions {lvalue})




SetDarkMode( (MolDraw2D)d2d) -> None :set dark mode for a MolDraw2D object

C++ signature :void SetDarkMode(RDKit::MolDraw2D {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.Draw.rdMolDraw2D.SetMonochromeMode((MolDrawOptions)options, (tuple)fgColour, (tuple)bgColour) → None :¶
set monochrome mode for a MolDrawOptions object


C++ signature :void SetMonochromeMode(RDKit::MolDrawOptions {lvalue},boost::python::tuple,boost::python::tuple)




SetMonochromeMode( (MolDraw2D)drawer, (tuple)fgColour, (tuple)bgColour) -> None :set monochrome mode for a MolDraw2D object

C++ signature :void SetMonochromeMode(RDKit::MolDraw2D {lvalue},boost::python::tuple,boost::python::tuple)
--------------------------------------------------------------------------------
rdkit.Chem.Draw.rdMolDraw2D.UpdateDrawerParamsFromJSON((MolDraw2D)drawer, (str)json) → None :¶

C++ signature :void UpdateDrawerParamsFromJSON(RDKit::MolDraw2D {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.Draw.rdMolDraw2D.UpdateMolDrawOptionsFromJSON((MolDrawOptions)opts, (str)json) → None :¶

C++ signature :void UpdateMolDrawOptionsFromJSON(RDKit::MolDrawOptions {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Draw.SimilarityMaps.GetAPFingerprint(mol, atomId=-1, fpType='normal', nBits=2048, minLength=1, maxLength=30, nBitsPerEntry=4, **kwargs)¶
Calculates the atom pairs fingerprint with the torsions of atomId removed.

Parameters:mol – the molecule of interest
atomId – the atom to remove the pairs for (if -1, no pair is removed)
fpType – the type of AP fingerprint (‘normal’, ‘hashed’, ‘bv’)
nBits – the size of the bit vector (only for fpType=’bv’)
minLength – the minimum path length for an atom pair
maxLength – the maxmimum path length for an atom pair
nBitsPerEntry – the number of bits available for each pair
--------------------------------------------------------------------------------
rdkit.Chem.Draw.SimilarityMaps.GetAtomicWeightsForFingerprint(refMol, probeMol, fpFunction, metric=<Boost.Python.function object>)¶
Calculates the atomic weights for the probe molecule
based on a fingerprint function and a metric.

Parameters:refMol – the reference molecule
probeMol – the probe molecule
fpFunction – the fingerprint function
metric – the similarity metric

Note:If fpFunction needs additional parameters, use a lambda construct
--------------------------------------------------------------------------------
rdkit.Chem.Draw.SimilarityMaps.GetAtomicWeightsForModel(probeMol, fpFunction, predictionFunction)¶
Calculates the atomic weights for the probe molecule based on
a fingerprint function and the prediction function of a ML model.

Parameters:probeMol – the probe molecule
fpFunction – the fingerprint function
predictionFunction – the prediction function of the ML model
--------------------------------------------------------------------------------
rdkit.Chem.Draw.SimilarityMaps.GetMorganFingerprint(mol, atomId=-1, radius=2, fpType='bv', nBits=2048, useFeatures=False, **kwargs)¶
Calculates the Morgan fingerprint with the environments of atomId removed.

Parameters:mol – the molecule of interest
radius – the maximum radius
fpType – the type of Morgan fingerprint: ‘count’ or ‘bv’
atomId – the atom to remove the environments for (if -1, no environments is removed)
nBits – the size of the bit vector (only for fpType = ‘bv’)
useFeatures – if false: ConnectivityMorgan, if true: FeatureMorgan


any additional keyword arguments will be passed to the fingerprinting function.
--------------------------------------------------------------------------------
rdkit.Chem.Draw.SimilarityMaps.GetRDKFingerprint(mol, atomId=-1, fpType='bv', nBits=2048, minPath=1, maxPath=5, nBitsPerHash=2, **kwargs)¶
Calculates the RDKit fingerprint with the paths of atomId removed.

Parameters:mol – the molecule of interest
atomId – the atom to remove the paths for (if -1, no path is removed)
fpType – the type of RDKit fingerprint: ‘bv’
nBits – the size of the bit vector
minPath – minimum path length
maxPath – maximum path length
nBitsPerHash – number of to set per path
--------------------------------------------------------------------------------
rdkit.Chem.Draw.SimilarityMaps.GetSimilarityMapForFingerprint(refMol, probeMol, fpFunction, metric=<Boost.Python.function object>, **kwargs)¶
Generates the similarity map for a given reference and probe molecule,
fingerprint function and similarity metric.

Parameters:refMol – the reference molecule
probeMol – the probe molecule
fpFunction – the fingerprint function
metric – the similarity metric.
kwargs – additional arguments for drawing
--------------------------------------------------------------------------------
rdkit.Chem.Draw.SimilarityMaps.GetSimilarityMapForModel(probeMol, fpFunction, predictionFunction, **kwargs)¶
Generates the similarity map for a given ML model and probe molecule,
and fingerprint function.

Parameters:probeMol – the probe molecule
fpFunction – the fingerprint function
predictionFunction – the prediction function of the ML model
kwargs – additional arguments for drawing
--------------------------------------------------------------------------------
rdkit.Chem.Draw.SimilarityMaps.GetSimilarityMapFromWeights(mol, weights, colorMap=None, scale=-1, size=(250, 250), sigma=None, coordScale=1.5, step=0.01, colors='k', contourLines=10, alpha=0.5, draw2d=None, **kwargs)¶
Generates the similarity map for a molecule given the atomic weights.

Parameters:mol – the molecule of interest
colorMap – the matplotlib color map scheme, default is custom PiWG color map
scale – the scaling: scale < 0 -> the absolute maximum weight is used as maximum scale

scale = double -> this is the maximum scale

size – the size of the figure
sigma – the sigma for the Gaussians
coordScale – scaling factor for the coordinates
step – the step for calcAtomGaussian
colors – color of the contour lines
contourLines – if integer number N: N contour lines are drawn

if list(numbers): contour lines at these numbers are drawn

alpha – the alpha blending value for the contour lines
kwargs – additional arguments for drawing
--------------------------------------------------------------------------------
rdkit.Chem.Draw.SimilarityMaps.GetStandardizedWeights(weights)¶
Normalizes the weights,
such that the absolute maximum weight equals 1.0.

Parameters:weights – the list with the atomic weights
--------------------------------------------------------------------------------
rdkit.Chem.Draw.SimilarityMaps.GetTTFingerprint(mol, atomId=-1, fpType='normal', nBits=2048, targetSize=4, nBitsPerEntry=4, **kwargs)¶
Calculates the topological torsion fingerprint with the pairs of atomId removed.

Parameters:mol – the molecule of interest
atomId – the atom to remove the torsions for (if -1, no torsion is removed)
fpType – the type of TT fingerprint (‘normal’, ‘hashed’, ‘bv’)
nBits – the size of the bit vector (only for fpType=’bv’)
minLength – the minimum path length for an atom pair
maxLength – the maxmimum path length for an atom pair
nBitsPerEntry – the number of bits available for each torsion


any additional keyword arguments will be passed to the fingerprinting function.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.EnumerateHeterocycles.EnumerateHeterocycles(inputmol, depth=None)¶
Enumerate possible relevant heterocycles on the given input
molecule.
>>> from rdkit.Chem.EnumerateHeterocycles import EnumerateHeterocycles
>>> from rdkit import Chem
>>> for smi in sorted(Chem.MolToSmiles(m) for m in EnumerateHeterocycles(Chem.MolFromSmiles('c1ccccc1'))):
...     print(smi)
c1ccccc1
c1ccncc1
c1ccnnc1
c1cnccn1
c1cncnc1
c1cnncn1
c1cnnnc1
c1ncncn1


The algorithm works by mutating only one atom at a time. The depth
parameter can be used to control the level of this recursion. For
example, only enumerating aromatic rings that are one atom different:
>>> for smi in sorted(Chem.MolToSmiles(m) for m in EnumerateHeterocycles(Chem.MolFromSmiles('n1ccccc1'), depth=1)):
...     print(smi)
c1ccccc1
c1ccnnc1
c1cnccn1
c1cncnc1
--------------------------------------------------------------------------------
rdkit.Chem.EnumerateHeterocycles.GetHeterocycleReactionSmarts()¶
Return a list of the individual patterns for mutating individual
atoms in aromatic rings to generate a new aromatic ring. The
elements are collections.namedtuple objects with the following
fields:
SMARTS - the left side of the reaction SMARTS pattern, matches the atom to mutate
CONVERT_FROM - the element type being converted: c, n, o, s
CONVERT_TO - the right side of the reaction SMARTS pattern, there can be multiple destination types separated with a comma, these should map to multiple actual reaction objects
EXAMPLE - an example aromatic ring system that SMARTS should match against, used in test cases
NEGATIVE_EXAMPLE - an example aromatic ring system that SMART should NOT match against, used in test cases
DESCRIPTION - a human readable description of the SMARTS pattern matching
--------------------------------------------------------------------------------
rdkit.Chem.EnumerateHeterocycles.GetHeterocycleReactions()¶
Return RDKit ChemicalReaction objects of the reaction SMARTS
returned from GetHeterocyleReactionSmarts.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.EnumerateStereoisomers.EnumerateStereoisomers(m, options=<rdkit.Chem.EnumerateStereoisomers.StereoEnumerationOptions object>, verbose=False)¶
returns a generator that yields possible stereoisomers for a molecule

Arguments:
m: the molecule to work with
options: parameters controlling the enumeration
verbose: toggles how verbose the output is



If m has stereogroups, they will be expanded
A small example with 3 chiral atoms and 1 chiral bond (16 theoretical stereoisomers):
>>> from rdkit import Chem
>>> from rdkit.Chem.EnumerateStereoisomers import EnumerateStereoisomers, StereoEnumerationOptions
>>> m = Chem.MolFromSmiles('BrC=CC1OC(C2)(F)C2(Cl)C1')
>>> isomers = tuple(EnumerateStereoisomers(m))
>>> len(isomers)
16
>>> for smi in sorted(Chem.MolToSmiles(x, isomericSmiles=True) for x in isomers):
...     print(smi)
...
F[C@@]12C[C@@]1(Cl)C[C@@H](/C=C/Br)O2
F[C@@]12C[C@@]1(Cl)C[C@@H](/C=C\Br)O2
F[C@@]12C[C@@]1(Cl)C[C@H](/C=C/Br)O2
F[C@@]12C[C@@]1(Cl)C[C@H](/C=C\Br)O2
F[C@@]12C[C@]1(Cl)C[C@@H](/C=C/Br)O2
F[C@@]12C[C@]1(Cl)C[C@@H](/C=C\Br)O2
F[C@@]12C[C@]1(Cl)C[C@H](/C=C/Br)O2
F[C@@]12C[C@]1(Cl)C[C@H](/C=C\Br)O2
F[C@]12C[C@@]1(Cl)C[C@@H](/C=C/Br)O2
F[C@]12C[C@@]1(Cl)C[C@@H](/C=C\Br)O2
F[C@]12C[C@@]1(Cl)C[C@H](/C=C/Br)O2
F[C@]12C[C@@]1(Cl)C[C@H](/C=C\Br)O2
F[C@]12C[C@]1(Cl)C[C@@H](/C=C/Br)O2
F[C@]12C[C@]1(Cl)C[C@@H](/C=C\Br)O2
F[C@]12C[C@]1(Cl)C[C@H](/C=C/Br)O2
F[C@]12C[C@]1(Cl)C[C@H](/C=C\Br)O2


Because the molecule is constrained, not all of those isomers can
actually exist. We can check that:
>>> opts = StereoEnumerationOptions(tryEmbedding=True)
>>> isomers = tuple(EnumerateStereoisomers(m, options=opts))
>>> len(isomers)
8
>>> for smi in sorted(Chem.MolToSmiles(x,isomericSmiles=True) for x in isomers):
...     print(smi)
...
F[C@@]12C[C@]1(Cl)C[C@@H](/C=C/Br)O2
F[C@@]12C[C@]1(Cl)C[C@@H](/C=C\Br)O2
F[C@@]12C[C@]1(Cl)C[C@H](/C=C/Br)O2
F[C@@]12C[C@]1(Cl)C[C@H](/C=C\Br)O2
F[C@]12C[C@@]1(Cl)C[C@@H](/C=C/Br)O2
F[C@]12C[C@@]1(Cl)C[C@@H](/C=C\Br)O2
F[C@]12C[C@@]1(Cl)C[C@H](/C=C/Br)O2
F[C@]12C[C@@]1(Cl)C[C@H](/C=C\Br)O2


Or we can force the output to only give us unique isomers:
>>> m = Chem.MolFromSmiles('FC(Cl)C=CC=CC(F)Cl')
>>> opts = StereoEnumerationOptions(unique=True)
>>> isomers = tuple(EnumerateStereoisomers(m, options=opts))
>>> len(isomers)
10
>>> for smi in sorted(Chem.MolToSmiles(x,isomericSmiles=True) for x in isomers):
...     print(smi)
...
F[C@@H](Cl)/C=C/C=C/[C@@H](F)Cl
F[C@@H](Cl)/C=C\C=C/[C@@H](F)Cl
F[C@@H](Cl)/C=C\C=C\[C@@H](F)Cl
F[C@H](Cl)/C=C/C=C/[C@@H](F)Cl
F[C@H](Cl)/C=C/C=C/[C@H](F)Cl
F[C@H](Cl)/C=C/C=C\[C@@H](F)Cl
F[C@H](Cl)/C=C\C=C/[C@@H](F)Cl
F[C@H](Cl)/C=C\C=C/[C@H](F)Cl
F[C@H](Cl)/C=C\C=C\[C@@H](F)Cl
F[C@H](Cl)/C=C\C=C\[C@H](F)Cl


By default the code only expands unspecified stereocenters:
>>> m = Chem.MolFromSmiles('BrC=C[C@H]1OC(C2)(F)C2(Cl)C1')
>>> isomers = tuple(EnumerateStereoisomers(m))
>>> len(isomers)
8
>>> for smi in sorted(Chem.MolToSmiles(x,isomericSmiles=True) for x in isomers):
...     print(smi)
...
F[C@@]12C[C@@]1(Cl)C[C@@H](/C=C/Br)O2
F[C@@]12C[C@@]1(Cl)C[C@@H](/C=C\Br)O2
F[C@@]12C[C@]1(Cl)C[C@@H](/C=C/Br)O2
F[C@@]12C[C@]1(Cl)C[C@@H](/C=C\Br)O2
F[C@]12C[C@@]1(Cl)C[C@@H](/C=C/Br)O2
F[C@]12C[C@@]1(Cl)C[C@@H](/C=C\Br)O2
F[C@]12C[C@]1(Cl)C[C@@H](/C=C/Br)O2
F[C@]12C[C@]1(Cl)C[C@@H](/C=C\Br)O2


But we can change that behavior:
>>> opts = StereoEnumerationOptions(onlyUnassigned=False)
>>> isomers = tuple(EnumerateStereoisomers(m, options=opts))
>>> len(isomers)
16


Since the result is a generator, we can allow exploring at least parts of very
large result sets:
>>> m = Chem.MolFromSmiles('Br' + '[CH](Cl)' * 20 + 'F')
>>> opts = StereoEnumerationOptions(maxIsomers=0)
>>> isomers = EnumerateStereoisomers(m, options=opts)
>>> for x in range(5):
...   print(Chem.MolToSmiles(next(isomers),isomericSmiles=True))
F[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)Br
F[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@H](Cl)Br
F[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@H](Cl)[C@@H](Cl)Br
F[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@H](Cl)[C@H](Cl)Br
F[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@H](Cl)[C@@H](Cl)[C@@H](Cl)Br


Or randomly sample a small subset. Note that if we want that sampling to be consistent
across python versions we need to provide a random number seed:
>>> m = Chem.MolFromSmiles('Br' + '[CH](Cl)' * 20 + 'F')
>>> opts = StereoEnumerationOptions(maxIsomers=3,rand=0xf00d)
>>> isomers = EnumerateStereoisomers(m, options=opts)
>>> for smi in isomers: #sorted(Chem.MolToSmiles(x, isomericSmiles=True) for x in isomers):
...     print(Chem.MolToSmiles(smi))
F[C@@H](Cl)[C@H](Cl)[C@H](Cl)[C@H](Cl)[C@@H](Cl)[C@H](Cl)[C@H](Cl)[C@@H](Cl)[C@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@H](Cl)[C@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@H](Cl)[C@H](Cl)[C@H](Cl)[C@@H](Cl)Br
F[C@H](Cl)[C@H](Cl)[C@H](Cl)[C@@H](Cl)[C@H](Cl)[C@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@H](Cl)[C@@H](Cl)[C@H](Cl)[C@H](Cl)[C@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@H](Cl)[C@H](Cl)[C@@H](Cl)[C@@H](Cl)Br
F[C@@H](Cl)[C@@H](Cl)[C@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@H](Cl)[C@@H](Cl)[C@@H](Cl)[C@H](Cl)[C@@H](Cl)Br
--------------------------------------------------------------------------------
rdkit.Chem.EnumerateStereoisomers.GetStereoisomerCount(m, options=<rdkit.Chem.EnumerateStereoisomers.StereoEnumerationOptions object>)¶
returns an estimate (upper bound) of the number of possible stereoisomers for a molecule

Arguments:

m: the molecule to work with
options: parameters controlling the enumeration


>>> from rdkit import Chem
>>> from rdkit.Chem.EnumerateStereoisomers import EnumerateStereoisomers, StereoEnumerationOptions
>>> m = Chem.MolFromSmiles('BrC(Cl)(F)CCC(O)C')
>>> GetStereoisomerCount(m)
4
>>> m = Chem.MolFromSmiles('CC(Cl)(O)C')
>>> GetStereoisomerCount(m)
1


double bond stereochemistry is also included:
>>> m = Chem.MolFromSmiles('BrC(Cl)(F)C=CC(O)C')
>>> GetStereoisomerCount(m)
8
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.EState.AtomTypes.BuildPatts(rawV=None)¶
Internal Use Only
--------------------------------------------------------------------------------
rdkit.Chem.EState.AtomTypes.TypeAtoms(mol)¶
assigns each atom in a molecule to an EState type
Returns:

list of tuples (atoms can possibly match multiple patterns) with atom types
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.EState.EState.EStateIndices(mol, force=True)¶
returns a tuple of EState indices for the molecule
Reference: Hall, Mohney and Kier. JCICS _31_ 76-81 (1991)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState.GetPrincipleQuantumNumber(atNum)¶
Get principal quantum number for atom number
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState.MaxAbsEStateIndex(mol, force=1)¶
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState.MaxEStateIndex(mol, force=1)¶
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState.MinAbsEStateIndex(mol, force=1)¶
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState.MinEStateIndex(mol, force=1)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.EState_VSA1(mol)¶
EState VSA Descriptor 1 (-inf < x <  -0.39)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.EState_VSA10(mol)¶
EState VSA Descriptor 10 ( 9.17 <= x <  15.00)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.EState_VSA11(mol)¶
EState VSA Descriptor 11 ( 15.00 <= x < inf)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.EState_VSA2(mol)¶
EState VSA Descriptor 2 ( -0.39 <= x <  0.29)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.EState_VSA3(mol)¶
EState VSA Descriptor 3 ( 0.29 <= x <  0.72)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.EState_VSA4(mol)¶
EState VSA Descriptor 4 ( 0.72 <= x <  1.17)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.EState_VSA5(mol)¶
EState VSA Descriptor 5 ( 1.17 <= x <  1.54)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.EState_VSA6(mol)¶
EState VSA Descriptor 6 ( 1.54 <= x <  1.81)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.EState_VSA7(mol)¶
EState VSA Descriptor 7 ( 1.81 <= x <  2.05)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.EState_VSA8(mol)¶
EState VSA Descriptor 8 ( 2.05 <= x <  4.69)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.EState_VSA9(mol)¶
EState VSA Descriptor 9 ( 4.69 <= x <  9.17)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.EState_VSA_(mol, bins=None, force=1)¶
Internal Use Only
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.VSA_EState1(mol)¶
VSA EState Descriptor 1 (-inf < x <  4.78)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.VSA_EState10(mol)¶
VSA EState Descriptor 10 ( 11.00 <= x < inf)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.VSA_EState2(mol)¶
VSA EState Descriptor 2 ( 4.78 <= x <  5.00)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.VSA_EState3(mol)¶
VSA EState Descriptor 3 ( 5.00 <= x <  5.41)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.VSA_EState4(mol)¶
VSA EState Descriptor 4 ( 5.41 <= x <  5.74)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.VSA_EState5(mol)¶
VSA EState Descriptor 5 ( 5.74 <= x <  6.00)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.VSA_EState6(mol)¶
VSA EState Descriptor 6 ( 6.00 <= x <  6.07)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.VSA_EState7(mol)¶
VSA EState Descriptor 7 ( 6.07 <= x <  6.45)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.VSA_EState8(mol)¶
VSA EState Descriptor 8 ( 6.45 <= x <  7.00)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.VSA_EState9(mol)¶
VSA EState Descriptor 9 ( 7.00 <= x <  11.00)
--------------------------------------------------------------------------------
rdkit.Chem.EState.EState_VSA.VSA_EState_(mol, bins=None, force=1)¶
Internal Use Only
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.EState.Fingerprinter.FingerprintMol(mol)¶
generates the EState fingerprints for the molecule
Concept from the paper: Hall and Kier JCICS _35_ 1039-1045 (1995)

two numeric arrays are returned:The first (of ints) contains the number of times each possible atom type is hit
The second (of floats) contains the sum of the EState indices for atoms of

each type.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.FeatFinderCLI.GetAtomFeatInfo(factory, mol)¶
--------------------------------------------------------------------------------
rdkit.Chem.FeatFinderCLI.existingFile(filename)¶
‘type’ for argparse - check that filename exists
--------------------------------------------------------------------------------
rdkit.Chem.FeatFinderCLI.initParser()¶
Initialize the parser
--------------------------------------------------------------------------------
rdkit.Chem.FeatFinderCLI.main()¶
Main application
--------------------------------------------------------------------------------
rdkit.Chem.FeatFinderCLI.processArgs(args, parser)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.FeatMaps.FeatMapUtils.CombineFeatMaps(fm1, fm2, mergeMetric=0, mergeTol=1.5, dirMergeMode=0)¶
the parameters will be taken from fm1
--------------------------------------------------------------------------------
rdkit.Chem.FeatMaps.FeatMapUtils.GetFeatFeatDistMatrix(fm, mergeMetric, mergeTol, dirMergeMode, compatFunc)¶
NOTE that mergeTol is a max value for merging when using distance-based
merging and a min value when using score-based merging.
--------------------------------------------------------------------------------
rdkit.Chem.FeatMaps.FeatMapUtils.MergeFeatPoints(fm, mergeMetric=0, mergeTol=1.5, dirMergeMode=0, mergeMethod=0, compatFunc=<function familiesMatch>)¶
NOTE that mergeTol is a max value for merging when using distance-based
merging and a min value when using score-based merging.
returns whether or not any points were actually merged
--------------------------------------------------------------------------------
rdkit.Chem.FeatMaps.FeatMapUtils.familiesMatch(f1, f2)¶
--------------------------------------------------------------------------------
rdkit.Chem.FeatMaps.FeatMapUtils.feq(v1, v2, tol=0.0001)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Features.FeatDirUtilsRD.ArbAxisRotation(theta, ax, pt)¶
--------------------------------------------------------------------------------
rdkit.Chem.Features.FeatDirUtilsRD.GetAcceptor1FeatVects(conf, featAtoms, scale=1.5)¶
Get the direction vectors for Acceptor of type 1
This is a acceptor with one heavy atom neighbor. There are two possibilities we will
consider here
1. The bond to the heavy atom is a single bond e.g. CO

In this case we don’t know the exact direction and we just use the inversion of this bond direction
and mark this direction as a ‘cone’


The bond to the heavy atom is a double bond e.g. C=O
In this case the we have two possible direction except in some special cases e.g. SO2
where again we will use bond direction


ARGUMENTS:featAtoms - list of atoms that are part of the feature
scale - length of the direction vector
--------------------------------------------------------------------------------
rdkit.Chem.Features.FeatDirUtilsRD.GetAcceptor2FeatVects(conf, featAtoms, scale=1.5)¶
Get the direction vectors for Acceptor of type 2
This is the acceptor with two adjacent heavy atoms. We will special case a few things here.
If the acceptor atom is an oxygen we will assume a sp3 hybridization
the acceptor directions (two of them)
reflect that configurations. Otherwise the direction vector in plane with the neighboring
heavy atoms

ARGUMENTS:featAtoms - list of atoms that are part of the feature
scale - length of the direction vector
--------------------------------------------------------------------------------
rdkit.Chem.Features.FeatDirUtilsRD.GetAcceptor3FeatVects(conf, featAtoms, scale=1.5)¶
Get the direction vectors for Donor of type 3
This is a donor with three heavy atoms as neighbors. We will assume
a tetrahedral arrangement of these neighbors. So the direction we are seeking
is the last fourth arm of the sp3 arrangement

ARGUMENTS:featAtoms - list of atoms that are part of the feature
scale - length of the direction vector
--------------------------------------------------------------------------------
rdkit.Chem.Features.FeatDirUtilsRD.GetAromaticFeatVects(conf, featAtoms, featLoc, scale=1.5)¶
Compute the direction vector for an aromatic feature

ARGUMENTS:conf - a conformer
featAtoms - list of atom IDs that make up the feature
featLoc - location of the aromatic feature specified as point3d
scale - the size of the direction vector
--------------------------------------------------------------------------------
rdkit.Chem.Features.FeatDirUtilsRD.GetDonor1FeatVects(conf, featAtoms, scale=1.5)¶
Get the direction vectors for Donor of type 1
This is a donor with one heavy atom. It is not clear where we should we should be putting the
direction vector for this. It should probably be a cone. In this case we will just use the
direction vector from the donor atom to the heavy atom
ARGUMENTS:

featAtoms - list of atoms that are part of the feature
scale - length of the direction vector
--------------------------------------------------------------------------------
rdkit.Chem.Features.FeatDirUtilsRD.GetDonor2FeatVects(conf, featAtoms, scale=1.5)¶
Get the direction vectors for Donor of type 2
This is a donor with two heavy atoms as neighbors. The atom may are may not have
hydrogen on it. Here are the situations with the neighbors that will be considered here


two heavy atoms and two hydrogens: we will assume a sp3 arrangement here
two heavy atoms and one hydrogen: this can either be sp2 or sp3
two heavy atoms and no hydrogens



ARGUMENTS:featAtoms - list of atoms that are part of the feature
scale - length of the direction vector
--------------------------------------------------------------------------------
rdkit.Chem.Features.FeatDirUtilsRD.GetDonor3FeatVects(conf, featAtoms, scale=1.5)¶
Get the direction vectors for Donor of type 3
This is a donor with three heavy atoms as neighbors. We will assume
a tetrahedral arrangement of these neighbors. So the direction we are seeking
is the last fourth arm of the sp3 arrangement

ARGUMENTS:featAtoms - list of atoms that are part of the feature
scale - length of the direction vector
--------------------------------------------------------------------------------
rdkit.Chem.Features.FeatDirUtilsRD.cross(v1, v2)¶
--------------------------------------------------------------------------------
rdkit.Chem.Features.FeatDirUtilsRD.findNeighbors(atomId, adjMat)¶
Find the IDs of the neighboring atom IDs
ARGUMENTS:
atomId - atom of interest
adjMat - adjacency matrix for the compound
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Features.ShowFeats.ShowArrow(viewer, tail, head, radius, color, label, transparency=0, includeArrowhead=True)¶
--------------------------------------------------------------------------------
rdkit.Chem.Features.ShowFeats.ShowMolFeats(mol, factory, viewer, radius=0.5, confId=-1, showOnly=True, name='', transparency=0.0, colors=None, excludeTypes=[], useFeatDirs=True, featLabel=None, dirLabel=None, includeArrowheads=True, writeFeats=False, showMol=True, featMapFile=False)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.ClusterMols.ClusterFromDetails(details)¶
Returns the cluster tree
--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.ClusterMols.ClusterPoints(data, metric, algorithmId, haveLabels=False, haveActs=True, returnDistances=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.ClusterMols.GetDistanceMatrix(data, metric, isSimilarity=1)¶
data should be a list of tuples with fingerprints in position 1
(the rest of the elements of the tuple are not important)

Returns the symmetric distance matrix
(see ML.Cluster.Resemblance for layout documentation)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.FingerprintMols.FingerprintMol(mol, fingerprinter=<Boost.Python.function object>, **fpArgs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.FingerprintMols.FingerprintsFromDetails(details, reportFreq=10)¶
--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.FingerprintMols.FingerprintsFromMols(mols, fingerprinter=<Boost.Python.function object>, reportFreq=10, maxMols=-1, **fpArgs)¶
fpArgs are passed as keyword arguments to the fingerprinter
Returns a list of 2-tuples: (ID,fp)
--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.FingerprintMols.FingerprintsFromPickles(dataSource, idCol, pklCol, fingerprinter=<Boost.Python.function object>, reportFreq=10, maxMols=-1, **fpArgs)¶
fpArgs are passed as keyword arguments to the fingerprinter
Returns a list of 2-tuples: (ID,fp)
--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.FingerprintMols.FingerprintsFromSmiles(dataSource, idCol, smiCol, fingerprinter=<Boost.Python.function object>, reportFreq=10, maxMols=-1, **fpArgs)¶
fpArgs are passed as keyword arguments to the fingerprinter
Returns a list of 2-tuples: (ID,fp)
--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.FingerprintMols.FoldFingerprintToTargetDensity(fp, **fpArgs)¶
--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.FingerprintMols.GetRDKFingerprint(mol)¶
uses default parameters
--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.FingerprintMols.ParseArgs(details=None)¶
parses the command line arguments and returns a
_FingerprinterDetails_ instance with the results.
Note:


If you make modifications here, please update the global
_usageDoc string so the Usage message is up to date.
This routine is used by both the fingerprinter, the clusterer and the
screener; not all arguments make sense for all applications.
--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.FingerprintMols.Usage()¶
prints a usage string and exits
--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.FingerprintMols.error(msg)¶
--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.FingerprintMols.message(msg)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.MolSimilarity.GetFingerprints(details)¶
returns an iterable sequence of fingerprints
each fingerprint will have a _fieldsFromDb member whose first entry is
the id.
--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.MolSimilarity.ScreenFingerprints(details, data, mol=None, probeFp=None)¶
Returns a list of results
--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.MolSimilarity.ScreenFromDetails(details, mol=None)¶
Returns a list of results
--------------------------------------------------------------------------------
rdkit.Chem.Fingerprints.MolSimilarity.ScreenInDb(details, mol)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.MATCH(mol, pat)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.all_subgraph_extensions(enumeration_mol, subgraph, visited_bond_indices, internal_bonds, external_edges)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.assign_isotopes_from_class_tag(mol, atom_class_tag)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.atom_typer_any(atoms)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.atom_typer_elements(atoms)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.atom_typer_isotopes(atoms)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.bond_typer_any(bonds)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.bond_typer_bondtypes(bonds)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.canon(cangen_nodes)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.check_completeRingsOnly(smarts, subgraph, enumeration_mol)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.compute_mcs(fragmented_mols, typed_mols, minNumAtoms, threshold_count=None, maximize='bonds', completeRingsOnly=False, timeout=None, timer=None, verbose=False, verboseDelay=1.0)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.convert_input_to_typed_molecules(mols, atom_typer, bond_typer, matchValences, ringMatchesRingOnly)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.default_atom_typer(atoms)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.default_bond_typer(bonds)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.enumerate_subgraphs(enumeration_mols, prune, atom_assignment, matches_all_targets, hits, timeout, heappush, heappop)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.find_duplicates(cangen_nodes, start, end)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.find_extension_size(enumeration_mol, known_atoms, exclude_bonds, directed_edges)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.find_extensions(atom_indices, visited_bond_indices, directed_edges)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.find_upper_fragment_size_limits(rdmol, atoms)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.fmcs(mols, minNumAtoms=2, maximize='bonds', atomCompare='elements', bondCompare='bondtypes', threshold=1.0, matchValences=False, ringMatchesRingOnly=False, completeRingsOnly=False, timeout=None, times=None, verbose=False, verboseDelay=1.0)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.fragmented_mol_to_enumeration_mols(typed_mol, minNumAtoms=2)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.gen_primes()¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.generate_smarts(cangen_nodes)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.get_canonical_bondtype_counts(typed_mols)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.get_canonical_bondtypes(rdmol, bonds, atom_smarts_types, bond_smarts_types)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.get_closure_label(bond_smarts, closure)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.get_counts(it)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.get_initial_cangen_nodes(subgraph, enumeration_mol, atom_assignment, do_initial_assignment=True)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.get_isotopes(mol)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.get_selected_atom_classes(mol, atom_indices)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.get_specified_types(rdmol, atom_types, ringMatchesRingOnly)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.get_typed_fragment(typed_mol, atom_indices)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.get_typed_molecule(rdmol, atom_typer, bond_typer, matchValences=False, ringMatchesRingOnly=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.intersect_counts(counts1, counts2)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.main(args=None)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.make_arbitrary_smarts(subgraph, enumeration_mol, atom_assignment)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.make_canonical_smarts(subgraph, enumeration_mol, atom_assignment)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.make_complete_sdf(mcs, mol, subgraph, args)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.make_fragment_sdf(mcs, mol, subgraph, args)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.make_fragment_smiles(mcs, mol, subgraph, args=None)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.make_structure_format(format_name, mcs, mol, subgraph, args)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.nonempty_powerset([1,2,3]) --> (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.parse_num_atoms(s)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.parse_select(s)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.parse_threshold(s)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.parse_timeout(s)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.prune_maximize_atoms(subgraph, mol, num_remaining_atoms, num_remaining_bonds, best_sizes)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.prune_maximize_bonds(subgraph, mol, num_remaining_atoms, num_remaining_bonds, best_sizes)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.remove_unknown_bondtypes(typed_mol, supported_canonical_bondtypes)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.rerank(cangen_nodes)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.restore_isotopes(mol)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.save_atom_classes(mol, atom_classes)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.save_isotopes(mol, isotopes)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.set_isotopes(mol, isotopes)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.subgraph_to_fragment(mol, subgraph)¶
--------------------------------------------------------------------------------
rdkit.Chem.fmcs.fmcs.tiebreaker()¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Fraggle.FraggleSim.GetFraggleSimilarity(queryMol, refMol, tverskyThresh=0.8)¶
return the Fraggle similarity between two molecules
>>> q = Chem.MolFromSmiles('COc1cc(CN2CCC(NC(=O)c3cncc(C)c3)CC2)c(OC)c2ccccc12')
>>> m = Chem.MolFromSmiles('COc1cc(CN2CCC(NC(=O)c3ccccc3)CC2)c(OC)c2ccccc12')
>>> sim,match = GetFraggleSimilarity(q,m)
>>> sim
0.980...
>>> match
'*C1CCN(Cc2cc(OC)c3ccccc3c2OC)CC1'


>>> m = Chem.MolFromSmiles('COc1cc(CN2CCC(Nc3nc4ccccc4s3)CC2)c(OC)c2ccccc12')
>>> sim,match = GetFraggleSimilarity(q,m)
>>> sim
0.794...
>>> match
'*C1CCN(Cc2cc(OC)c3ccccc3c2OC)CC1'


>>> q = Chem.MolFromSmiles('COc1ccccc1')
>>> sim,match = GetFraggleSimilarity(q,m)
>>> sim
0.347...
>>> match
'*c1ccccc1'
--------------------------------------------------------------------------------
rdkit.Chem.Fraggle.FraggleSim.atomContrib(subs, mol, tverskyThresh=0.8)¶
atomContrib algorithm
generate fp of query_substructs (qfp)

loop through atoms of smilesFor each atom
Generate partial fp of the atom (pfp)
Find Tversky sim of pfp in qfp
If Tversky < 0.8, mark atom in smiles

Loop through marked atomsIf marked atom in ring - turn all atoms in that ring to * (aromatic) or Sc (aliphatic)
For each marked atom

If aromatic turn to a *
If aliphatic turn to a Sc



Return modified smiles
--------------------------------------------------------------------------------
rdkit.Chem.Fraggle.FraggleSim.compute_fraggle_similarity_for_subs(inMol, qMol, qSmi, qSubs, tverskyThresh=0.8)¶
--------------------------------------------------------------------------------
rdkit.Chem.Fraggle.FraggleSim.delete_bonds(mol, bonds, ftype, hac)¶
Fragment molecule on bonds and reduce to fraggle fragmentation SMILES.
If none exists, returns None
--------------------------------------------------------------------------------
rdkit.Chem.Fraggle.FraggleSim.generate_fraggle_fragmentation(mol, verbose=False)¶
Create all possible fragmentations for molecule
>>> q = Chem.MolFromSmiles(‘COc1cc(CN2CCC(NC(=O)c3cncc(C)c3)CC2)c(OC)c2ccccc12’)
>>> fragments = generate_fraggle_fragmentation(q)
>>> fragments = sorted([‘.’.join(sorted(s.split(‘.’))) for s in fragments])
>>> fragments


[’*C(=O)NC1CCN(Cc2cc(OC)c3ccccc3c2OC)CC1’,‘C(=O)c1cncc(C)c1.*C1CCN(Cc2cc(OC)c3ccccc3c2OC)CC1’,
‘*C(=O)c1cncc(C)c1.*Cc1cc(OC)c2ccccc2c1OC’,
‘*C(=O)c1cncc(C)c1.*c1cc(OC)c2ccccc2c1OC’,
‘*C1CCN(Cc2cc(OC)c3ccccc3c2OC)CC1’,
‘*C1CCN(Cc2cc(OC)c3ccccc3c2OC)CC1.*c1cncc(C)c1’,
‘*Cc1cc(OC)c2ccccc2c1OC.*NC(=O)c1cncc(C)c1’,
‘*Cc1cc(OC)c2ccccc2c1OC.*c1cncc(C)c1’,
‘*N1CCC(NC(=O)c2cncc(C)c2)CC1.*c1cc(OC)c2ccccc2c1OC’,
‘*NC(=O)c1cncc(C)c1.*c1cc(OC)c2ccccc2c1OC’,
‘*NC1CCN(Cc2cc(OC)c3ccccc3c2OC)CC1’,
‘*NC1CCN(Cc2cc(OC)c3ccccc3c2OC)CC1.*c1cncc(C)c1’,
‘*c1c(CN2CCC(NC(=O)c3cncc(C)c3)CC2)cc(OC)c2ccccc12’,
‘*c1c(OC)cc(CN2CCC(NC(=O)c3cncc(C)c3)CC2)c(OC)c1’,
‘*c1cc(CN2CCC(NC(=O)c3cncc(C)c3)CC2)c(OC)c2ccccc12’,
‘*c1cc(OC)c2ccccc2c1OC.*c1cncc(C)c1’]
--------------------------------------------------------------------------------
rdkit.Chem.Fraggle.FraggleSim.isValidRingCut(mol)¶
to check is a fragment is a valid ring cut, it needs to match the
SMARTS: [$([#0][r].[r][#0]),$([#0][r][#0])]
--------------------------------------------------------------------------------
rdkit.Chem.Fraggle.FraggleSim.select_fragments(fragments, ftype, hac)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.FragmentCatalog.BuildAdjacencyList(catalog, bits, limitInclusion=1, orderLevels=0)¶
--------------------------------------------------------------------------------
rdkit.Chem.FragmentCatalog.GetMolsMatchingBit(mols, bit, fps)¶
--------------------------------------------------------------------------------
rdkit.Chem.FragmentCatalog.ProcessGainsFile(fileName, nToDo=-1, delim=',', haveDescriptions=1)¶
--------------------------------------------------------------------------------
rdkit.Chem.FragmentCatalog.message(msg, dest=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_Al_COO(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of aliphatic carboxylic acids
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_Al_OH(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of aliphatic hydroxyl groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_Al_OH_noTert(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of aliphatic hydroxyl groups excluding tert-OH
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_ArN(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of N functional groups attached to aromatics
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_Ar_COO(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of Aromatic carboxylic acide
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_Ar_N(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of aromatic nitrogens
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_Ar_NH(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of aromatic amines
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_Ar_OH(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of aromatic hydroxyl groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_COO(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of carboxylic acids
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_COO2(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of carboxylic acids
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_C_O(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of carbonyl O
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_C_O_noCOO(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of carbonyl O, excluding COOH
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_C_S(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of thiocarbonyl
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_HOCCN(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of C(OH)CCN-Ctert-alkyl or  C(OH)CCNcyclic
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_Imine(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of Imines
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_NH0(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of Tertiary amines
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_NH1(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of Secondary amines
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_NH2(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of Primary amines
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_N_O(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of hydroxylamine groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_Ndealkylation1(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of XCCNR groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_Ndealkylation2(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of tert-alicyclic amines (no heteroatoms, not quinine-like bridged N)
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_Nhpyrrole(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of H-pyrrole nitrogens
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_SH(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of thiol groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_aldehyde(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of aldehydes
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_alkyl_carbamate(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of alkyl carbamates (subject to hydrolysis)
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_alkyl_halide(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of alkyl halides
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_allylic_oxid(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of allylic oxidation sites excluding steroid dienone
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_amide(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of amides
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_amidine(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of amidine groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_aniline(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of anilines
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_aryl_methyl(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of aryl methyl sites for hydroxylation
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_azide(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of azide groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_azo(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of azo groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_barbitur(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of barbiturate groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_benzene(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of benzene rings
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_benzodiazepine(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of benzodiazepines with no additional fused rings
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_bicyclic(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Bicyclic
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_diazo(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of diazo groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_dihydropyridine(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of dihydropyridines
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_epoxide(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of epoxide rings
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_ester(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of esters
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_ether(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of ether oxygens (including phenoxy)
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_furan(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of furan rings
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_guanido(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of guanidine groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_halogen(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of halogens
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_hdrzine(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of hydrazine groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_hdrzone(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of hydrazone groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_imidazole(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of imidazole rings
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_imide(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of imide groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_isocyan(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of isocyanates
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_isothiocyan(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of isothiocyanates
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_ketone(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of ketones
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_ketone_Topliss(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of ketones excluding diaryl, a,b-unsat. dienones, heteroatom on Calpha
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_lactam(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of beta lactams
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_lactone(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of cyclic esters (lactones)
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_methoxy(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of methoxy groups -OCH3
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_morpholine(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of morpholine rings
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_nitrile(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of nitriles
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_nitro(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of nitro groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_nitro_arom(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of nitro benzene ring substituents
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_nitro_arom_nonortho(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of non-ortho nitro benzene ring substituents
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_nitroso(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of nitroso groups, excluding NO2
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_oxazole(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of oxazole rings
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_oxime(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of oxime groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_para_hydroxylation(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of para-hydroxylation sites
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_phenol(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of phenols
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_phenol_noOrthoHbond(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of phenolic OH excluding ortho intramolecular Hbond substituents
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_phos_acid(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of phosphoric acid groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_phos_ester(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of phosphoric ester groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_piperdine(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of piperdine rings
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_piperzine(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of piperzine rings
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_priamide(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of primary amides
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_prisulfonamd(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of primary sulfonamides
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_pyridine(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of pyridine rings
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_quatN(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of quaternary nitrogens
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_sulfide(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of thioether
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_sulfonamd(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of sulfonamides
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_sulfone(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of sulfone groups
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_term_acetylene(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of terminal acetylenes
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_tetrazole(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of tetrazole rings
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_thiazole(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of thiazole rings
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_thiocyan(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of thiocyanates
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_thiophene(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of thiophene rings
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_unbrch_alkane(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of unbranched alkanes  of at least 4 members (excludes halogenated alkanes)
--------------------------------------------------------------------------------
rdkit.Chem.Fragments.fr_urea(mol, countUnique=True, pattern=<rdkit.Chem.rdchem.Mol object>)¶
Number of urea groups
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.FunctionalGroups.BuildFuncGroupHierarchy(fileNm=None, data=None, force=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.FunctionalGroups.CreateMolFingerprint(mol, hierarchy)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.AvgIpc(mol, dMat=None, forceDMat=False)¶
This returns the average information content of the coefficients of the characteristic
polynomial of the adjacency matrix of a hydrogen-suppressed graph of a molecule.
From Eq 7 of D. Bonchev & N. Trinajstic, J. Chem. Phys. vol 67, 4517-4533 (1977)
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.BalabanJ(mol, dMat=None, forceDMat=0)¶
Calculate Balaban’s J value for a molecule
Arguments


mol: a molecule
dMat: (optional) a distance/adjacency matrix for the molecule, if this
is not provide, one will be calculated
forceDMat: (optional) if this is set, the distance/adjacency matrix
will be recalculated regardless of whether or not _dMat_ is provided
or the molecule already has one


Returns


a float containing the J value



We follow the notation of Balaban’s paper:Chem. Phys. Lett. vol 89, 399-404, (1982)
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.BertzCT(mol, cutoff=100, dMat=None, forceDMat=1)¶
A topological index meant to quantify “complexity” of molecules.
Consists of a sum of two terms, one representing the complexity
of the bonding, the other representing the complexity of the
distribution of heteroatoms.
From S. H. Bertz, J. Am. Chem. Soc., vol 103, 3599-3601 (1981)
“cutoff” is an integer value used to limit the computational
expense.  A cutoff value tells the program to consider vertices
topologically identical if their distance vectors (sets of
distances to all other vertices) are equal out to the “cutoff”th
nearest-neighbor.

NOTE  The original implementation had the following comment:
> this implementation treats aromatic rings as the
> corresponding Kekule structure with alternating bonds,
> for purposes of counting “connections”.


Upon further thought, this is the WRONG thing to do.  Itresults in the possibility of a molecule giving two different
CT values depending on the kekulization.  For example, in the
old implementation, these two SMILES:

CC2=CN=C1C3=C(C(C)=C(C=N3)C)C=CC1=C2C
CC3=CN=C2C1=NC=C(C)C(C)=C1C=CC2=C3C

which correspond to differentk kekule forms, yield different
values.

The new implementation uses consistent (aromatic) bond ordersfor aromatic bonds.


THIS MEANS THAT THIS IMPLEMENTATION IS NOT BACKWARDS COMPATIBLE.
Any molecule containing aromatic rings will yield different
values with this implementation.  The new behavior is the correct
one, so we’re going to live with the breakage.

NOTE this barfs if the molecule contains a second (ornth) fragment that is one atom.
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.Chi0(mol)¶
From equations (1),(9) and (10) of Rev. Comp. Chem. vol 2, 367-422, (1991)
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.Chi0n(x)¶
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.Chi0v(x)¶
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.Chi1(mol)¶
From equations (1),(11) and (12) of Rev. Comp. Chem. vol 2, 367-422, (1991)
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.Chi1n(x)¶
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.Chi1v(x)¶
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.Chi2n(x)¶
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.Chi2v(x)¶
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.Chi3n(x)¶
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.Chi3v(x)¶
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.Chi4n(x)¶
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.Chi4v(x)¶
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.ChiNn_(x, y)¶
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.ChiNv_(x, y)¶
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.HallKierAlpha(x)¶
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.Ipc(mol, avg=False, dMat=None, forceDMat=False)¶
This returns the information content of the coefficients of the characteristic
polynomial of the adjacency matrix of a hydrogen-suppressed graph of a molecule.
‘avg = True’ returns the information content divided by the total population.
From Eq 6 of D. Bonchev & N. Trinajstic, J. Chem. Phys. vol 67, 4517-4533 (1977)
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.Kappa1(x)¶
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.Kappa2(x)¶
--------------------------------------------------------------------------------
rdkit.Chem.GraphDescriptors.Kappa3(x)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Graphs.CharacteristicPolynomial(mol, mat=None)¶
calculates the characteristic polynomial for a molecular graph
if mat is not passed in, the molecule’s Weighted Adjacency Matrix will
be used.
The approach used is the Le Verrier-Faddeev-Frame method described
in _Chemical Graph Theory, 2nd Edition_ by Nenad Trinajstic (CRC Press,
1992), pg 76.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.inchi.InchiToInchiKey(inchi)¶
Return the InChI key for the given InChI string. Return None on error
--------------------------------------------------------------------------------
rdkit.Chem.inchi.MolBlockToInchi(molblock, options='', logLevel=None, treatWarningAsError=False)¶
Returns the standard InChI string for a mol block
Keyword arguments:
logLevel – the log level used for logging logs and messages from InChI
API. set to None to diable the logging completely
treatWarningAsError – set to True to raise an exception in case of a
molecule that generates warning in calling InChI API. The resultant InChI
string and AuxInfo string as well as the error message are encoded in the
exception.
Returns:
the standard InChI string returned by InChI API for the input molecule
--------------------------------------------------------------------------------
rdkit.Chem.inchi.MolBlockToInchiAndAuxInfo(molblock, options='', logLevel=None, treatWarningAsError=False)¶
Returns the standard InChI string and InChI auxInfo for a mol block
Keyword arguments:
logLevel – the log level used for logging logs and messages from InChI
API. set to None to diable the logging completely
treatWarningAsError – set to True to raise an exception in case of a
molecule that generates warning in calling InChI API. The resultant InChI
string and AuxInfo string as well as the error message are encoded in the
exception.
Returns:
a tuple of the standard InChI string and the auxInfo string returned by
InChI API, in that order, for the input molecule
--------------------------------------------------------------------------------
rdkit.Chem.inchi.MolFromInchi(inchi, sanitize=True, removeHs=True, logLevel=None, treatWarningAsError=False)¶
Construct a molecule from a InChI string
Keyword arguments:
sanitize – set to True to enable sanitization of the molecule. Default is
True
removeHs – set to True to remove Hydrogens from a molecule. This only
makes sense when sanitization is enabled
logLevel – the log level used for logging logs and messages from InChI
API. set to None to diable the logging completely
treatWarningAsError – set to True to raise an exception in case of a
molecule that generates warning in calling InChI API. The resultant
molecule  and error message are part of the excpetion
Returns:
a rdkit.Chem.rdchem.Mol instance
--------------------------------------------------------------------------------
rdkit.Chem.inchi.MolToInchi(mol, options='', logLevel=None, treatWarningAsError=False)¶
Returns the standard InChI string for a molecule
Keyword arguments:
logLevel – the log level used for logging logs and messages from InChI
API. set to None to diable the logging completely
treatWarningAsError – set to True to raise an exception in case of a
molecule that generates warning in calling InChI API. The resultant InChI
string and AuxInfo string as well as the error message are encoded in the
exception.
Returns:
the standard InChI string returned by InChI API for the input molecule
--------------------------------------------------------------------------------
rdkit.Chem.inchi.MolToInchiAndAuxInfo(mol, options='', logLevel=None, treatWarningAsError=False)¶
Returns the standard InChI string and InChI auxInfo for a molecule
Keyword arguments:
logLevel – the log level used for logging logs and messages from InChI
API. set to None to diable the logging completely
treatWarningAsError – set to True to raise an exception in case of a
molecule that generates warning in calling InChI API. The resultant InChI
string and AuxInfo string as well as the error message are encoded in the
exception.
Returns:
a tuple of the standard InChI string and the auxInfo string returned by
InChI API, in that order, for the input molecule
--------------------------------------------------------------------------------
rdkit.Chem.inchi.MolToInchiKey(mol, options='')¶
Returns the standard InChI key for a molecule
Returns:
the standard InChI key returned by InChI API for the input molecule
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.FractionCSP3(x, y=<Boost.Python.function object>)¶

CalcFractionCSP3( (Mol)mol) -> float :returns the fraction of C atoms that are SP3 hybridized

C++ signature :double CalcFractionCSP3(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.HeavyAtomCount(mol)¶
Number of heavy atoms a molecule.
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.NHOHCount(x)¶
Number of NHs or OHs
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.NOCount(x)¶
Number of Nitrogens and Oxygens
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.NumAliphaticCarbocycles(x, y=<Boost.Python.function object>)¶

CalcNumAliphaticCarbocycles( (Mol)mol) -> int :returns the number of aliphatic (containing at least one non-aromatic bond) carbocycles for a molecule

C++ signature :unsigned int CalcNumAliphaticCarbocycles(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.NumAliphaticHeterocycles(x, y=<Boost.Python.function object>)¶

CalcNumAliphaticHeterocycles( (Mol)mol) -> int :returns the number of aliphatic (containing at least one non-aromatic bond) heterocycles for a molecule

C++ signature :unsigned int CalcNumAliphaticHeterocycles(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.NumAliphaticRings(x, y=<Boost.Python.function object>)¶

CalcNumAliphaticRings( (Mol)mol) -> int :returns the number of aliphatic (containing at least one non-aromatic bond) rings for a molecule

C++ signature :unsigned int CalcNumAliphaticRings(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.NumAromaticCarbocycles(x, y=<Boost.Python.function object>)¶

CalcNumAromaticCarbocycles( (Mol)mol) -> int :returns the number of aromatic carbocycles for a molecule

C++ signature :unsigned int CalcNumAromaticCarbocycles(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.NumAromaticHeterocycles(x, y=<Boost.Python.function object>)¶

CalcNumAromaticHeterocycles( (Mol)mol) -> int :returns the number of aromatic heterocycles for a molecule

C++ signature :unsigned int CalcNumAromaticHeterocycles(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.NumAromaticRings(x, y=<Boost.Python.function object>)¶

CalcNumAromaticRings( (Mol)mol) -> int :returns the number of aromatic rings for a molecule

C++ signature :unsigned int CalcNumAromaticRings(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.NumHAcceptors(x)¶
Number of Hydrogen Bond Acceptors
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.NumHDonors(x)¶
Number of Hydrogen Bond Donors
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.NumHeteroatoms(x)¶
Number of Heteroatoms
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.NumRotatableBonds(x)¶
Number of Rotatable Bonds
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.NumSaturatedCarbocycles(x, y=<Boost.Python.function object>)¶

CalcNumSaturatedCarbocycles( (Mol)mol) -> int :returns the number of saturated carbocycles for a molecule

C++ signature :unsigned int CalcNumSaturatedCarbocycles(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.NumSaturatedHeterocycles(x, y=<Boost.Python.function object>)¶

CalcNumSaturatedHeterocycles( (Mol)mol) -> int :returns the number of saturated heterocycles for a molecule

C++ signature :unsigned int CalcNumSaturatedHeterocycles(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.NumSaturatedRings(x, y=<Boost.Python.function object>)¶

CalcNumSaturatedRings( (Mol)mol) -> int :returns the number of saturated rings for a molecule

C++ signature :unsigned int CalcNumSaturatedRings(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.Lipinski.RingCount(x)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.MCS.FindMCS(mols, minNumAtoms=2, maximize='bonds', atomCompare='elements', bondCompare='bondtypes', matchValences=False, ringMatchesRingOnly=False, completeRingsOnly=False, timeout=None, threshold=None)¶
Find the maximum common substructure of a set of molecules

In the simplest case, pass in a list of molecules and get back
an MCSResult object which describes the MCS:
>>> from rdkit import Chem
>>> mols = [Chem.MolFromSmiles("C#CCP"), Chem.MolFromSmiles("C=CCO")]
>>> from rdkit.Chem import MCS
>>> MCS.FindMCS(mols)
MCSResult(numAtoms=2, numBonds=1, smarts='[#6]-[#6]', completed=1)


The SMARTS ‘[#6]-[#6]’ matches the largest common substructure of
the input structures. It has 2 atoms and 1 bond. If there is no
MCS which is at least minNumAtoms in size then the result will set
numAtoms and numBonds to -1 and set smarts to None.
By default, two atoms match if they are the same element and two
bonds match if they have the same bond type. Specify atomCompare
and bondCompare to use different comparison functions, as in:
>>> MCS.FindMCS(mols, atomCompare="any")
MCSResult(numAtoms=3, numBonds=2, smarts='[*]-[*]-[*]', completed=1)
>>> MCS.FindMCS(mols, bondCompare="any")
MCSResult(numAtoms=3, numBonds=2, smarts='[#6]~[#6]~[#6]', completed=1)


An atomCompare of “any” says that any atom matches any other atom,
“elements” compares by element type, and “isotopes” matches based on
the isotope label. Isotope labels can be used to implement user-defined
atom types. A bondCompare of “any” says that any bond matches any
other bond, and “bondtypes” says bonds are equivalent if and only if
they have the same bond type.
A substructure has both atoms and bonds. The default maximize
setting of “atoms” finds a common substructure with the most number
of atoms. Use maximize=”bonds” to maximize the number of bonds.
Maximizing the number of bonds tends to maximize the number of rings,
although two small rings may have fewer bonds than one large ring.
You might not want a 3-valent nitrogen to match one which is 5-valent.
The default matchValences value of False ignores valence information.
When True, the atomCompare setting is modified to also require that
the two atoms have the same valency.
>>> MCS.FindMCS(mols, matchValences=True)
MCSResult(numAtoms=2, numBonds=1, smarts='[#6v4]-[#6v4]', completed=1)


It can be strange to see a linear carbon chain match a carbon ring,
which is what the ringMatchesRingOnly default of False does. If
you set it to True then ring bonds will only match ring bonds.
>>> mols = [Chem.MolFromSmiles("C1CCC1CCC"), Chem.MolFromSmiles("C1CCCCCC1")]
>>> MCS.FindMCS(mols)
MCSResult(numAtoms=7, numBonds=6, smarts='[#6]-[#6]-[#6]-[#6]-[#6]-[#6]-[#6]', completed=1)
>>> MCS.FindMCS(mols, ringMatchesRingOnly=True)
MCSResult(numAtoms=4, numBonds=3, smarts='[#6](-@[#6])-@[#6]-@[#6]', completed=1)


You can further restrict things and require that partial rings
(as in this case) are not allowed. That is, if an atom is part of
the MCS and the atom is in a ring of the entire molecule then
that atom is also in a ring of the MCS. Set completeRingsOnly
to True to toggle this requirement and also sets ringMatchesRingOnly
to True.
>>> mols = [Chem.MolFromSmiles("CCC1CC2C1CN2"), Chem.MolFromSmiles("C1CC2C1CC2")]
>>> MCS.FindMCS(mols)
MCSResult(numAtoms=6, numBonds=6, smarts='[#6]-1-[#6]-[#6](-[#6])-[#6]-1-[#6]', completed=1)
>>> MCS.FindMCS(mols, ringMatchesRingOnly=True)
MCSResult(numAtoms=5, numBonds=5, smarts='[#6]-@1-@[#6]-@[#6](-@[#6])-@[#6]-@1', completed=1)
>>> MCS.FindMCS(mols, completeRingsOnly=True)
MCSResult(numAtoms=4, numBonds=4, smarts='[#6]-@1-@[#6]-@[#6]-@[#6]-@1', completed=1)


The MCS algorithm will exhaustively search for a maximum common substructure.
Typically this takes a fraction of a second, but for some comparisons this
can take minutes or longer. Use the timeout parameter to stop the search
after the given number of seconds (wall-clock seconds, not CPU seconds) and
return the best match found in that time. If timeout is reached then the
completed property of the MCSResult will be 0 instead of 1.
>>> mols = [Chem.MolFromSmiles("Nc1ccccc1"*100), Chem.MolFromSmiles("Nc1ccccccccc1"*100)]
>>> MCS.FindMCS(mols, timeout=0.1)
MCSResult(..., completed=0)


(The MCS after 50 seconds contained 511 atoms.)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.MolDb.FingerprintUtils.BuildAtomPairFP(mol)¶
--------------------------------------------------------------------------------
rdkit.Chem.MolDb.FingerprintUtils.BuildAvalonFP(mol, smiles=None)¶
--------------------------------------------------------------------------------
rdkit.Chem.MolDb.FingerprintUtils.BuildMorganFP(mol)¶
--------------------------------------------------------------------------------
rdkit.Chem.MolDb.FingerprintUtils.BuildPharm2DFP(mol)¶
--------------------------------------------------------------------------------
rdkit.Chem.MolDb.FingerprintUtils.BuildRDKitFP(mol)¶
--------------------------------------------------------------------------------
rdkit.Chem.MolDb.FingerprintUtils.BuildSigFactory(options=None, fdefFile=None, bins=[(2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 100)], skipFeats=('LumpedHydrophobe', 'ZnBinder'))¶
--------------------------------------------------------------------------------
rdkit.Chem.MolDb.FingerprintUtils.BuildTorsionsFP(mol)¶
--------------------------------------------------------------------------------
rdkit.Chem.MolDb.FingerprintUtils.DepickleFP(pkl, similarityMethod)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.MolDb.Loader_orig.ConvertRows(rows, globalProps, defaultVal, skipSmiles)¶
--------------------------------------------------------------------------------
rdkit.Chem.MolDb.Loader_orig.LoadDb(suppl, dbName, nameProp='_Name', nameCol='compound_id', silent=False, redraw=False, errorsTo=None, keepHs=False, defaultVal='N/A', skipProps=False, regName='molecules', skipSmiles=False, maxRowsCached=-1, uniqNames=False, addComputedProps=False, lazySupplier=False, startAnew=True)¶
--------------------------------------------------------------------------------
rdkit.Chem.MolDb.Loader_orig.ProcessMol(mol, typeConversions, globalProps, nDone, nameProp='_Name', nameCol='compound_id', redraw=False, keepHs=False, skipProps=False, addComputedProps=False, skipSmiles=False, uniqNames=None, namesSeen=None)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.MolDb.Loader_sa.ConnectToSchema(dbUrl, echo=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.MolDb.Loader_sa.LoadDb(suppl, dbName, nameProp='_Name', nameCol='compound_id', silent=False, redraw=False, errorsTo=None, keepHs=False, defaultVal='N/A', skipProps=False, regName='molecules', skipSmiles=False, maxRowsCached=-1, uniqNames=False, addComputedProps=False, lazySupplier=False, numForPropScan=10, startAnew=True)¶
--------------------------------------------------------------------------------
rdkit.Chem.MolDb.Loader_sa.ProcessMol(session, mol, globalProps, nDone, nameProp='_Name', nameCol='compound_id', redraw=False, keepHs=False, skipProps=False, addComputedProps=False, skipSmiles=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.MolDb.Loader_sa.RegisterSchema(dbUrl, echo=False)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.MolKey.MolKey.CheckCTAB(ctab, isSmiles=True)¶
--------------------------------------------------------------------------------
rdkit.Chem.MolKey.MolKey.ErrorBitsToText(err)¶
returns a list of error bit descriptions for the error code provided
--------------------------------------------------------------------------------
rdkit.Chem.MolKey.MolKey.GetInchiForCTAB(ctab)¶
>>> from rdkit.Chem.MolKey import MolKey
>>> from rdkit.Avalon import pyAvalonTools
>>> res = MolKey.GetInchiForCTAB(pyAvalonTools.Generate2DCoords('c1cn[nH]c1C(Cl)Br',True))
>>> res.inchi
'InChI=1/C4H4BrClN2/c5-4(6)3-1-2-7-8-3/h1-2,4H,(H,7,8)/t4?/f/h8H'
>>> res = MolKey.GetInchiForCTAB(pyAvalonTools.Generate2DCoords('c1c[nH]nc1C(Cl)Br',True))
>>> res.inchi
'InChI=1/C4H4BrClN2/c5-4(6)3-1-2-7-8-3/h1-2,4H,(H,7,8)/t4?/f/h7H'
>>>
--------------------------------------------------------------------------------
rdkit.Chem.MolKey.MolKey.GetKeyForCTAB(ctab, stereo_info=None, stereo_comment=None, logger=None)¶
>>> from rdkit.Chem.MolKey import MolKey
>>> from rdkit.Avalon import pyAvalonTools
>>> res = MolKey.GetKeyForCTAB(pyAvalonTools.Generate2DCoords('c1ccccc1C(F)Cl', True))
>>> res.mol_key
'1|L7676nfGsSIU33wkx//NCg=='
>>> res.stereo_code
'R_ONE'
>>> res = MolKey.GetKeyForCTAB(pyAvalonTools.Generate2DCoords('c1ccccc1[C@H](F)Cl', True))
>>> res.mol_key
'1|Aj38EIxf13RuPDQG2A0UMw=='
>>> res.stereo_code
'S_ABS'
>>> res = MolKey.GetKeyForCTAB(pyAvalonTools.Generate2DCoords('c1ccccc1[C@@H](F)Cl', True))
>>> res.mol_key
'1|9ypfMrhxn1w0ncRooN5HXw=='
>>> res.stereo_code
'S_ABS'
>>> res = MolKey.GetKeyForCTAB(pyAvalonTools.Generate2DCoords('c1cccc(C(Br)Cl)c1[C@@H](F)Cl', True))
>>> res.mol_key
'1|c96jMSlbn7O9GW5d5uB9Mw=='
>>> res.stereo_code
'S_PART'
>>> res = MolKey.GetKeyForCTAB(pyAvalonTools.Generate2DCoords('c1cccc([C@H](Br)Cl)c1[C@@H](F)Cl', True))
>>> res.mol_key
'1|+B+GCEardrJteE8xzYdGLA=='
>>> res.stereo_code
'S_ABS'
>>> res = MolKey.GetKeyForCTAB(pyAvalonTools.Generate2DCoords('c1cccc(C(Br)Cl)c1C(F)Cl', True))
>>> res.mol_key
'1|5H9R3LvclagMXHp3Clrc/g=='
>>> res.stereo_code
'S_UNKN'
>>> res = MolKey.GetKeyForCTAB(pyAvalonTools.Generate2DCoords('c1cccc(C(Br)Cl)c1C(F)Cl',True), stereo_info='S_REL')
>>> res.mol_key
'1|cqKWVsUEY6QNpGCbDaDTYA=='
>>> res.stereo_code
'S_REL'
>>> res.inchi
'InChI=1/C8H6BrCl2F/c9-7(10)5-3-1-2-4-6(5)8(11)12/h1-4,7-8H/t7?,8?'
--------------------------------------------------------------------------------
rdkit.Chem.MolKey.MolKey.initStruchk(configDir=None, logFile=None)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.CHARGE_CORRECTIONS() → object :¶

C++ signature :std::vector<RDKit::MolStandardize::ChargeCorrection, std::allocator<RDKit::MolStandardize::ChargeCorrection> > CHARGE_CORRECTIONS()
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.CanonicalTautomer((Mol)mol[, (AtomPairsParameters)params=None]) → Mol :¶
Returns the canonical tautomer for the molecule

C++ signature :RDKit::ROMol* CanonicalTautomer(RDKit::ROMol const* [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.ChargeParent((Mol)mol[, (AtomPairsParameters)params=None[, (bool)skipStandardize=False]]) → Mol :¶
Returns the uncharged version of the largest fragment

C++ signature :RDKit::ROMol* ChargeParent(RDKit::ROMol const* [,boost::python::api::object=None [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.ChargeParentInPlace((Mol)mol[, (AtomPairsParameters)params=None[, (bool)skipStandardize=False]]) → None :¶
Generates the charge parent in place


C++ signature :void ChargeParentInPlace(RDKit::ROMol* [,boost::python::api::object=None [,bool=False]])




ChargeParentInPlace( (AtomPairsParameters)mols, (int)numThreads [, (AtomPairsParameters)params=None [, (bool)skipStandardize=False]]) -> None :Generates the chargeparent in place for multiple molecules

C++ signature :void ChargeParentInPlace(boost::python::api::object,int [,boost::python::api::object=None [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.Cleanup((Mol)mol[, (AtomPairsParameters)params=None]) → Mol :¶
Standardizes a molecule

C++ signature :RDKit::ROMol* Cleanup(RDKit::ROMol const* [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.CleanupInPlace((Mol)mol[, (AtomPairsParameters)params=None]) → None :¶
Standardizes a molecule in place


C++ signature :void CleanupInPlace(RDKit::ROMol* [,boost::python::api::object=None])




CleanupInPlace( (AtomPairsParameters)mols, (int)numThreads [, (AtomPairsParameters)params=None]) -> None :Standardizes multiple molecules in place

C++ signature :void CleanupInPlace(boost::python::api::object,int [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.DisconnectOrganometallics((Mol)mol[, (AtomPairsParameters)params=None]) → Mol :¶
Returns the molecule disconnected using the organometallics rules.

C++ signature :RDKit::ROMol* DisconnectOrganometallics(RDKit::ROMol {lvalue} [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.DisconnectOrganometallicsInPlace((Mol)mol[, (AtomPairsParameters)params=None]) → None :¶
Disconnects the molecule using the organometallics rules, modifies the input molecule

C++ signature :void DisconnectOrganometallicsInPlace(RDKit::ROMol* [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.FragmentParent((Mol)mol[, (AtomPairsParameters)params=None[, (bool)skipStandardize=False]]) → Mol :¶
Returns the largest fragment after doing a cleanup

C++ signature :RDKit::ROMol* FragmentParent(RDKit::ROMol const* [,boost::python::api::object=None [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.FragmentParentInPlace((Mol)mol[, (AtomPairsParameters)params=None[, (bool)skipStandardize=False]]) → None :¶
Generates the largest fragment in place


C++ signature :void FragmentParentInPlace(RDKit::ROMol* [,boost::python::api::object=None [,bool=False]])




FragmentParentInPlace( (AtomPairsParameters)mols, (int)numThreads [, (AtomPairsParameters)params=None [, (bool)skipStandardize=False]]) -> None :Generates the largest fragment in place for multiple molecules

C++ signature :void FragmentParentInPlace(boost::python::api::object,int [,boost::python::api::object=None [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.FragmentRemoverFromData((str)fragmentData[, (bool)leave_last=True[, (bool)skip_if_all_match=False]]) → FragmentRemover :¶
creates a FragmentRemover from a string containing parameter data

C++ signature :RDKit::MolStandardize::FragmentRemover* FragmentRemoverFromData(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=True [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.GetV1TautomerEnumerator() → TautomerEnumerator :¶
return a TautomerEnumerator using v1 of the enumeration rules

C++ signature :RDKit::MolStandardize::TautomerEnumerator* GetV1TautomerEnumerator()
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.IsotopeParent((Mol)mol[, (AtomPairsParameters)params=None[, (bool)skipStandardize=False]]) → Mol :¶
removes all isotopes specifications from the given molecule

C++ signature :RDKit::ROMol* IsotopeParent(RDKit::ROMol const* [,boost::python::api::object=None [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.IsotopeParentInPlace((Mol)mol[, (AtomPairsParameters)params=None[, (bool)skipStandardize=False]]) → None :¶
Generates the isotope parent in place


C++ signature :void IsotopeParentInPlace(RDKit::ROMol* [,boost::python::api::object=None [,bool=False]])




IsotopeParentInPlace( (AtomPairsParameters)mols, (int)numThreads [, (AtomPairsParameters)params=None [, (bool)skipStandardize=False]]) -> None :Generates the isotope parent in place for multiple molecules

C++ signature :void IsotopeParentInPlace(boost::python::api::object,int [,boost::python::api::object=None [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.Normalize((Mol)mol[, (AtomPairsParameters)params=None]) → Mol :¶
Applies a series of standard transformations to correct functional groups and recombine charges

C++ signature :RDKit::ROMol* Normalize(RDKit::ROMol const* [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.NormalizeInPlace((Mol)mol[, (AtomPairsParameters)params=None]) → None :¶
Applies a series of standard transformations to correct functional groups and recombine charges, modifies the input molecule


C++ signature :void NormalizeInPlace(RDKit::ROMol* [,boost::python::api::object=None])




NormalizeInPlace( (AtomPairsParameters)mols, (int)numThreads [, (AtomPairsParameters)params=None]) -> None :Normalizes multiple molecules in place

C++ signature :void NormalizeInPlace(boost::python::api::object,int [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.NormalizerFromData((str)paramData, (CleanupParameters)params) → Normalizer :¶
creates a Normalizer from a string containing normalization SMARTS

C++ signature :RDKit::MolStandardize::Normalizer* NormalizerFromData(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,RDKit::MolStandardize::CleanupParameters)
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.NormalizerFromParams((CleanupParameters)params) → Normalizer :¶
creates a Normalizer from CleanupParameters

C++ signature :RDKit::MolStandardize::Normalizer* NormalizerFromParams(RDKit::MolStandardize::CleanupParameters)
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.Reionize((Mol)mol[, (AtomPairsParameters)params=None]) → Mol :¶
Ensures the strongest acid groups are charged first

C++ signature :RDKit::ROMol* Reionize(RDKit::ROMol const* [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.ReionizeInPlace((Mol)mol[, (AtomPairsParameters)params=None]) → None :¶
Ensures the strongest acid groups are charged first, modifies the input molecule


C++ signature :void ReionizeInPlace(RDKit::ROMol* [,boost::python::api::object=None])




ReionizeInPlace( (AtomPairsParameters)mols, (int)numThreads [, (AtomPairsParameters)params=None]) -> None :Reionizes multiple molecules in place

C++ signature :void ReionizeInPlace(boost::python::api::object,int [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.ReionizerFromData((str)paramData[, (AtomPairsParameters)chargeCorrections=[]]) → Reionizer :¶
creates a reionizer from a string containing parameter data and a list of charge corrections

C++ signature :RDKit::MolStandardize::Reionizer* ReionizerFromData(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=[]])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.RemoveFragments((Mol)mol[, (AtomPairsParameters)params=None]) → Mol :¶
Removes fragments from the molecule

C++ signature :RDKit::ROMol* RemoveFragments(RDKit::ROMol const* [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.RemoveFragmentsInPlace((Mol)mol[, (AtomPairsParameters)params=None]) → None :¶
Removes fragments from the molecule, modifies the input molecule


C++ signature :void RemoveFragmentsInPlace(RDKit::ROMol* [,boost::python::api::object=None])




RemoveFragmentsInPlace( (AtomPairsParameters)mols, (int)numThreads [, (AtomPairsParameters)params=None]) -> None :Removes fragments from multiple molecules in place

C++ signature :void RemoveFragmentsInPlace(boost::python::api::object,int [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.StandardizeSmiles((str)smiles) → str :¶
Convenience function for standardizing a SMILES

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > StandardizeSmiles(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.StereoParent((Mol)mol[, (AtomPairsParameters)params=None[, (bool)skipStandardize=False]]) → Mol :¶
Generates the largest fragment in place for multiple molecules

C++ signature :RDKit::ROMol* StereoParent(RDKit::ROMol const* [,boost::python::api::object=None [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.StereoParentInPlace((Mol)mol[, (AtomPairsParameters)params=None[, (bool)skipStandardize=False]]) → None :¶
Generates the stereo parent in place


C++ signature :void StereoParentInPlace(RDKit::ROMol* [,boost::python::api::object=None [,bool=False]])




StereoParentInPlace( (AtomPairsParameters)mols, (int)numThreads [, (AtomPairsParameters)params=None [, (bool)skipStandardize=False]]) -> None :Generates the stereo parent in place for multiple molecules

C++ signature :void StereoParentInPlace(boost::python::api::object,int [,boost::python::api::object=None [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.SuperParent((Mol)mol[, (AtomPairsParameters)params=None[, (bool)skipStandardize=False]]) → Mol :¶
Returns the super parent. The super parent is the fragment, charge, isotope, stereo, and tautomer parent of the molecule.

C++ signature :RDKit::ROMol* SuperParent(RDKit::ROMol const* [,boost::python::api::object=None [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.SuperParentInPlace((Mol)mol[, (AtomPairsParameters)params=None[, (bool)skipStandardize=False]]) → None :¶
Generates the super parent in place


C++ signature :void SuperParentInPlace(RDKit::ROMol* [,boost::python::api::object=None [,bool=False]])




SuperParentInPlace( (AtomPairsParameters)mols, (int)numThreads [, (AtomPairsParameters)params=None [, (bool)skipStandardize=False]]) -> None :Generates the super parent in place for multiple molecules

C++ signature :void SuperParentInPlace(boost::python::api::object,int [,boost::python::api::object=None [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.TautomerParent((Mol)mol[, (AtomPairsParameters)params=None[, (bool)skipStandardize=False]]) → Mol :¶
Returns the tautomer parent of a given molecule. The fragment parent is the standardized canonical tautomer of the molecule

C++ signature :RDKit::ROMol* TautomerParent(RDKit::ROMol const* [,boost::python::api::object=None [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.TautomerParentInPlace((Mol)mol[, (AtomPairsParameters)params=None[, (bool)skipStandardize=False]]) → None :¶
Generates the tautomer parent in place


C++ signature :void TautomerParentInPlace(RDKit::ROMol* [,boost::python::api::object=None [,bool=False]])




TautomerParentInPlace( (AtomPairsParameters)mols, (int)numThreads [, (AtomPairsParameters)params=None [, (bool)skipStandardize=False]]) -> None :Generates the tautomer parent in place for multiple molecules

C++ signature :void TautomerParentInPlace(boost::python::api::object,int [,boost::python::api::object=None [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.UpdateParamsFromJSON((CleanupParameters)params, (str)json) → None :¶
updates the cleanup parameters from the provided JSON string

C++ signature :void UpdateParamsFromJSON(RDKit::MolStandardize::CleanupParameters {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.MolStandardize.rdMolStandardize.ValidateSmiles((str)mol) → list :¶

C++ signature :boost::python::list ValidateSmiles(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.LabuteASA(*x, **y)¶
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.PEOE_VSA1(x, y=0)¶
MOE Charge VSA Descriptor 1 (-inf < x < -0.30)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.PEOE_VSA10(x, y=9)¶
MOE Charge VSA Descriptor 10 ( 0.10 <= x <  0.15)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.PEOE_VSA11(x, y=10)¶
MOE Charge VSA Descriptor 11 ( 0.15 <= x <  0.20)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.PEOE_VSA12(x, y=11)¶
MOE Charge VSA Descriptor 12 ( 0.20 <= x <  0.25)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.PEOE_VSA13(x, y=12)¶
MOE Charge VSA Descriptor 13 ( 0.25 <= x <  0.30)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.PEOE_VSA14(x, y=13)¶
MOE Charge VSA Descriptor 14 ( 0.30 <= x < inf)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.PEOE_VSA2(x, y=1)¶
MOE Charge VSA Descriptor 2 (-0.30 <= x < -0.25)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.PEOE_VSA3(x, y=2)¶
MOE Charge VSA Descriptor 3 (-0.25 <= x < -0.20)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.PEOE_VSA4(x, y=3)¶
MOE Charge VSA Descriptor 4 (-0.20 <= x < -0.15)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.PEOE_VSA5(x, y=4)¶
MOE Charge VSA Descriptor 5 (-0.15 <= x < -0.10)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.PEOE_VSA6(x, y=5)¶
MOE Charge VSA Descriptor 6 (-0.10 <= x < -0.05)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.PEOE_VSA7(x, y=6)¶
MOE Charge VSA Descriptor 7 (-0.05 <= x <  0.00)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.PEOE_VSA8(x, y=7)¶
MOE Charge VSA Descriptor 8 ( 0.00 <= x <  0.05)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.PEOE_VSA9(x, y=8)¶
MOE Charge VSA Descriptor 9 ( 0.05 <= x <  0.10)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SMR_VSA1(x, y=0)¶
MOE MR VSA Descriptor 1 (-inf < x <  1.29)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SMR_VSA10(x, y=9)¶
MOE MR VSA Descriptor 10 ( 4.00 <= x < inf)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SMR_VSA2(x, y=1)¶
MOE MR VSA Descriptor 2 ( 1.29 <= x <  1.82)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SMR_VSA3(x, y=2)¶
MOE MR VSA Descriptor 3 ( 1.82 <= x <  2.24)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SMR_VSA4(x, y=3)¶
MOE MR VSA Descriptor 4 ( 2.24 <= x <  2.45)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SMR_VSA5(x, y=4)¶
MOE MR VSA Descriptor 5 ( 2.45 <= x <  2.75)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SMR_VSA6(x, y=5)¶
MOE MR VSA Descriptor 6 ( 2.75 <= x <  3.05)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SMR_VSA7(x, y=6)¶
MOE MR VSA Descriptor 7 ( 3.05 <= x <  3.63)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SMR_VSA8(x, y=7)¶
MOE MR VSA Descriptor 8 ( 3.63 <= x <  3.80)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SMR_VSA9(x, y=8)¶
MOE MR VSA Descriptor 9 ( 3.80 <= x <  4.00)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SlogP_VSA1(x, y=0)¶
MOE logP VSA Descriptor 1 (-inf < x < -0.40)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SlogP_VSA10(x, y=9)¶
MOE logP VSA Descriptor 10 ( 0.40 <= x <  0.50)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SlogP_VSA11(x, y=10)¶
MOE logP VSA Descriptor 11 ( 0.50 <= x <  0.60)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SlogP_VSA12(x, y=11)¶
MOE logP VSA Descriptor 12 ( 0.60 <= x < inf)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SlogP_VSA2(x, y=1)¶
MOE logP VSA Descriptor 2 (-0.40 <= x < -0.20)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SlogP_VSA3(x, y=2)¶
MOE logP VSA Descriptor 3 (-0.20 <= x <  0.00)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SlogP_VSA4(x, y=3)¶
MOE logP VSA Descriptor 4 ( 0.00 <= x <  0.10)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SlogP_VSA5(x, y=4)¶
MOE logP VSA Descriptor 5 ( 0.10 <= x <  0.15)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SlogP_VSA6(x, y=5)¶
MOE logP VSA Descriptor 6 ( 0.15 <= x <  0.20)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SlogP_VSA7(x, y=6)¶
MOE logP VSA Descriptor 7 ( 0.20 <= x <  0.25)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SlogP_VSA8(x, y=7)¶
MOE logP VSA Descriptor 8 ( 0.25 <= x <  0.30)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.SlogP_VSA9(x, y=8)¶
MOE logP VSA Descriptor 9 ( 0.30 <= x <  0.40)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.TPSA(*x, **y)¶
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.pyLabuteASA(mol, includeHs=1)¶
calculates Labute’s Approximate Surface Area (ASA from MOE)
Definition from P. Labute’s article in the Journal of the Chemical Computing Group
and J. Mol. Graph. Mod.  _18_ 464-477 (2000)
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.pyPEOE_VSA_(mol, bins=None, force=1)¶
Internal Use Only
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.pySMR_VSA_(mol, bins=None, force=1)¶
Internal Use Only
--------------------------------------------------------------------------------
rdkit.Chem.MolSurf.pySlogP_VSA_(mol, bins=None, force=1)¶
Internal Use Only
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.PandasTools.AddMoleculeColumnToFrame(frame, smilesCol='Smiles', molCol='ROMol', includeFingerprints=False)¶
Converts the molecules contains in “smilesCol” to RDKit molecules and appends them to the
dataframe “frame” using the specified column name.
If desired, a fingerprint can be computed and stored with the molecule objects to accelerate
substructure matching
--------------------------------------------------------------------------------
rdkit.Chem.PandasTools.AddMurckoToFrame(frame, molCol='ROMol', MurckoCol='Murcko_SMILES', Generic=False)¶
Adds column with SMILES of Murcko scaffolds to pandas DataFrame.
Generic set to true results in SMILES of generic framework.
--------------------------------------------------------------------------------
rdkit.Chem.PandasTools.AlignMol(mol, scaffold)¶
Aligns mol (RDKit mol object) to scaffold (SMILES string)
--------------------------------------------------------------------------------
rdkit.Chem.PandasTools.AlignToScaffold(frame, molCol='ROMol', scaffoldCol='Murcko_SMILES')¶
Aligns molecules in molCol to scaffolds in scaffoldCol
--------------------------------------------------------------------------------
rdkit.Chem.PandasTools.ChangeMoleculeRendering(frame=None, renderer='image')¶
Allows to change the rendering of the molecules between image and string
representations.
This serves two purposes: First it allows to avoid the generation of images if this is
not desired and, secondly, it allows to enable image rendering for newly created dataframe
that already contains molecules, without having to rerun the time-consuming
AddMoleculeColumnToFrame. Note: this behaviour is, because some pandas methods, e.g. head()
returns a new dataframe instance that uses the default pandas rendering (thus not drawing
images for molecules) instead of the monkey-patched one.
--------------------------------------------------------------------------------
rdkit.Chem.PandasTools.FrameToGridImage(frame, column='ROMol', legendsCol=None, **kwargs)¶
Draw grid image of mols in pandas DataFrame.
--------------------------------------------------------------------------------
rdkit.Chem.PandasTools.InstallPandasTools()¶
Monkey patch an RDKit method of Chem.Mol and pandas
--------------------------------------------------------------------------------
rdkit.Chem.PandasTools.LoadSDF(filename, idName='ID', molColName='ROMol', includeFingerprints=False, isomericSmiles=True, smilesName=None, embedProps=False, removeHs=True, strictParsing=True, sanitize=True)¶
Read file in SDF format and return as Pandas data frame.
If embedProps=True all properties also get embedded in Mol objects in the molecule column.
If molColName=None molecules would not be present in resulting DataFrame (only properties
would be read).
Sanitize boolean is passed on to Chem.ForwardSDMolSupplier sanitize. 
If neither molColName nor smilesName are set, sanitize=false.
--------------------------------------------------------------------------------
rdkit.Chem.PandasTools.PrintAsImageString(x)¶
Returns the molecules as base64 encoded PNG image or as SVG
--------------------------------------------------------------------------------
rdkit.Chem.PandasTools.RGroupDecompositionToFrame(groups, mols, include_core=False, redraw_sidechains=False)¶
returns a dataframe with the results of R-Group Decomposition
>>> from rdkit import Chem
>>> from rdkit.Chem import rdRGroupDecomposition
>>> from rdkit.Chem import PandasTools
>>> import pandas as pd
>>> scaffold = Chem.MolFromSmiles('c1ccccn1')
>>> mols = [Chem.MolFromSmiles(smi) for smi in 'c1c(F)cccn1 c1c(Cl)c(C)ccn1 c1c(O)cccn1 c1c(F)c(C)ccn1 c1cc(Cl)c(F)cn1'.split()]
>>> groups,_ = rdRGroupDecomposition.RGroupDecompose([scaffold],mols,asSmiles=False,asRows=False)
>>> df = PandasTools.RGroupDecompositionToFrame(groups,mols,include_core=False)
>>> list(df.columns)
['Mol', 'R1', 'R2']
>>> df = PandasTools.RGroupDecompositionToFrame(groups,mols,include_core=True)
>>> list(df.columns)
['Mol', 'Core', 'R1', 'R2']
>>> len(df)
5
>>> df.columns() 
<class 'pandas*...*DataFrame'>
RangeIndex: 5 entries, 0 to 4
Data columns (total 4 columns):
Mol     5 non-null object
Core    5 non-null object
R1      5 non-null object
R2      5 non-null object
dtypes: object(4)
memory usage: *...*
--------------------------------------------------------------------------------
rdkit.Chem.PandasTools.RemoveSaltsFromFrame(frame, molCol='ROMol')¶
Removes salts from mols in pandas DataFrame’s ROMol column
--------------------------------------------------------------------------------
rdkit.Chem.PandasTools.RenderImagesInAllDataFrames(images=True)¶
Changes the default dataframe rendering to not escape HTML characters, thus allowing
rendered images in all dataframes.
IMPORTANT: THIS IS A GLOBAL CHANGE THAT WILL AFFECT TO COMPLETE PYTHON SESSION. If you want
to change the rendering only for a single dataframe use the “ChangeMoleculeRendering” method
instead.
--------------------------------------------------------------------------------
rdkit.Chem.PandasTools.SaveSMILESFromFrame(frame, outFile, molCol='ROMol', NamesCol='', isomericSmiles=False)¶
Saves smi file. SMILES are generated from column with RDKit molecules. Column
with names is optional.
--------------------------------------------------------------------------------
rdkit.Chem.PandasTools.SaveXlsxFromFrame(frame, outFile, molCol='ROMol', size=(300, 300), formats=None)¶
Saves pandas DataFrame as a xlsx file with embedded images.
molCol can be either a single column label or a list of column labels.
It maps numpy data types to excel cell types:
int, float -> number
datetime -> datetime
object -> string (limited to 32k character - xlsx limitations)
The formats parameter can be optionally set to a dict of XlsxWriter
formats (https://xlsxwriter.readthedocs.io/format.html#format), e.g.:
{

‘write_string’:  {‘text_wrap’: True}

}
Currently supported keys for the formats dict are:
‘write_string’, ‘write_number’, ‘write_datetime’.
Cells with compound images are a bit larger than images due to excel.
Column width weirdness explained (from xlsxwriter docs):
The width corresponds to the column width value that is specified in Excel.
It is approximately equal to the length of a string in the default font of Calibri 11.
Unfortunately, there is no way to specify “AutoFit” for a column in the Excel file format.
This feature is only available at runtime from within Excel.
--------------------------------------------------------------------------------
rdkit.Chem.PandasTools.UninstallPandasTools()¶
Unpatch an RDKit method of Chem.Mol and pandas
--------------------------------------------------------------------------------
rdkit.Chem.PandasTools.WriteSDF(df, out, molColName='ROMol', idName=None, properties=None, allNumeric=False, forceV3000=False)¶
Write an SD file for the molecules in the dataframe. Dataframe columns can be exported as
SDF tags if specified in the “properties” list. “properties=list(df.columns)” would export
all columns.
The “allNumeric” flag allows to automatically include all numeric columns in the output.
User has to make sure that correct data type is assigned to column.
“idName” can be used to select a column to serve as molecule title. It can be set to
“RowID” to use the dataframe row key as title.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Pharm2D.DefaultSigFactory(fdefFile=None, minPointCount=2, maxPointCount=3, bins=[(2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 100)])¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Pharm2D.Generate.Gen2DFingerprint(mol, sigFactory, perms=None, dMat=None, bitInfo=None)¶
generates a 2D fingerprint for a molecule using the
parameters in _sig_
Arguments


mol: the molecule for which the signature should be generated
sigFactory : the SigFactory object with signature parameters
NOTE: no preprocessing is carried out for _sigFactory_.

It must be pre-initialized.


perms: (optional) a sequence of permutation indices limiting which
pharmacophore combinations are allowed
dMat: (optional) the distance matrix to be used
bitInfo: (optional) used to return the atoms involved in the bits
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Pharm2D.Matcher.GetAtomsMatchingBit(sigFactory, bitIdx, mol, dMat=None, justOne=0, matchingAtoms=None)¶
Returns a list of lists of atom indices for a bit
Arguments


sigFactory: a SigFactory
bitIdx: the bit to be queried
mol: the molecule to be examined
dMat: (optional) the distance matrix of the molecule
justOne: (optional) if this is nonzero, only the first match
will be returned.
matchingAtoms: (optional) if this is nonzero, it should
contain a sequence of sequences with the indices of atoms in
the molecule which match each of the patterns used by the
signature.


Returns

a list of tuples with the matching atoms
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Pharm2D.Utils.BinsTriangleInequality(d1, d2, d3)¶
checks the triangle inequality for combinations
of distance bins.

the general triangle inequality is:d1 + d2 >= d3

the conservative binned form of this is:d1(upper) + d2(upper) >= d3(lower)
--------------------------------------------------------------------------------
rdkit.Chem.Pharm2D.Utils.CountUpTo(nItems, nSlots, vs, idx=0, startAt=0)¶

Figures out where a given combination of indices wouldoccur in the combinatorial explosion generated by _GetIndexCombinations_
Arguments


nItems: the number of items to distribute
nSlots: the number of slots in which to distribute them
vs: a sequence containing the values to find
idx: used in the recursion
startAt: used in the recursion




Returns

an integer
--------------------------------------------------------------------------------
rdkit.Chem.Pharm2D.Utils.GetAllCombinations(choices, noDups=1, which=0)¶
Does the combinatorial explosion of the possible combinations
of the elements of _choices_.
Arguments


choices: sequence of sequences with the elements to be enumerated
noDups: (optional) if this is nonzero, results with duplicates,
e.g. (1,1,0), will not be generated
which: used in recursion


Returns

a list of lists

>>> GetAllCombinations([(0, ), (1, ), (2, )])
[[0, 1, 2]]
>>> GetAllCombinations([(0, ), (1, 3), (2, )])
[[0, 1, 2], [0, 3, 2]]


>>> GetAllCombinations([(0, 1), (1, 3), (2, )])
[[0, 1, 2], [0, 3, 2], [1, 3, 2]]
--------------------------------------------------------------------------------
rdkit.Chem.Pharm2D.Utils.GetIndexCombinations(nItems, nSlots, slot=0, lastItemVal=0)¶

Generates all combinations of nItems in nSlots without includingduplicates


Arguments


nItems: the number of items to distribute
nSlots: the number of slots in which to distribute them
slot: used in recursion
lastItemVal: used in recursion


Returns

a list of lists
--------------------------------------------------------------------------------
rdkit.Chem.Pharm2D.Utils.GetPossibleScaffolds(nPts, bins, useTriangleInequality=True)¶
gets all realizable scaffolds (passing the triangle inequality) with the
given number of points and returns them as a list of tuples
--------------------------------------------------------------------------------
rdkit.Chem.Pharm2D.Utils.GetTriangles(nPts)¶
returns a tuple with the distance indices for
triangles composing an nPts-pharmacophore
--------------------------------------------------------------------------------
rdkit.Chem.Pharm2D.Utils.GetUniqueCombinations(choices, classes, which=0)¶
Does the combinatorial explosion of the possible combinations
of the elements of _choices_.
--------------------------------------------------------------------------------
rdkit.Chem.Pharm2D.Utils.GetUniqueCombinations_new(choices, classes, which=0)¶
Does the combinatorial explosion of the possible combinations
of the elements of _choices_.
--------------------------------------------------------------------------------
rdkit.Chem.Pharm2D.Utils.NumCombinations(nItems, nSlots)¶
returns the number of ways to fit nItems into nSlots
We assume that (x, y) and (y, x) are equivalent, and
(x, x) is allowed.

General formula is, for N items and S slots:res = (N+S-1)! / ( (N-1)! * S! )
--------------------------------------------------------------------------------
rdkit.Chem.Pharm2D.Utils.OrderTriangle(featIndices, dists)¶
put the distances for a triangle into canonical order
It’s easy if the features are all different:
>>> OrderTriangle([0, 2, 4], [1, 2, 3])
([0, 2, 4], [1, 2, 3])


It’s trickiest if they are all the same:
>>> OrderTriangle([0, 0, 0], [1, 2, 3])
([0, 0, 0], [3, 2, 1])
>>> OrderTriangle([0, 0, 0], [2, 1, 3])
([0, 0, 0], [3, 2, 1])
>>> OrderTriangle([0, 0, 0], [1, 3, 2])
([0, 0, 0], [3, 2, 1])
>>> OrderTriangle([0, 0, 0], [3, 1, 2])
([0, 0, 0], [3, 2, 1])
>>> OrderTriangle([0, 0, 0], [3, 2, 1])
([0, 0, 0], [3, 2, 1])


>>> OrderTriangle([0, 0, 1], [3, 2, 1])
([0, 0, 1], [3, 2, 1])
>>> OrderTriangle([0, 0, 1], [1, 3, 2])
([0, 0, 1], [1, 3, 2])
>>> OrderTriangle([0, 0, 1], [1, 2, 3])
([0, 0, 1], [1, 3, 2])
--------------------------------------------------------------------------------
rdkit.Chem.Pharm2D.Utils.ScaffoldPasses(combo, bins=None)¶
checks the scaffold passed in to see if all
contributing triangles can satisfy the triangle inequality
the scaffold itself (encoded in combo) is a list of binned distances
--------------------------------------------------------------------------------
rdkit.Chem.Pharm2D.Utils.UniquifyCombinations(combos)¶
uniquifies the combinations in the argument
Arguments:


combos: a sequence of sequences


Returns


a list of tuples containing the unique combos
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.AddExcludedVolumes(bm, excludedVolumes, smoothIt=True)¶
Adds a set of excluded volumes to the bounds matrix
and returns the new matrix
excludedVolumes is a list of ExcludedVolume objects

>>> boundsMat = numpy.array([[0.0, 2.0, 2.0],[1.0, 0.0, 2.0],[1.0, 1.0, 0.0]])
>>> ev1 = ExcludedVolume.ExcludedVolume(([(0, ), 0.5, 1.0], ), exclusionDist=1.5)
>>> bm = AddExcludedVolumes(boundsMat, (ev1, ))


the results matrix is one bigger:
>>> bm.shape == (4, 4)
True


and the original bounds mat is not altered:
>>> boundsMat.shape == (3, 3)
True


>>> print(', '.join([f'{x:.3f}' for x in bm[-1]]))
0.500, 1.500, 1.500, 0.000
>>> print(', '.join([f'{x:.3f}' for x in bm[:,-1]]))
1.000, 3.000, 3.000, 0.000
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.Check2DBounds(atomMatch, mol, pcophore)¶
checks to see if a particular mapping of features onto
a molecule satisfies a pharmacophore’s 2D restrictions
>>> from rdkit import Geometry
>>> from rdkit.Chem.Pharm3D import Pharmacophore
>>> activeFeats = [
...  ChemicalFeatures.FreeChemicalFeature('Acceptor', Geometry.Point3D(0.0, 0.0, 0.0)),
...  ChemicalFeatures.FreeChemicalFeature('Donor', Geometry.Point3D(0.0, 0.0, 0.0))]
>>> pcophore= Pharmacophore.Pharmacophore(activeFeats)
>>> pcophore.setUpperBound2D(0, 1, 3)
>>> m = Chem.MolFromSmiles('FCC(N)CN')
>>> Check2DBounds(((0, ), (3, )), m, pcophore)
True
>>> Check2DBounds(((0, ), (5, )), m, pcophore)
False
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.CoarseScreenPharmacophore(atomMatch, bounds, pcophore, verbose=False)¶
>>> from rdkit import Geometry
>>> from rdkit.Chem.Pharm3D import Pharmacophore
>>> feats = [
...   ChemicalFeatures.FreeChemicalFeature('HBondAcceptor', 'HAcceptor1',
...                                        Geometry.Point3D(0.0, 0.0, 0.0)),
...   ChemicalFeatures.FreeChemicalFeature('HBondDonor', 'HDonor1',
...                                        Geometry.Point3D(2.65, 0.0, 0.0)),
...   ChemicalFeatures.FreeChemicalFeature('Aromatic', 'Aromatic1',
...                                        Geometry.Point3D(5.12, 0.908, 0.0)),
...   ]
>>> pcophore = Pharmacophore.Pharmacophore(feats)
>>> pcophore.setLowerBound(0, 1, 1.1)
>>> pcophore.setUpperBound(0, 1, 1.9)
>>> pcophore.setLowerBound(0, 2, 2.1)
>>> pcophore.setUpperBound(0, 2, 2.9)
>>> pcophore.setLowerBound(1, 2, 2.1)
>>> pcophore.setUpperBound(1, 2, 3.9)


>>> bounds = numpy.array([[0, 2, 3],[1, 0, 4],[2, 3, 0]], dtype=numpy.float64)
>>> CoarseScreenPharmacophore(((0, ),(1, )),bounds, pcophore)
True


>>> CoarseScreenPharmacophore(((0, ),(2, )),bounds, pcophore)
False


>>> CoarseScreenPharmacophore(((1, ),(2, )),bounds, pcophore)
False


>>> CoarseScreenPharmacophore(((0, ),(1, ),(2, )),bounds, pcophore)
True


>>> CoarseScreenPharmacophore(((1, ),(0, ),(2, )),bounds, pcophore)
False


>>> CoarseScreenPharmacophore(((2, ),(1, ),(0, )),bounds, pcophore)
False


# we ignore the point locations here and just use their definitions:
>>> feats = [
...   ChemicalFeatures.FreeChemicalFeature('HBondAcceptor', 'HAcceptor1',
...                                        Geometry.Point3D(0.0, 0.0, 0.0)),
...   ChemicalFeatures.FreeChemicalFeature('HBondDonor', 'HDonor1',
...                                        Geometry.Point3D(2.65, 0.0, 0.0)),
...   ChemicalFeatures.FreeChemicalFeature('Aromatic', 'Aromatic1',
...                                        Geometry.Point3D(5.12, 0.908, 0.0)),
...   ChemicalFeatures.FreeChemicalFeature('HBondDonor', 'HDonor1',
...                                        Geometry.Point3D(2.65, 0.0, 0.0)),
...                ]
>>> pcophore=Pharmacophore.Pharmacophore(feats)
>>> pcophore.setLowerBound(0,1, 2.1)
>>> pcophore.setUpperBound(0,1, 2.9)
>>> pcophore.setLowerBound(0,2, 2.1)
>>> pcophore.setUpperBound(0,2, 2.9)
>>> pcophore.setLowerBound(0,3, 2.1)
>>> pcophore.setUpperBound(0,3, 2.9)
>>> pcophore.setLowerBound(1,2, 1.1)
>>> pcophore.setUpperBound(1,2, 1.9)
>>> pcophore.setLowerBound(1,3, 1.1)
>>> pcophore.setUpperBound(1,3, 1.9)
>>> pcophore.setLowerBound(2,3, 1.1)
>>> pcophore.setUpperBound(2,3, 1.9)
>>> bounds = numpy.array([[0, 3, 3, 3], 
...                       [2, 0, 2, 2], 
...                       [2, 1, 0, 2], 
...                       [2, 1, 1, 0]], 
...                      dtype=numpy.float64)


>>> CoarseScreenPharmacophore(((0, ), (1, ), (2, ), (3, )), bounds, pcophore)
True


>>> CoarseScreenPharmacophore(((0, ), (1, ), (3, ), (2, )), bounds, pcophore)
True


>>> CoarseScreenPharmacophore(((1, ), (0, ), (3, ), (2, )), bounds, pcophore)
False
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.CombiEnum(sequence)¶
This generator takes a sequence of sequences as an argument and
provides all combinations of the elements of the subsequences:
>>> gen = CombiEnum(((1, 2), (10, 20)))
>>> next(gen)
[1, 10]
>>> next(gen)
[1, 20]


>>> [x for x in CombiEnum(((1, 2), (10,20)))]
[[1, 10], [1, 20], [2, 10], [2, 20]]


>>> [x for x in CombiEnum(((1, 2),(10, 20), (100, 200)))]
[[1, 10, 100], [1, 10, 200], [1, 20, 100], [1, 20, 200], [2, 10, 100],
 [2, 10, 200], [2, 20, 100], [2, 20, 200]]
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.ComputeChiralVolume(mol, centerIdx, confId=-1)¶
Computes the chiral volume of an atom
We’re using the chiral volume formula from Figure 7 of
Blaney and Dixon, Rev. Comp. Chem. V, 299-335 (1994)

>>> import os.path
>>> from rdkit import RDConfig
>>> dataDir = os.path.join(RDConfig.RDCodeDir,'Chem/Pharm3D/test_data')


R configuration atoms give negative volumes:
>>> mol = Chem.MolFromMolFile(os.path.join(dataDir, 'mol-r.mol'))
>>> Chem.AssignStereochemistry(mol)
>>> mol.GetAtomWithIdx(1).GetProp('_CIPCode')
'R'
>>> ComputeChiralVolume(mol, 1) < 0
True


S configuration atoms give positive volumes:
>>> mol = Chem.MolFromMolFile(os.path.join(dataDir, 'mol-s.mol'))
>>> Chem.AssignStereochemistry(mol)
>>> mol.GetAtomWithIdx(1).GetProp('_CIPCode')
'S'
>>> ComputeChiralVolume(mol, 1) > 0
True


Non-chiral (or non-specified) atoms give zero volume:
>>> ComputeChiralVolume(mol, 0) == 0.0
True


We also work on 3-coordinate atoms (with implicit Hs):
>>> mol = Chem.MolFromMolFile(os.path.join(dataDir, 'mol-r-3.mol'))
>>> Chem.AssignStereochemistry(mol)
>>> mol.GetAtomWithIdx(1).GetProp('_CIPCode')
'R'
>>> ComputeChiralVolume(mol, 1) < 0
True


>>> mol = Chem.MolFromMolFile(os.path.join(dataDir, 'mol-s-3.mol'))
>>> Chem.AssignStereochemistry(mol)
>>> mol.GetAtomWithIdx(1).GetProp('_CIPCode')
'S'
>>> ComputeChiralVolume(mol, 1) > 0
True
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.ConstrainedEnum(matches, mol, pcophore, bounds, use2DLimits=False, index=0, soFar=[])¶
Enumerates the list of atom mappings a molecule
has to a particular pharmacophore.
We do check distance bounds here.
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.DownsampleBoundsMatrix(bm, indices, maxThresh=4.0)¶
Removes rows from a bounds matrix that are that are greater 
than a threshold value away from a set of other points
Returns the modfied bounds matrix
The goal of this function is to remove rows from the bounds matrix
that correspond to atoms (atomic index) that are likely to be quite far from
the pharmacophore we’re interested in. Because the bounds smoothing
we eventually have to do is N^3, this can be a big win

>>> boundsMat = numpy.array([[0.0, 3.0, 4.0],[2.0, 0.0, 3.0],[2.0, 2.0, 0.0]])
>>> bm = DownsampleBoundsMatrix(boundsMat,(0, ), 3.5)
>>> bm.shape == (2, 2)
True


we don’t touch the input matrix:
>>> boundsMat.shape == (3, 3)
True


>>> print(', '.join([f'{x:.3f}' for x in bm[0]]))
0.000, 3.000
>>> print(', '.join([f'{x:.3f}' for x in bm[1]]))
2.000, 0.000


if the threshold is high enough, we don’t do anything:
>>> boundsMat = numpy.array([[0.0, 4.0, 3.0],[2.0, 0.0, 3.0],[2.0, 2.0, 0.0]])
>>> bm = DownsampleBoundsMatrix(boundsMat, (0, ), 5.0)
>>> bm.shape == (3, 3)
True


If there’s a max value that’s close enough to any of the indices
we pass in, we’ll keep it:
>>> boundsMat = numpy.array([[0.0, 4.0, 3.0],[2.0, 0.0, 3.0],[2.0, 2.0, 0.0]])
>>> bm = DownsampleBoundsMatrix(boundsMat, (0, 1), 3.5)
>>> bm.shape == (3, 3)
True


However, the datatype should not be changed or uprank into np.float64 as default behaviour
>>> boundsMat = numpy.array([[0.0, 4.0, 3.0],[2.0, 0.0, 3.0],[2.0, 2.0, 0.0]], dtype=numpy.float32)
>>> bm = DownsampleBoundsMatrix(boundsMat,(0, 1), 3.5)
>>> bm.dtype == numpy.float64
False
>>> bm.dtype == numpy.float32 or numpy.issubdtype(bm.dtype, numpy.float32)
True
>>> bm.dtype == boundsMat.dtype or numpy.issubdtype(bm.dtype, boundsMat.dtype)
True
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.EmbedMol(mol, bm, atomMatch=None, weight=2.0, randomSeed=-1, excludedVolumes=None)¶
Generates an embedding for a molecule based on a bounds matrix and adds
a conformer (id 0) to the molecule
if the optional argument atomMatch is provided, it will be used to provide
supplemental weights for the embedding routine (used in the optimization
phase to ensure that the resulting geometry really does satisfy the
pharmacophore).
if the excludedVolumes is provided, it should be a sequence of
ExcludedVolume objects
>>> m = Chem.MolFromSmiles('c1ccccc1C')
>>> bounds = MolDG.GetMoleculeBoundsMatrix(m)
>>> bounds.shape == (7, 7)
True
>>> m.GetNumConformers()
0
>>> EmbedMol(m,bounds,randomSeed=23)
>>> m.GetNumConformers()
1
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.EmbedOne(mol, name, match, pcophore, count=1, silent=0, **kwargs)¶
generates statistics for a molecule’s embeddings

Four energies are computed for each embedding:
E1: the energy (with constraints) of the initial embedding
E2: the energy (with constraints) of the optimized embedding
E3: the energy (no constraints) the geometry for E2
E4: the energy (no constraints) of the optimized free-molecule
(starting from the E3 geometry)


Returns a 9-tuple:
the mean value of E1
the sample standard deviation of E1
the mean value of E2
the sample standard deviation of E2
the mean value of E3
the sample standard deviation of E3
the mean value of E4
the sample standard deviation of E4
The number of embeddings that failed
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.EmbedPharmacophore(mol, atomMatch, pcophore, randomSeed=-1, count=10, smoothFirst=True, silent=False, bounds=None, excludedVolumes=None, targetNumber=-1, useDirs=False)¶
Generates one or more embeddings for a molecule that satisfy a pharmacophore
atomMatch is a sequence of sequences containing atom indices
for each of the pharmacophore’s features.


count: is the maximum number of attempts to make a generating an embedding
smoothFirst: toggles triangle smoothing of the molecular bounds matix

bounds: if provided, should be the molecular bounds matrix. If this isn’tprovided, the matrix will be generated.




targetNumber: if this number is positive, it provides a maximum numberof embeddings to generate (i.e. we’ll have count attempts to generate
targetNumber embeddings).






returns: a 3 tuple:
the molecular bounds matrix adjusted for the pharmacophore
a list of embeddings (molecules with a single conformer)
the number of failed attempts at embedding

>>> from rdkit import Geometry
>>> from rdkit.Chem.Pharm3D import Pharmacophore
>>> m = Chem.MolFromSmiles('OCCN')
>>> feats = [
...   ChemicalFeatures.FreeChemicalFeature('HBondAcceptor', 'HAcceptor1',
...                                        Geometry.Point3D(0.0, 0.0, 0.0)),
...   ChemicalFeatures.FreeChemicalFeature('HBondDonor', 'HDonor1',
...                                        Geometry.Point3D(2.65, 0.0, 0.0)),
...   ]
>>> pcophore=Pharmacophore.Pharmacophore(feats)
>>> pcophore.setLowerBound(0,1, 2.5)
>>> pcophore.setUpperBound(0,1, 3.5)
>>> atomMatch = ((0, ), (3, ))


>>> bm,embeds,nFail = EmbedPharmacophore(m, atomMatch, pcophore, randomSeed=23, silent=1)
>>> len(embeds)
10
>>> nFail
0


Set up a case that can’t succeed:
>>> pcophore = Pharmacophore.Pharmacophore(feats)
>>> pcophore.setLowerBound(0,1, 2.0)
>>> pcophore.setUpperBound(0,1, 2.1)
>>> atomMatch = ((0, ), (3, ))


>>> bm, embeds, nFail = EmbedPharmacophore(m, atomMatch, pcophore, randomSeed=23, silent=1)
>>> len(embeds)
0
>>> nFail
10
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.GetAllPharmacophoreMatches(matches, bounds, pcophore, useDownsampling=0, progressCallback=None, use2DLimits=False, mol=None, verbose=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.GetAtomHeavyNeighbors(atom)¶
returns a list of the heavy-atom neighbors of the
atom passed in:
>>> m = Chem.MolFromSmiles('CCO')
>>> l = GetAtomHeavyNeighbors(m.GetAtomWithIdx(0))
>>> len(l)
1
>>> isinstance(l[0],Chem.Atom)
True
>>> l[0].GetIdx()
1


>>> l = GetAtomHeavyNeighbors(m.GetAtomWithIdx(1))
>>> len(l)
2
>>> l[0].GetIdx()
0
>>> l[1].GetIdx()
2
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.MatchFeatsToMol(mol, featFactory, features)¶
generates a list of all possible mappings of each feature to a molecule

Returns a 2-tuple:
a boolean indicating whether or not all features were found
a list, numFeatures long, of sequences of features

>>> import os.path
>>> from rdkit import RDConfig, Geometry
>>> fdefFile = os.path.join(RDConfig.RDCodeDir, 'Chem/Pharm3D/test_data/BaseFeatures.fdef')
>>> featFactory = ChemicalFeatures.BuildFeatureFactory(fdefFile)
>>> activeFeats = [
...  ChemicalFeatures.FreeChemicalFeature('Acceptor', Geometry.Point3D(0.0, 0.0, 0.0)),
...  ChemicalFeatures.FreeChemicalFeature('Donor', Geometry.Point3D(0.0, 0.0, 0.0))]
>>> m = Chem.MolFromSmiles('FCCN')
>>> match, mList = MatchFeatsToMol(m, featFactory, activeFeats)
>>> match
True


Two feature types:
>>> len(mList)
2


The first feature type, Acceptor, has two matches:
>>> len(mList[0])
2
>>> mList[0][0].GetAtomIds()
(0,)
>>> mList[0][1].GetAtomIds()
(3,)


The first feature type, Donor, has a single match:
>>> len(mList[1])
1
>>> mList[1][0].GetAtomIds()
(3,)
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.MatchPharmacophore(matches, bounds, pcophore, useDownsampling=False, use2DLimits=False, mol=None, excludedVolumes=None, useDirs=False)¶
if use2DLimits is set, the molecule must also be provided and topological
distances will also be used to filter out matches
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.MatchPharmacophoreToMol(mol, featFactory, pcophore)¶
generates a list of all possible mappings of a pharmacophore to a molecule

Returns a 2-tuple:
a boolean indicating whether or not all features were found
a list, numFeatures long, of sequences of features

>>> import os.path
>>> from rdkit import Geometry, RDConfig
>>> from rdkit.Chem.Pharm3D import Pharmacophore
>>> fdefFile = os.path.join(RDConfig.RDCodeDir,'Chem/Pharm3D/test_data/BaseFeatures.fdef')
>>> featFactory = ChemicalFeatures.BuildFeatureFactory(fdefFile)
>>> activeFeats = [
...  ChemicalFeatures.FreeChemicalFeature('Acceptor', Geometry.Point3D(0.0, 0.0, 0.0)),
...  ChemicalFeatures.FreeChemicalFeature('Donor',Geometry.Point3D(0.0, 0.0, 0.0))]
>>> pcophore= Pharmacophore.Pharmacophore(activeFeats)
>>> m = Chem.MolFromSmiles('FCCN')
>>> match, mList = MatchPharmacophoreToMol(m,featFactory,pcophore)
>>> match
True


Two feature types:
>>> len(mList)
2


The first feature type, Acceptor, has two matches:
>>> len(mList[0])
2
>>> mList[0][0].GetAtomIds()
(0,)
>>> mList[0][1].GetAtomIds()
(3,)


The first feature type, Donor, has a single match:
>>> len(mList[1])
1
>>> mList[1][0].GetAtomIds()
(3,)
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.OptimizeMol(mol, bm, atomMatches=None, excludedVolumes=None, forceConstant=1200.0, maxPasses=5, verbose=False)¶
carries out a UFF optimization for a molecule optionally subject
to the constraints in a bounds matrix



atomMatches, if provided, is a sequence of sequences
forceConstant is the force constant of the spring used to enforce
the constraints



returns a 2-tuple:
the energy of the initial conformation
the energy post-embedding



NOTE that these energies include the energies of the constraints

>>> from rdkit import Geometry
>>> from rdkit.Chem.Pharm3D import Pharmacophore
>>> m = Chem.MolFromSmiles('OCCN')
>>> feats = [
...  ChemicalFeatures.FreeChemicalFeature('HBondAcceptor', 'HAcceptor1',
...                                       Geometry.Point3D(0.0, 0.0, 0.0)),
...  ChemicalFeatures.FreeChemicalFeature('HBondDonor', 'HDonor1',
...                                       Geometry.Point3D(2.65, 0.0, 0.0)),
...  ]
>>> pcophore=Pharmacophore.Pharmacophore(feats)
>>> pcophore.setLowerBound(0,1, 2.5)
>>> pcophore.setUpperBound(0,1, 2.8)
>>> atomMatch = ((0, ), (3, ))
>>> bm, embeds, nFail = EmbedPharmacophore(m, atomMatch, pcophore, randomSeed=23, silent=1)
>>> len(embeds)
10
>>> testM = embeds[0]


Do the optimization:
>>> e1, e2 = OptimizeMol(testM,bm,atomMatches=atomMatch)


Optimizing should have lowered the energy:
>>> e2 < e1
True


Check the constrained distance:
>>> conf = testM.GetConformer(0)
>>> p0 = conf.GetAtomPosition(0)
>>> p3 = conf.GetAtomPosition(3)
>>> d03 = p0.Distance(p3)
>>> d03 >= pcophore.getLowerBound(0,1) - 0.01
True
>>> d03 <= pcophore.getUpperBound(0,1) + 0.01
True


If we optimize without the distance constraints (provided via the atomMatches
argument) we’re not guaranteed to get the same results, particularly in a case
like the current one where the pharmacophore brings the atoms uncomfortably
close together:
>>> testM = embeds[1]
>>> e1, e2 = OptimizeMol(testM,bm)
>>> e2 < e1
True
>>> conf = testM.GetConformer(0)
>>> p0 = conf.GetAtomPosition(0)
>>> p3 = conf.GetAtomPosition(3)
>>> d03 = p0.Distance(p3)
>>> d03 >= pcophore.getLowerBound(0, 1) - 0.01
True
>>> d03 <= pcophore.getUpperBound(0, 1) + 0.01
False
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.ReplaceGroup(match, bounds, slop=0.01, useDirs=False, dirLength=2.0)¶
Adds an entry at the end of the bounds matrix for a point at
the center of a multi-point feature

returns a 2-tuple:new bounds mat
index of point added


>>> boundsMat = numpy.array([[0.0, 2.0, 2.0],[1.0, 0.0, 2.0],[1.0, 1.0, 0.0]])
>>> match = [0, 1, 2]
>>> bm,idx = ReplaceGroup(match, boundsMat, slop=0.0)


the index is at the end:
>>> idx == 3
True


and the matrix is one bigger:
>>> bm.shape == (4, 4)
True


but the original bounds mat is not altered:
>>> boundsMat.shape == (3, 3)
True


We make the assumption that the points of the
feature form a regular polygon, are listed in order
(i.e. pt 0 is a neighbor to pt 1 and pt N-1)
and that the replacement point goes at the center:
>>> print(', '.join([f'{x:.3f}' for x in bm[-1]]))
0.577, 0.577, 0.577, 0.000
>>> print(', '.join([f'{x:.3f}' for x in bm[:,-1]]))
1.155, 1.155, 1.155, 0.000


The slop argument (default = 0.01) is fractional:
>>> bm, idx = ReplaceGroup(match, boundsMat)
>>> print(', '.join([f'{x:.3f}' for x in bm[-1]]))
0.572, 0.572, 0.572, 0.000
>>> print(', '.join([f'{x:.3f}' for x in bm[:,-1]]))
1.166, 1.166, 1.166, 0.000
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.UpdatePharmacophoreBounds(bm, atomMatch, pcophore, useDirs=False, dirLength=2.0, mol=None)¶
loops over a distance bounds matrix and replaces the elements
that are altered by a pharmacophore
NOTE this returns the resulting bounds matrix, but it may also
alter the input matrix
atomMatch is a sequence of sequences containing atom indices
for each of the pharmacophore’s features.

>>> from rdkit import Geometry
>>> from rdkit.Chem.Pharm3D import Pharmacophore
>>> feats = [
...   ChemicalFeatures.FreeChemicalFeature('HBondAcceptor', 'HAcceptor1',
...                                        Geometry.Point3D(0.0, 0.0, 0.0)),
...   ChemicalFeatures.FreeChemicalFeature('HBondDonor', 'HDonor1',
...                                        Geometry.Point3D(2.65, 0.0, 0.0)),
...   ]
>>> pcophore = Pharmacophore.Pharmacophore(feats)
>>> pcophore.setLowerBound(0,1, 1.0)
>>> pcophore.setUpperBound(0,1, 2.0)


>>> boundsMat = numpy.array([[0.0, 3.0, 3.0],[2.0, 0.0, 3.0],[2.0, 2.0, 0.0]])
>>> atomMatch = ((0, ), (1, ))
>>> bm = UpdatePharmacophoreBounds(boundsMat, atomMatch, pcophore)



In this case, there are no multi-atom features, so the result matrix
is the same as the input:
>>> bm is boundsMat
True


this means, of course, that the input boundsMat is altered:
>>> print(', '.join([f'{x:.3f}' for x in boundsMat[0]]))
0.000, 2.000, 3.000
>>> print(', '.join([f'{x:.3f}' for x in boundsMat[1]]))
1.000, 0.000, 3.000
>>> print(', '.join([f'{x:.3f}' for x in boundsMat[2]]))
2.000, 2.000, 0.000
--------------------------------------------------------------------------------
rdkit.Chem.Pharm3D.EmbedLib.isNaN(v)¶
provides an OS independent way of detecting NaNs
This is intended to be used with values returned from the C++
side of things.
We can’t actually test this from Python (which traps
zero division errors), but it would work something like
this if we could:
>>> isNaN(0)
False


#>>> isNan(1/0)
#True
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.QED.ads(x, adsParameter)¶
ADS function
--------------------------------------------------------------------------------
rdkit.Chem.QED.default(mol)¶
Calculates the QED descriptor using average descriptor weights.
--------------------------------------------------------------------------------
rdkit.Chem.QED.properties(mol)¶
Calculates the properties that are required to calculate the QED descriptor.
--------------------------------------------------------------------------------
rdkit.Chem.QED.qed(mol, w=(0.66, 0.46, 0.05, 0.61, 0.06, 0.65, 0.48, 0.95), qedProperties=None)¶
Calculate the weighted sum of ADS mapped properties
some examples from the QED paper, reference values from Peter G’s original implementation
>>> m = Chem.MolFromSmiles(‘N=C(CCSCc1csc(N=C(N)N)n1)NS(N)(=O)=O’)
>>> qed(m)
0.253…
>>> m = Chem.MolFromSmiles(‘CNC(=NCCSCc1nc[nH]c1C)NC#N’)
>>> qed(m)
0.234…
>>> m = Chem.MolFromSmiles(‘CCCCCNC(=N)NN=Cc1c[nH]c2ccc(CO)cc12’)
>>> qed(m)
0.234…
--------------------------------------------------------------------------------
rdkit.Chem.QED.weights_max(mol)¶
Calculates the QED descriptor using maximal descriptor weights.
--------------------------------------------------------------------------------
rdkit.Chem.QED.weights_mean(mol)¶
Calculates the QED descriptor using average descriptor weights.
--------------------------------------------------------------------------------
rdkit.Chem.QED.weights_none(mol)¶
Calculates the QED descriptor using unit weights.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Randomize.RandomizeMol(mol)¶
--------------------------------------------------------------------------------
rdkit.Chem.Randomize.RandomizeMolBlock(molblock)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdAbbreviations.CondenseAbbreviationSubstanceGroups((Mol)mol) → Mol :¶
Finds and replaces abbreviation (i.e. “SUP”) substance groups in a molecule. The result is not sanitized.

C++ signature :RDKit::ROMol* CondenseAbbreviationSubstanceGroups(RDKit::ROMol const*)
--------------------------------------------------------------------------------
rdkit.Chem.rdAbbreviations.CondenseMolAbbreviations((Mol)mol, (AtomPairsParameters)abbrevs[, (float)maxCoverage=0.4[, (bool)sanitize=True]]) → Mol :¶
Finds and replaces abbreviations in a molecule. The result is not sanitized.

C++ signature :RDKit::ROMol* CondenseMolAbbreviations(RDKit::ROMol const*,boost::python::api::object [,double=0.4 [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdAbbreviations.GetDefaultAbbreviations() → _vectN5RDKit13Abbreviations22AbbreviationDefinitionE :¶
returns a list of the default abbreviation definitions

C++ signature :std::vector<RDKit::Abbreviations::AbbreviationDefinition, std::allocator<RDKit::Abbreviations::AbbreviationDefinition> > GetDefaultAbbreviations()
--------------------------------------------------------------------------------
rdkit.Chem.rdAbbreviations.GetDefaultLinkers() → _vectN5RDKit13Abbreviations22AbbreviationDefinitionE :¶
returns a list of the default linker definitions

C++ signature :std::vector<RDKit::Abbreviations::AbbreviationDefinition, std::allocator<RDKit::Abbreviations::AbbreviationDefinition> > GetDefaultLinkers()
--------------------------------------------------------------------------------
rdkit.Chem.rdAbbreviations.LabelMolAbbreviations((Mol)mol, (AtomPairsParameters)abbrevs[, (float)maxCoverage=0.4]) → Mol :¶
Finds abbreviations and adds to them to a molecule as “SUP” SubstanceGroups

C++ signature :RDKit::ROMol* LabelMolAbbreviations(RDKit::ROMol const*,boost::python::api::object [,double=0.4])
--------------------------------------------------------------------------------
rdkit.Chem.rdAbbreviations.ParseAbbreviations((str)text[, (bool)removeExtraDummies=False[, (bool)allowConnectionToDummies=False]]) → _vectN5RDKit13Abbreviations22AbbreviationDefinitionE :¶
returns a set of abbreviation definitions from a string

C++ signature :std::vector<RDKit::Abbreviations::AbbreviationDefinition, std::allocator<RDKit::Abbreviations::AbbreviationDefinition> > ParseAbbreviations(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=False [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdAbbreviations.ParseLinkers((str)text) → _vectN5RDKit13Abbreviations22AbbreviationDefinitionE :¶
returns a set of linker definitions from a string

C++ signature :std::vector<RDKit::Abbreviations::AbbreviationDefinition, std::allocator<RDKit::Abbreviations::AbbreviationDefinition> > ParseLinkers(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdchem.AddMolSubstanceGroup((Mol)mol, (SubstanceGroup)sgroup) → SubstanceGroup :¶
adds a copy of a SubstanceGroup to a molecule, returns the new SubstanceGroup

C++ signature :RDKit::SubstanceGroup* AddMolSubstanceGroup(RDKit::ROMol {lvalue},RDKit::SubstanceGroup)
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.ClearMolSubstanceGroups((Mol)mol) → None :¶
removes all SubstanceGroups from a molecule (if any)

C++ signature :void ClearMolSubstanceGroups(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.CreateMolDataSubstanceGroup((Mol)mol, (str)fieldName, (str)value) → SubstanceGroup :¶
creates a new DATA SubstanceGroup associated with a molecule, returns the new SubstanceGroup

C++ signature :RDKit::SubstanceGroup* CreateMolDataSubstanceGroup(RDKit::ROMol {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.CreateMolSubstanceGroup((Mol)mol, (str)type) → SubstanceGroup :¶
creates a new SubstanceGroup associated with a molecule, returns the new SubstanceGroup

C++ signature :RDKit::SubstanceGroup* CreateMolSubstanceGroup(RDKit::ROMol {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.CreateStereoGroup((StereoGroupType)stereoGroupType, (Mol)mol, (AtomPairsParameters)atomIds[, (int)readId=0]) → StereoGroup :¶
creates a StereoGroup associated with a molecule from a list of atom Ids

C++ signature :RDKit::StereoGroup* CreateStereoGroup(RDKit::StereoGroupType,RDKit::ROMol {lvalue},boost::python::api::object [,unsigned int=0])
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.ForwardStereoGroupIds((Mol)mol) → None :¶
Forward the original Stereo Group IDs when exporting the Mol.

C++ signature :void ForwardStereoGroupIds(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.GetAtomAlias((Atom)atom) → str :¶
Returns the atom’s MDL alias text

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > GetAtomAlias(RDKit::Atom const*)
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.GetAtomRLabel((Atom)atom) → int :¶
Returns the atom’s MDL AtomRLabel (this is an integer from 0 to 99)

C++ signature :int GetAtomRLabel(RDKit::Atom const*)
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.GetAtomValue((Atom)atom) → str :¶
Returns the atom’s MDL alias text

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > GetAtomValue(RDKit::Atom const*)
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.GetDefaultPickleProperties() → int :¶
Get the current global mol pickler options.

C++ signature :unsigned int GetDefaultPickleProperties()
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.GetMolSubstanceGroupWithIdx((Mol)mol, (int)idx) → SubstanceGroup :¶
returns a particular SubstanceGroup from the molecule

C++ signature :RDKit::SubstanceGroup* GetMolSubstanceGroupWithIdx(RDKit::ROMol {lvalue},unsigned int)
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.GetMolSubstanceGroups((Mol)mol) → SubstanceGroup_VECT :¶
returns a copy of the molecule’s SubstanceGroups (if any)

C++ signature :std::vector<RDKit::SubstanceGroup, std::allocator<RDKit::SubstanceGroup> > GetMolSubstanceGroups(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.GetNumPiElectrons((Atom)atom) → int :¶
Returns the number of electrons an atom is using for pi bonding

C++ signature :unsigned int GetNumPiElectrons(RDKit::Atom)
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.GetPeriodicTable() → PeriodicTable :¶
Returns the application’s PeriodicTable instance.

C++ signature :RDKit::PeriodicTable* GetPeriodicTable()
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.GetSupplementalSmilesLabel((Atom)atom) → str :¶
Gets the supplemental smiles label on an atom, returns an empty string if not present.

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > GetSupplementalSmilesLabel(RDKit::Atom const*)
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.MolBundleCanSerialize() → bool :¶
Returns True if the MolBundle is serializable (requires boost serialization

C++ signature :bool MolBundleCanSerialize()
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.SetAtomAlias((Atom)atom, (str)rlabel) → None :¶
Sets the atom’s MDL alias text.
Setting to an empty string clears the alias.

C++ signature :void SetAtomAlias(RDKit::Atom*,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.SetAtomRLabel((Atom)atom, (int)rlabel) → None :¶
Sets the atom’s MDL RLabel (this is an integer from 0 to 99).
Setting to 0 clears the rlabel.

C++ signature :void SetAtomRLabel(RDKit::Atom*,int)
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.SetAtomValue((Atom)atom, (str)rlabel) → None :¶
Sets the atom’s MDL alias text.
Setting to an empty string clears the alias.

C++ signature :void SetAtomValue(RDKit::Atom*,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.SetDefaultPickleProperties((int)arg1) → None :¶
Set the current global mol pickler options.

C++ signature :void SetDefaultPickleProperties(unsigned int)
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.SetSupplementalSmilesLabel((Atom)atom, (str)label) → None :¶
Sets a supplemental label on an atom that is written to the smiles string.
>>> m = Chem.MolFromSmiles("C")
>>> Chem.SetSupplementalSmilesLabel(m.GetAtomWithIdx(0), '<xxx>')
>>> Chem.MolToSmiles(m)
'C<xxx>'



C++ signature :void SetSupplementalSmilesLabel(RDKit::Atom*,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdchem.tossit() → None :¶

C++ signature :void tossit()
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.Compute2DCoordsForReaction((ChemicalReaction)reaction[, (float)spacing=1.0[, (bool)updateProps=True[, (bool)canonOrient=True[, (int)nFlipsPerSample=0[, (int)nSample=0[, (int)sampleSeed=0[, (bool)permuteDeg4Nodes=False[, (float)bondLength=-1.0]]]]]]]]) → None :¶

Compute 2D coordinates for a reaction. 
ARGUMENTS: 
reaction - the reaction of interest
spacing - the amount of space left between components of the reaction
canonOrient - orient the reactants and products in a canonical way

updateProps - if set, properties such as conjugation andhybridization will be calculated for the reactant and product
templates before generating coordinates. This should result in
better depictions, but can lead to errors in some cases.




nFlipsPerSample - number of rotatable bonds that areflipped at random at a time.



nSample - Number of random samplings of rotatable bonds.
sampleSeed - seed for the random sampling process.

permuteDeg4Nodes - allow permutation of bonds at a degree 4node during the sampling process



bondLength - change the default bond length for depiction




C++ signature :void Compute2DCoordsForReaction(RDKit::ChemicalReaction {lvalue} [,double=1.0 [,bool=True [,bool=True [,unsigned int=0 [,unsigned int=0 [,int=0 [,bool=False [,double=-1.0]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.CreateDifferenceFingerprintForReaction((ChemicalReaction)reaction[, (ReactionFingerprintParams)ReactionFingerPrintParams=<rdkit.Chem.rdChemReactions.ReactionFingerprintParams object at 0x76141c0e26c0>]) → UIntSparseIntVect :¶
construct a difference fingerprint for a ChemicalReaction by subtracting the reactant fingerprint from the product fingerprint

C++ signature :RDKit::SparseIntVect<unsigned int>* CreateDifferenceFingerprintForReaction(RDKit::ChemicalReaction [,RDKit::ReactionFingerprintParams=<rdkit.Chem.rdChemReactions.ReactionFingerprintParams object at 0x76141c0e26c0>])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.CreateStructuralFingerprintForReaction((ChemicalReaction)reaction[, (ReactionFingerprintParams)ReactionFingerPrintParams=<rdkit.Chem.rdChemReactions.ReactionFingerprintParams object at 0x76141c0e27c0>]) → ExplicitBitVect :¶
construct a structural fingerprint for a ChemicalReaction by concatenating the reactant fingerprint and the product fingerprint

C++ signature :ExplicitBitVect* CreateStructuralFingerprintForReaction(RDKit::ChemicalReaction [,RDKit::ReactionFingerprintParams=<rdkit.Chem.rdChemReactions.ReactionFingerprintParams object at 0x76141c0e27c0>])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.EnumerateLibraryCanSerialize() → bool :¶
Returns True if the EnumerateLibrary is serializable (requires boost serialization

C++ signature :bool EnumerateLibraryCanSerialize()
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.GetChemDrawRxnAdjustParams() → AdjustQueryParameters :¶

(deprecated, see MatchOnlyAtRgroupsAdjustParams)Returns the chemdraw style adjustment parameters for reactant templates

C++ signature :RDKit::MolOps::AdjustQueryParameters GetChemDrawRxnAdjustParams()
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.GetDefaultAdjustParams() → AdjustQueryParameters :¶
Returns the default adjustment parameters for reactant templates

C++ signature :RDKit::MolOps::AdjustQueryParameters GetDefaultAdjustParams()
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.HasAgentTemplateSubstructMatch((ChemicalReaction)reaction, (ChemicalReaction)queryReaction) → bool :¶
tests if the agents of a queryReaction are the same as those of a reaction

C++ signature :bool HasAgentTemplateSubstructMatch(RDKit::ChemicalReaction,RDKit::ChemicalReaction)
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.HasProductTemplateSubstructMatch((ChemicalReaction)reaction, (ChemicalReaction)queryReaction) → bool :¶
tests if the products of a queryReaction are substructures of the products of a reaction

C++ signature :bool HasProductTemplateSubstructMatch(RDKit::ChemicalReaction,RDKit::ChemicalReaction)
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.HasReactantTemplateSubstructMatch((ChemicalReaction)reaction, (ChemicalReaction)queryReaction) → bool :¶
tests if the reactants of a queryReaction are substructures of the reactants of a reaction

C++ signature :bool HasReactantTemplateSubstructMatch(RDKit::ChemicalReaction,RDKit::ChemicalReaction)
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.HasReactionAtomMapping((ChemicalReaction)rxn) → bool :¶
tests if a reaction obtains any atom mapping

C++ signature :bool HasReactionAtomMapping(RDKit::ChemicalReaction)
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.HasReactionSubstructMatch((ChemicalReaction)reaction, (ChemicalReaction)queryReaction[, (bool)includeAgents=False]) → bool :¶
tests if the queryReaction is a substructure of a reaction

C++ signature :bool HasReactionSubstructMatch(RDKit::ChemicalReaction,RDKit::ChemicalReaction [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.IsReactionTemplateMoleculeAgent((Mol)molecule, (float)agentThreshold) → bool :¶
tests if a molecule can be classified as an agent depending on the ratio of mapped atoms and a give threshold

C++ signature :bool IsReactionTemplateMoleculeAgent(RDKit::ROMol,double)
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.MatchOnlyAtRgroupsAdjustParams() → AdjustQueryParameters :¶
Only match at the specified rgroup locations in the reactant templates

C++ signature :RDKit::MolOps::AdjustQueryParameters MatchOnlyAtRgroupsAdjustParams()
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.MrvBlockIsReaction((str)mrvData) → bool :¶
returns whether or not an MRV block contains reaction data

C++ signature :bool MrvBlockIsReaction(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.MrvFileIsReaction((str)filename) → bool :¶
returns whether or not an MRV file contains reaction data

C++ signature :bool MrvFileIsReaction(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.PreprocessReaction((ChemicalReaction)reaction[, (dict)queries={}[, (str)propName='molFileValue']]) → object :¶
A function for preprocessing reactions with more specific queries.
Queries are indicated by labels on atoms (molFileAlias property by default)
When these labels are found, more specific queries are placed on the atoms.
By default, the available quieries come from

FilterCatalog.GetFlattenedFunctionalGroupHierarchy(True)n


Sample Usage:>>> from rdkit import Chem, RDConfig
>>> from rdkit.Chem import MolFromSmiles, AllChem
>>> from rdkit.Chem.rdChemReactions import PreprocessReaction
>>> import os
>>> testFile = os.path.join(RDConfig.RDCodeDir,'Chem','SimpleEnum','test_data','boronic1.rxn')
>>> rxn = AllChem.ReactionFromRxnFile(testFile)
>>> rxn.Initialize()
>>> nWarn,nError,nReacts,nProds,reactantLabels = PreprocessReaction(rxn)
>>> nWarn
0
>>> nError
0
>>> nReacts
2
>>> nProds
1
>>> reactantLabels
(((0, 'halogen.bromine.aromatic'),), ((1, 'boronicacid'),))




If there are functional group labels in the input reaction (via atoms with molFileValue properties),
the corresponding atoms will have queries added to them so that they only match such things. We can
see this here:
>>> rxn = AllChem.ReactionFromRxnFile(testFile)
>>> rxn.Initialize()
>>> r1 = rxn.GetReactantTemplate(0)
>>> m1 = Chem.MolFromSmiles('CCBr')
>>> m2 = Chem.MolFromSmiles('c1ccccc1Br')



These both match because the reaction file itself just has R1-Br:>>> m1.HasSubstructMatch(r1)
True
>>> m2.HasSubstructMatch(r1)
True



After preprocessing, we only match the aromatic Br:>>> d = PreprocessReaction(rxn)
>>> m1.HasSubstructMatch(r1)
False
>>> m2.HasSubstructMatch(r1)
True



We also support or queries in the values field (separated by commas):>>> testFile = os.path.join(RDConfig.RDCodeDir,'Chem','SimpleEnum','test_data','azide_reaction.rxn')
>>> rxn = AllChem.ReactionFromRxnFile(testFile)
>>> rxn.Initialize()
>>> reactantLabels = PreprocessReaction(rxn)[-1]
>>> reactantLabels
(((1, 'azide'),), ((1, 'carboxylicacid,acidchloride'),))
>>> m1 = Chem.MolFromSmiles('CC(=O)O')
>>> m2 = Chem.MolFromSmiles('CC(=O)Cl')
>>> m3 = Chem.MolFromSmiles('CC(=O)N')
>>> r2 = rxn.GetReactantTemplate(1)
>>> m1.HasSubstructMatch(r2)
True
>>> m2.HasSubstructMatch(r2)
True
>>> m3.HasSubstructMatch(r2)
False



unrecognized final group types are returned as None:>>> testFile = os.path.join(RDConfig.RDCodeDir,'Chem','SimpleEnum','test_data','bad_value1.rxn')
>>> rxn = AllChem.ReactionFromRxnFile(testFile)
>>> rxn.Initialize()
>>> nWarn,nError,nReacts,nProds,reactantLabels = PreprocessReaction(rxn)
Traceback (most recent call last):
  ...
KeyError: 'boromicacid'



One unrecognized group type in a comma-separated list makes the whole thing fail:>>> testFile = os.path.join(RDConfig.RDCodeDir,'Chem','SimpleEnum','test_data','bad_value2.rxn')
>>> rxn = AllChem.ReactionFromRxnFile(testFile)
>>> rxn.Initialize()
>>> nWarn,nError,nReacts,nProds,reactantLabels = PreprocessReaction(rxn)
Traceback (most recent call last):
  ...
KeyError: 'carboxylicacid,acidchlroide'
>>> testFile = os.path.join(RDConfig.RDCodeDir,'Chem','SimpleEnum','test_data','bad_value3.rxn')
>>> rxn = AllChem.ReactionFromRxnFile(testFile)
>>> rxn.Initialize()
>>> nWarn,nError,nReacts,nProds,reactantLabels = PreprocessReaction(rxn)
Traceback (most recent call last):
  ...
KeyError: 'carboxyliccaid,acidchloride'
>>> rxn = rdChemReactions.ChemicalReaction()
>>> rxn.Initialize()
>>> nWarn,nError,nReacts,nProds,reactantLabels = PreprocessReaction(rxn)
>>> reactantLabels
()
>>> reactantLabels == ()
True



C++ signature :boost::python::api::object PreprocessReaction(RDKit::ChemicalReaction {lvalue} [,boost::python::dict={} [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’molFileValue’]])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionFromMolecule((Mol)mol) → ChemicalReaction :¶
construct a ChemicalReaction from an molecule if the RXN role property of the molecule is set

C++ signature :RDKit::ChemicalReaction* ReactionFromMolecule(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionFromMrvBlock((AtomPairsParameters)rxnblock[, (bool)sanitize=False[, (bool)removeHs=False]]) → ChemicalReaction :¶
construct a ChemicalReaction from a string in Marvin (mrv) format


C++ signature :RDKit::ChemicalReaction* ReactionFromMrvBlock(boost::python::api::object [,bool=False [,bool=False]])




ReactionFromMrvBlock( (AtomPairsParameters)rxnblock [, (bool)sanitize=False [, (bool)removeHs=False]]) -> ChemicalReaction :construct a ChemicalReaction from a string in Marvin (mrv) format

C++ signature :RDKit::ChemicalReaction* ReactionFromMrvBlock(boost::python::api::object [,bool=False [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionFromMrvFile((str)filename[, (bool)sanitize=False[, (bool)removeHs=False]]) → ChemicalReaction :¶
construct a ChemicalReaction from an Marvin (mrv) rxn file

C++ signature :RDKit::ChemicalReaction* ReactionFromMrvFile(char const* [,bool=False [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionFromPNGFile((str)fname) → ChemicalReaction :¶
construct a ChemicalReaction from metadata in a PNG file

C++ signature :RDKit::ChemicalReaction* ReactionFromPNGFile(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionFromPNGString((str)data) → ChemicalReaction :¶
construct a ChemicalReaction from an string with PNG data

C++ signature :RDKit::ChemicalReaction* ReactionFromPNGString(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionFromRxnBlock((str)rxnblock[, (bool)sanitize=False[, (bool)removeHs=False[, (bool)strictParsing=True]]]) → ChemicalReaction :¶
construct a ChemicalReaction from a string in MDL rxn format

C++ signature :RDKit::ChemicalReaction* ReactionFromRxnBlock(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=False [,bool=False [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionFromRxnFile((str)filename[, (bool)sanitize=False[, (bool)removeHs=False[, (bool)strictParsing=True]]]) → ChemicalReaction :¶
construct a ChemicalReaction from an MDL rxn file

C++ signature :RDKit::ChemicalReaction* ReactionFromRxnFile(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=False [,bool=False [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionFromSmarts((str)SMARTS[, (dict)replacements={}[, (bool)useSmiles=False]]) → ChemicalReaction :¶
construct a ChemicalReaction from a reaction SMARTS string. 
see the documentation for rdkit.Chem.MolFromSmiles for an explanation
of the replacements argument.

C++ signature :RDKit::ChemicalReaction* ReactionFromSmarts(char const* [,boost::python::dict={} [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionMetadataToPNGFile((ChemicalReaction)mol, (AtomPairsParameters)filename[, (bool)includePkl=True[, (bool)includeSmiles=True[, (bool)includeSmarts=False[, (bool)includeMol=False]]]]) → object :¶
Reads the contents of a PNG file and adds metadata about a reaction to it. The modified file contents are returned.

C++ signature :boost::python::api::object ReactionMetadataToPNGFile(RDKit::ChemicalReaction,boost::python::api::object [,bool=True [,bool=True [,bool=False [,bool=False]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionMetadataToPNGString((ChemicalReaction)mol, (AtomPairsParameters)pngdata[, (bool)includePkl=True[, (bool)includeSmiles=True[, (bool)includeSmarts=False[, (bool)includeRxn=False]]]]) → object :¶
Adds metadata about a reaction to the PNG string passed in.The modified string is returned.

C++ signature :boost::python::api::object ReactionMetadataToPNGString(RDKit::ChemicalReaction,boost::python::api::object [,bool=True [,bool=True [,bool=False [,bool=False]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionToMolecule((ChemicalReaction)reaction) → Mol :¶
construct a molecule for a ChemicalReaction with RXN role property set

C++ signature :RDKit::ROMol* ReactionToMolecule(RDKit::ChemicalReaction)
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionToMrvBlock((ChemicalReaction)reaction[, (bool)prettyPrint=False]) → str :¶
construct a string in Marvin (MRV) rxn format for a ChemicalReaction

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > ReactionToMrvBlock(RDKit::ChemicalReaction [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionToMrvFile((ChemicalReaction)reaction, (str)filename[, (bool)prettyPrint=False]) → None :¶
write a Marvin (MRV) rxn file for a ChemicalReaction

C++ signature :void ReactionToMrvFile(RDKit::ChemicalReaction,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionToRxnBlock((ChemicalReaction)reaction[, (bool)separateAgents=False[, (bool)forceV3000=False]]) → str :¶
construct a string in MDL rxn format for a ChemicalReaction

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > ReactionToRxnBlock(RDKit::ChemicalReaction [,bool=False [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionToSmarts((ChemicalReaction)reaction) → str :¶
construct a reaction SMARTS string for a ChemicalReaction


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > ReactionToSmarts(RDKit::ChemicalReaction)




ReactionToSmarts( (ChemicalReaction)reaction, (SmilesWriteParams)params) -> str :construct a reaction SMARTS string for a ChemicalReaction

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > ReactionToSmarts(RDKit::ChemicalReaction,RDKit::SmilesWriteParams)
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionToSmiles((ChemicalReaction)reaction[, (bool)canonical=True]) → str :¶
construct a reaction SMILES string for a ChemicalReaction


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > ReactionToSmiles(RDKit::ChemicalReaction [,bool=True])




ReactionToSmiles( (ChemicalReaction)reaction, (SmilesWriteParams)params) -> str :construct a reaction SMILES string for a ChemicalReaction

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > ReactionToSmiles(RDKit::ChemicalReaction,RDKit::SmilesWriteParams)
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionToV3KRxnBlock((ChemicalReaction)reaction[, (bool)separateAgents=False]) → str :¶
construct a string in MDL v3000 rxn format for a ChemicalReaction

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > ReactionToV3KRxnBlock(RDKit::ChemicalReaction [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionsFromCDXMLBlock((AtomPairsParameters)rxnblock[, (bool)sanitize=False[, (bool)removeHs=False]]) → object :¶
construct a tuple of ChemicalReactions from a string in CDXML format

C++ signature :boost::python::api::object ReactionsFromCDXMLBlock(boost::python::api::object [,bool=False [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReactionsFromCDXMLFile((str)filename[, (bool)sanitize=False[, (bool)removeHs=False]]) → object :¶
construct a tuple of ChemicalReactions from a CDXML rxn file

C++ signature :boost::python::api::object ReactionsFromCDXMLFile(char const* [,bool=False [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.ReduceProductToSideChains((Mol)product[, (bool)addDummyAtoms=True]) → Mol :¶
reduce the product of a reaction to the side chains added by the reaction.              The output is a molecule with attached wildcards indicating where the product was attached.              The dummy atom has the same reaction-map number as the product atom (if available).

C++ signature :RDKit::ROMol* ReduceProductToSideChains(boost::shared_ptr<RDKit::ROMol> [,bool=True])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.RemoveMappingNumbersFromReactions((ChemicalReaction)reaction) → None :¶
Removes the mapping numbers from the molecules of a reaction

C++ signature :void RemoveMappingNumbersFromReactions(RDKit::ChemicalReaction)
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.SanitizeRxn((ChemicalReaction)rxn[, (int)sanitizeOps=4294967295[, (AdjustQueryParameters)params=<rdkit.Chem.rdmolops.AdjustQueryParameters object at 0x76141bd78900>[, (bool)catchErrors=False]]]) → SanitizeFlags :¶
Does some sanitization of the reactant and product templates of a reaction.



The reaction is modified in place.
If sanitization fails, an exception will be thrown unless catchErrors is set


ARGUMENTS:


rxn: the reaction to be modified
sanitizeOps: (optional) reaction sanitization operations to be carried out
these should be constructed by or’ing together the
operations in rdkit.Chem.rdChemReactions.SanitizeFlags
optional adjustment parameters for changing the meaning of the substructure
matching done in the templates.  The default is 
rdkit.Chem.rdChemReactions.DefaultRxnAdjustParams which aromatizes
kekule structures if possible.
catchErrors: (optional) if provided, instead of raising an exception
when sanitization fails (the default behavior), the 
first operation that failed (as defined in rdkit.Chem.rdChemReactions.SanitizeFlags)
is returned. Zero is returned on success.



The operations carried out by default are:
fixRGroups(): sets R group labels on mapped dummy atoms when possible
fixAtomMaps(): attempts to set atom maps on unmapped R groups
adjustTemplate(): calls adjustQueryProperties() on all reactant templates
fixHs(): merges explicit Hs in the reactant templates that don’t map to heavy atoms





C++ signature :RDKit::RxnOps::SanitizeRxnFlags SanitizeRxn(RDKit::ChemicalReaction {lvalue} [,unsigned long=4294967295 [,RDKit::MolOps::AdjustQueryParameters=<rdkit.Chem.rdmolops.AdjustQueryParameters object at 0x76141bd78900> [,bool=False]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.SanitizeRxnAsMols((ChemicalReaction)rxn[, (int)sanitizeOps=268435455]) → None :¶
Does the usual molecular sanitization on each reactant, agent, and product of the reaction

C++ signature :void SanitizeRxnAsMols(RDKit::ChemicalReaction {lvalue} [,unsigned int=268435455])
--------------------------------------------------------------------------------
rdkit.Chem.rdChemReactions.UpdateProductsStereochemistry((ChemicalReaction)reaction) → None :¶
Caution: This is an expert-user function which will change a property (molInversionFlag) of your products.          This function is called by default using the RXN or SMARTS parser for reactions and should really only be called if reactions have been constructed some other way.          The function updates the stereochemistry of the product by considering 4 different cases: inversion, retention, removal, and introduction

C++ signature :void UpdateProductsStereochemistry(RDKit::ChemicalReaction*)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdCIPLabeler.AssignCIPLabels((Mol)mol[, (AtomPairsParameters)atomsToLabel=None[, (AtomPairsParameters)bondsToLabel=None[, (int)maxRecursiveIterations=0]]]) → None :¶
New implementation of Stereo assignment using a true CIP ranking.
On return:  The molecule to contains CIP flags
Errors:  when maxRecursiveIterations is exceeded, throws a MaxIterationsExceeded error
ARGUMENTS:


mol: the molecule
atomsToLabel: (optional) list of atoms to label
bondsToLabel: (optional) list of bonds to label
maxRecursiveIterations: (optional) protects against pseudo-infinite



recursion for highly symmetrical structures.A value of 1,250,000 take about 1 second.  Most structures requires less than 10,000iterations.
A peptide with MW~3000 took about 100 iterations, and a 20,000 mw protein took about 600 iterations


(0 = default - no limit)

C++ signature :void AssignCIPLabels(RDKit::ROMol {lvalue} [,boost::python::api::object=None [,boost::python::api::object=None [,unsigned int=0]]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdCoordGen.AddCoords((Mol)mol[, (AtomPairsParameters)params=None]) → None :¶
Add 2D coordinates.
ARGUMENTS:


mol: molecule to modify
params: (optional) parameters controlling the coordinate generation



C++ signature :void AddCoords(RDKit::ROMol {lvalue} [,boost::python::api::object {lvalue}=None])
--------------------------------------------------------------------------------
rdkit.Chem.rdCoordGen.SetDefaultTemplateFileDir((str)dir) → None :¶

C++ signature :void SetDefaultTemplateFileDir(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdDepictor.AddRingSystemTemplates((str)templatePath) → None :¶
Adds the ring system templates from the specified file to be used in 2D coordinate generation. If there are duplicates, the most recently added template will be used. Each template must be a single line in the file represented using CXSMILES, and the structure should be a single ring system. Throws a DepictException if any templates are invalid.

C++ signature :void AddRingSystemTemplates(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdDepictor.Compute2DCoords((Mol)mol[, (bool)canonOrient=True[, (bool)clearConfs=True[, (dict)coordMap={}[, (int)nFlipsPerSample=0[, (int)nSample=0[, (int)sampleSeed=0[, (bool)permuteDeg4Nodes=False[, (float)bondLength=-1.0[, (bool)forceRDKit=False[, (bool)useRingTemplates=False]]]]]]]]]]) → int :¶

Compute 2D coordinates for a molecule. The resulting coordinates are stored on each atom of the molecule
ARGUMENTS:

mol - the molecule of interest
canonOrient - orient the molecule in a canonical way
clearConfs - if true, all existing conformations on the molecule

will be cleared


coordMap - a dictionary mapping atom Ids -> Point2D objects with starting coordinates for atoms that should
have their positions locked.

nFlipsPerSample - number of rotatable bonds that areflipped at random at a time.


nSample - Number of random samplings of rotatable bonds.
sampleSeed - seed for the random sampling process.
permuteDeg4Nodes - allow permutation of bonds at a degree 4

node during the sampling process

bondLength - change the default bond length for depiction 
forceRDKit - use RDKit to generate coordinates even if

preferCoordGen is set to true


useRingTemplates - use templates to generate coordinates of complexring systems



RETURNS:

ID of the conformation added to the molecule


C++ signature :unsigned int Compute2DCoords(RDKit::ROMol {lvalue} [,bool=True [,bool=True [,boost::python::dict {lvalue}={} [,unsigned int=0 [,unsigned int=0 [,int=0 [,bool=False [,double=-1.0 [,bool=False [,bool=False]]]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdDepictor.Compute2DCoordsMimicDistmat((Mol)mol, (AtomPairsParameters)distMat[, (bool)canonOrient=False[, (bool)clearConfs=True[, (float)weightDistMat=0.5[, (int)nFlipsPerSample=3[, (int)nSample=100[, (int)sampleSeed=100[, (bool)permuteDeg4Nodes=True[, (float)bondLength=-1.0[, (bool)forceRDKit=False]]]]]]]]]) → int :¶

Compute 2D coordinates for a molecule such that the inter-atom distances mimic those in a user-provided
distance matrix. 
The resulting coordinates are stored on each atom of the molecule
ARGUMENTS:

mol - the molecule of interest
distMat - distance matrix that we want the 2D structure to mimic
canonOrient - orient the molecule in a canonical way
clearConfs - if true, all existing conformations on the molecule

will be cleared


weightDistMat - weight assigned in the cost function to mimickingthe distance matrix.
This must be between (0.0,1.0). (1.0-weightDistMat)
is then the weight assigned to improving 
the density of the 2D structure i.e. try to
make it spread out

nFlipsPerSample - number of rotatable bonds that areflipped at random at a time.


nSample - Number of random samplings of rotatable bonds.
sampleSeed - seed for the random sampling process.
permuteDeg4Nodes - allow permutation of bonds at a degree 4

node during the sampling process

bondLength - change the default bond length for depiction 
forceRDKit - use RDKit to generate coordinates even if

preferCoordGen is set to true


RETURNS:

ID of the conformation added to the molecule


C++ signature :unsigned int Compute2DCoordsMimicDistmat(RDKit::ROMol {lvalue},boost::python::api::object [,bool=False [,bool=True [,double=0.5 [,unsigned int=3 [,unsigned int=100 [,int=100 [,bool=True [,double=-1.0 [,bool=False]]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdDepictor.GenerateDepictionMatching2DStructure((Mol)mol, (Mol)reference[, (int)confId=-1[, (AtomPairsParameters)refPatt=None[, (AtomPairsParameters)params=None]]]) → tuple :¶

Generate a depiction for a molecule where a piece of the 
molecule is constrained to have the same coordinates as a reference.
The constraint can be hard (default) or soft.
Hard (default, ConstrainedDepictionParams.alignOnly=False): 
Existing molecule coordinates, if present, are discarded; 
new coordinates are generated constraining a piece of the molecule 
to have the same coordinates as the reference, while the rest of 
the molecule is built around it. 
If ConstrainedDepictionParams.adjustMolBlockWedging is False 
(default), existing molblock wedging information is always preserved. 
If ConstrainedDepictionParams.adjustMolBlockWedging is True, 
existing molblock wedging information is preserved in case it 
only involves the invariant core and the core conformation has not 
changed, while it is cleared in case the wedging is also outside 
the invariant core, or core coordinates were changed. 
If ConstrainedDepictionParams.acceptFailure is set to True and no 
substructure match is found, coordinates will be recomputed from 
scratch, hence molblock wedging information will be cleared.
Soft (ConstrainedDepictionParams.alignOnly=True): 
Existing coordinates in the conformation identified by 
ConstrainedDepictionParams.existingConfId are preserved if present, 
otherwise unconstrained new coordinates are generated. 
Subsequently, coodinates undergo a rigid-body alignment to the reference. 
If ConstrainedDepictionParams.adjustMolBlockWedging is False 
(default), existing molblock wedging information is always preserved. 
If ConstrainedDepictionParams.adjustMolBlockWedging is True, 
existing molblock wedging information is inverted in case the rigid-body 
alignment involved a flip around the Z axis.
This is useful, for example, for generating depictions of SAR data 
sets such that the cores of the molecules are all oriented the same way. 
ARGUMENTS:

mol -    the molecule to be aligned, this will come back with a single conformer.

reference -    a molecule with the reference atoms to align to; this should have a depiction.


confId -       (optional) the id of the reference conformation to use 
refPatt -      (optional) a query molecule to be used to generate

the atom mapping between the molecule and the reference

params - (optional) a ConstrainedDepictionParams instance

RETURNS: a tuple of (refIdx, molIdx) tuples corresponding to the atom indices in mol constrained to have the same coordinates as atom 
indices in reference.




C++ signature :boost::python::tuple GenerateDepictionMatching2DStructure(RDKit::ROMol {lvalue},RDKit::ROMol [,int=-1 [,boost::python::api::object=None [,boost::python::api::object=None]]])



GenerateDepictionMatching2DStructure( (Mol)mol, (Mol)reference [, (int)confId=-1 [, (AtomPairsParameters)refPatt=None [, (bool)acceptFailure=False [, (bool)forceRDKit=False [, (bool)allowRGroups=False]]]]]) -> tuple :
Generate a depiction for a molecule where a piece of the molecule is constrained to have the same coordinates as a reference.
This is useful, for example, for generating depictions of SAR data 
sets such that the cores of the molecules are all oriented the same way. 
ARGUMENTS:

mol -    the molecule to be aligned, this will come back with a single conformer.

reference -    a molecule with the reference atoms to align to; this should have a depiction.


confId -       the id of the reference conformation to use 
refPatt -      a query molecule to be used to generate

the atom mapping between the molecule and the reference


acceptFailure - if True, standard depictions will be generated for molecules that don’t have a substructure match to the 
reference; if False, throws a DepictException.

forceRDKit -    (optional) use RDKit to generate coordinates even if preferCoordGen is set to true

allowRGroups -  (optional) if True, terminal dummy atoms in the reference are ignored if they match an implicit 
hydrogen in the molecule, and a constrained 
depiction is still attempted

RETURNS: a tuple of (refIdx, molIdx) tuples corresponding to the atom indices in mol constrained to have the same coordinates as atom 
indices in reference.



C++ signature :boost::python::tuple GenerateDepictionMatching2DStructure(RDKit::ROMol {lvalue},RDKit::ROMol [,int=-1 [,boost::python::api::object=None [,bool=False [,bool=False [,bool=False]]]]])



GenerateDepictionMatching2DStructure( (Mol)mol, (Mol)reference, (AtomPairsParameters)atomMap [, (int)confId=-1 [, (AtomPairsParameters)params=None]]) -> None :
Generate a depiction for a molecule where a piece of the molecule is constrained to have the same coordinates as a reference.
This is useful for, for example, generating depictions of SAR data 
sets so that the cores of the molecules are all oriented the same way. 
ARGUMENTS:

mol -    the molecule to be aligned, this will come back with a single conformer.

reference -    a molecule with the reference atoms to align to; this should have a depiction.

atomMap -      a sequence of (queryAtomIdx, molAtomIdx) pairs that will be used to generate the atom mapping between the molecule 
and the reference. Note that this sequence can be shorter 
than the number of atoms in the reference.


confId -       (optional) the id of the reference conformation to use 
params -       (optional) an instance of ConstrainedDepictionParams

C++ signature :void GenerateDepictionMatching2DStructure(RDKit::ROMol {lvalue},RDKit::ROMol,boost::python::api::object [,int=-1 [,boost::python::api::object=None]])



GenerateDepictionMatching2DStructure( (Mol)mol, (Mol)reference, (AtomPairsParameters)atomMap, (int)confId, (bool)forceRDKit) -> None :
Generate a depiction for a molecule where a piece of the molecule is constrained to have the same coordinates as a reference.
This is useful for, for example, generating depictions of SAR data 
sets so that the cores of the molecules are all oriented the same way. 
ARGUMENTS:

mol -    the molecule to be aligned, this will come back with a single conformer.

reference -    a molecule with the reference atoms to align to; this should have a depiction.

atomMap -      a sequence of (queryAtomIdx, molAtomIdx) pairs that will be used to generate the atom mapping between the molecule 
and the reference. Note that this sequence can be shorter 
than the number of atoms in the reference.


confId -       the id of the reference conformation to use 
forceRDKit -   use RDKit to generate coordinates even if

preferCoordGen is set to true


C++ signature :void GenerateDepictionMatching2DStructure(RDKit::ROMol {lvalue},RDKit::ROMol,boost::python::api::object,int,bool)
--------------------------------------------------------------------------------
rdkit.Chem.rdDepictor.GenerateDepictionMatching3DStructure((Mol)mol, (Mol)reference[, (int)confId=-1[, (AtomPairsParameters)refPatt=None[, (bool)acceptFailure=False[, (bool)forceRDKit=False]]]]) → None :¶

Generate a depiction for a molecule where a piece of the molecule is constrained to have coordinates similar to those of a 3D reference 
structure.
ARGUMENTS:

mol -    the molecule to be aligned, this will come back with a single conformer containing the 2D coordinates.

reference -    a molecule with the reference atoms to align to. By default this should be the same as mol, but with 
3D coordinates


confId -       (optional) the id of the reference conformation to use 
referencePattern -  (optional) a query molecule to map a subset of

the reference onto the mol, so that only some of the 
atoms are aligned.


acceptFailure - (optional) if True, standard depictions will be generated for molecules that don’t match the reference or the
referencePattern; if False, throws a DepictException.

forceRDKit -    (optional) use RDKit to generate coordinates even if preferCoordGen is set to true



C++ signature :void GenerateDepictionMatching3DStructure(RDKit::ROMol {lvalue},RDKit::ROMol {lvalue} [,int=-1 [,boost::python::api::object=None [,bool=False [,bool=False]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdDepictor.GetPreferCoordGen() → bool :¶
Return whether or not the CoordGen library is used for coordinate generation in the RDKit depiction library.

C++ signature :bool GetPreferCoordGen()
--------------------------------------------------------------------------------
rdkit.Chem.rdDepictor.IsCoordGenSupportAvailable() → bool :¶
Returns whether RDKit was built with CoordGen support.

C++ signature :bool IsCoordGenSupportAvailable()
--------------------------------------------------------------------------------
rdkit.Chem.rdDepictor.LoadDefaultRingSystemTemplates() → None :¶
Loads the default ring system templates and removes existing ones, if present.

C++ signature :void LoadDefaultRingSystemTemplates()
--------------------------------------------------------------------------------
rdkit.Chem.rdDepictor.NormalizeDepiction((Mol)mol[, (int)confId=-1[, (int)canonicalize=1[, (float)scaleFactor=-1.0]]]) → float :¶
Normalizes the 2D depiction.
If canonicalize is != 0, the depiction is subjected to a canonical
transformation such that its main axis is aligned along the X axis
(canonicalize >0, the default) or the Y axis (canonicalize <0).
If canonicalize is 0, no canonicalization takes place.
If scaleFactor is <0.0 (the default) the depiction is scaled such
that bond lengths conform to RDKit standards. The applied scaling
factor is returned.
ARGUMENTS:
mol          - the molecule to be normalized
confId       - (optional) the id of the reference conformation to use
canonicalize - (optional) if != 0, a canonical transformation is

applied: if >0 (the default), the main molecule axis is
aligned to the X axis, if <0 to the Y axis.
If 0, no canonical transformation is applied.


scaleFactor  - (optional) if >0.0, the scaling factor to apply. The default(-1.0) means that the depiction is automatically scaled
such that bond lengths are the standard RDKit ones.


RETURNS: the applied scaling factor.

C++ signature :double NormalizeDepiction(RDKit::ROMol {lvalue} [,int=-1 [,int=1 [,double=-1.0]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdDepictor.SetPreferCoordGen((bool)val) → None :¶
Sets whether or not the CoordGen library should be preferred to the RDKit depiction library.

C++ signature :void SetPreferCoordGen(bool)
--------------------------------------------------------------------------------
rdkit.Chem.rdDepictor.SetRingSystemTemplates((str)templatePath) → None :¶
Loads the ring system templates from the specified file to be used in 2D coordinate generation. Each template must be a single line in the file represented using CXSMILES, and the structure should be a single ring system. Throws a DepictException if any templates are invalid.

C++ signature :void SetRingSystemTemplates(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdDepictor.StraightenDepiction((Mol)mol[, (int)confId=-1[, (bool)minimizeRotation=False]]) → None :¶

Rotate the 2D depiction such that the majority of bonds have a30-degree angle with the X axis.
ARGUMENTS:
mol              - the molecule to be rotated.
confId           - (optional) the id of the reference conformation to use.
minimizeRotation - (optional) if False (the default), the molecule

is rotated such that the majority of bonds have an angle
with the X axis of 30 or 90 degrees. If True, the minimum
rotation is applied such that the majority of bonds have
an angle with the X axis of 0, 30, 60, or 90 degrees,
with the goal of altering the initial orientation as
little as possible .


C++ signature :void StraightenDepiction(RDKit::ROMol {lvalue} [,int=-1 [,bool=False]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdDeprotect.Deprotect((Mol)mol[, (AtomPairsParameters)deprotections=None]) → Mol :¶
Return the deprotected version of the molecule.

C++ signature :boost::shared_ptr<RDKit::ROMol> Deprotect(RDKit::ROMol [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.rdDeprotect.DeprotectInPlace((Mol)mol[, (AtomPairsParameters)deprotections=None]) → bool :¶
Deprotects the molecule in place.

C++ signature :bool DeprotectInPlace(RDKit::ROMol {lvalue} [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.rdDeprotect.GetDeprotections() → DeprotectDataVect :¶
Return the default list of deprotections

C++ signature :std::vector<RDKit::Deprotect::DeprotectData, std::allocator<RDKit::Deprotect::DeprotectData> > GetDeprotections()
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdDetermineBonds.DetermineBondOrders((Mol)mol[, (int)charge=0[, (bool)allowChargedFragments=True[, (bool)embedChiral=True[, (bool)useAtomMap=False]]]]) → None :¶
Assigns atomic connectivity to a molecule using atomic coordinates, 
disregarding pre-existing bonds

Args:mol : the molecule of interest; it must have a 3D conformer
charge : (optional) the charge of the molecule; it must be provided if

the Hueckel method is used and charge is non-zero


allowChargedFragments(optional) if this is true, formal chargeswill be placed on atoms according to their valency; otherwise, radical
electrons will be placed on the atoms

embedChiral(optional) if this is true,chirality information will be embedded into the molecule; the function calls
sanitizeMol() when this is true

useAtomMap(optional) if this is true, an atom map will be created for the molecule



C++ signature :void DetermineBondOrders(RDKit::ROMol {lvalue} [,int=0 [,bool=True [,bool=True [,bool=False]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdDetermineBonds.DetermineBonds((Mol)mol[, (bool)useHueckel=False[, (int)charge=0[, (float)covFactor=1.3[, (bool)allowChargedFragments=True[, (bool)embedChiral=True[, (bool)useAtomMap=False[, (bool)useVdw=False]]]]]]]) → None :¶
Assigns atomic connectivity to a molecule using atomic coordinates, 
disregarding pre-existing bonds

Args:mol : the molecule of interest; it must have a 3D conformer
useHueckel : (optional) if this is true, extended Hueckel theory

will be used to determine connectivity rather than the van der Waals 
or connect-the-dots methods


charge(optional) the charge of the molecule; it must be provided ifthe Hueckel method is used and charge is non-zero

covFactor(optional) the factor with which to multiply each covalentradius if the van der Waals method is used

allowChargedFragments(optional) if this is true, formal chargeswill be placed on atoms according to their valency; otherwise, radical
electrons will be placed on the atoms

embedChiral(optional) if this is true,chirality information will be embedded into the molecule; the function calls
sanitizeMol() when this is true

useAtomMap(optional) if this is true, an atom map will be created for the molecule

useVdw: (optional) if this is false, the connect-the-dots methodwill be used instead of the van der Waals method



C++ signature :void DetermineBonds(RDKit::ROMol {lvalue} [,bool=False [,int=0 [,double=1.3 [,bool=True [,bool=True [,bool=False [,bool=False]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdDetermineBonds.DetermineConnectivity((Mol)mol[, (bool)useHueckel=False[, (int)charge=0[, (float)covFactor=1.3[, (bool)useVdw=False]]]]) → None :¶
Assigns atomic connectivity to a molecule using atomic coordinates, 
disregarding pre-existing bonds

Args:mol : the molecule of interest; it must have a 3D conformer
useHueckel : (optional) if this is  c true, extended Hueckel theory

will be used to determine connectivity rather than the van der Waals 
or connect-the-dots methods


charge(optional) the charge of the molecule; it must be provided ifthe Hueckel method is used and charge is non-zero

covFactor(optional) the factor with which to multiply each covalentradius if the van der Waals method is used

useVdw: (optional) if this is false, the connect-the-dots methodwill be used instead of the van der Waals method



C++ signature :void DetermineConnectivity(RDKit::ROMol {lvalue} [,bool=False [,int=0 [,double=1.3 [,bool=False]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdDetermineBonds.hueckelEnabled() → bool :¶
whether or not the RDKit was compiled with YAeHMOP support

C++ signature :bool hueckelEnabled()
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdDistGeom.ETDG() → EmbedParameters :¶
Returns an EmbedParameters object for the ETDG method.

C++ signature :(anonymous namespace)::PyEmbedParameters* ETDG()
--------------------------------------------------------------------------------
rdkit.Chem.rdDistGeom.ETKDG() → EmbedParameters :¶
Returns an EmbedParameters object for the ETKDG method - version 1.

C++ signature :(anonymous namespace)::PyEmbedParameters* ETKDG()
--------------------------------------------------------------------------------
rdkit.Chem.rdDistGeom.ETKDGv2() → EmbedParameters :¶
Returns an EmbedParameters object for the ETKDG method - version 2.

C++ signature :(anonymous namespace)::PyEmbedParameters* ETKDGv2()
--------------------------------------------------------------------------------
rdkit.Chem.rdDistGeom.ETKDGv3() → EmbedParameters :¶
Returns an EmbedParameters object for the ETKDG method - version 3 (macrocycles).

C++ signature :(anonymous namespace)::PyEmbedParameters* ETKDGv3()
--------------------------------------------------------------------------------
rdkit.Chem.rdDistGeom.EmbedMolecule((Mol)mol[, (int)maxAttempts=0[, (int)randomSeed=-1[, (bool)clearConfs=True[, (bool)useRandomCoords=False[, (float)boxSizeMult=2.0[, (bool)randNegEig=True[, (int)numZeroFail=1[, (dict)coordMap={}[, (float)forceTol=0.001[, (bool)ignoreSmoothingFailures=False[, (bool)enforceChirality=True[, (bool)useExpTorsionAnglePrefs=True[, (bool)useBasicKnowledge=True[, (bool)printExpTorsionAngles=False[, (bool)useSmallRingTorsions=False[, (bool)useMacrocycleTorsions=True[, (int)ETversion=2[, (bool)useMacrocycle14config=True]]]]]]]]]]]]]]]]]]) → int :¶

Use distance geometry to obtain initial 
coordinates for a molecule
ARGUMENTS:


mol : the molecule of interest
maxAttempts : the maximum number of attempts to try embedding

randomSeedprovide a seed for the random number generator so that the same coordinates can be obtained 
for a molecule on multiple runs. If -1, the 
RNG will not be seeded.



clearConfs : clear all existing conformations on the molecule

useRandomCoordsStart the embedding from random coordinates instead ofusing eigenvalues of the distance matrix.




boxSizeMultDetermines the size of the box that is used forrandom coordinates. If this is a positive number, the 
side length will equal the largest element of the distance
matrix times boxSizeMult. If this is a negative number,
the side length will equal -boxSizeMult (i.e. independent
of the elements of the distance matrix).




randNegEigIf the embedding yields a negative eigenvalue, pick coordinates that correspond 
to this component at random



numZeroFail : fail embedding if we have at least this many zero eigenvalues

coordMapa dictionary mapping atom IDs->coordinates. Use this to require some atoms to have fixed coordinates in the resulting 
conformation.




forceToltolerance to be used during the force-field minimization with the distance geometry force field.




ignoreSmoothingFailurestry to embed the molecule even if triangle smoothingof the bounds matrix fails.



enforceChirality : enforce the correct chirality if chiral centers are present.
useExpTorsionAnglePrefs : impose experimental torsion angle preferences
useBasicKnowledge : impose basic knowledge such as flat rings
printExpTorsionAngles : print the output from the experimental torsion angles
useMacrocycleTorsions : use additional torsion profiles for macrocycles

ETversionversion of the standard torsion definitions to use. NOTE for bothETKDGv2 and ETKDGv3 this should be 2 since ETKDGv3 uses the ETKDGv2
definitions for standard torsions



useMacrocycle14config : use the 1-4 distance bounds from ETKDGv3


RETURNS:

ID of the new conformation added to the molecule



C++ signature :int EmbedMolecule(RDKit::ROMol {lvalue} [,unsigned int=0 [,int=-1 [,bool=True [,bool=False [,double=2.0 [,bool=True [,unsigned int=1 [,boost::python::dict {lvalue}={} [,double=0.001 [,bool=False [,bool=True [,bool=True [,bool=True [,bool=False [,bool=False [,bool=True [,unsigned int=2 [,bool=True]]]]]]]]]]]]]]]]]])



EmbedMolecule( (Mol)mol, (EmbedParameters)params) -> int :
Use distance geometry to obtain intial coordinates for a molecule
ARGUMENTS:


mol : the molecule of interest
params : an EmbedParameters object


RETURNS:

ID of the new conformation added to the molecule


C++ signature :int EmbedMolecule(RDKit::ROMol {lvalue},RDKit::DGeomHelpers::EmbedParameters {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdDistGeom.EmbedMultipleConfs((Mol)mol[, (int)numConfs=10[, (int)maxAttempts=0[, (int)randomSeed=-1[, (bool)clearConfs=True[, (bool)useRandomCoords=False[, (float)boxSizeMult=2.0[, (bool)randNegEig=True[, (int)numZeroFail=1[, (float)pruneRmsThresh=-1.0[, (dict)coordMap={}[, (float)forceTol=0.001[, (bool)ignoreSmoothingFailures=False[, (bool)enforceChirality=True[, (int)numThreads=1[, (bool)useExpTorsionAnglePrefs=True[, (bool)useBasicKnowledge=True[, (bool)printExpTorsionAngles=False[, (bool)useSmallRingTorsions=False[, (bool)useMacrocycleTorsions=True[, (int)ETversion=2[, (bool)useMacrocycle14config=True]]]]]]]]]]]]]]]]]]]]]) → _vecti :¶

Use distance geometry to obtain multiple sets of 
coordinates for a molecule
ARGUMENTS:


mol : the molecule of interest
numConfs : the number of conformers to generate
maxAttempts : the maximum number of attempts to try embedding

randomSeedprovide a seed for the random number generator so that the same coordinates can be obtained 
for a molecule on multiple runs. If -1, the 
RNG will not be seeded.



clearConfs : clear all existing conformations on the molecule

useRandomCoordsStart the embedding from random coordinates instead ofusing eigenvalues of the distance matrix.




boxSizeMult    Determines the size of the box that is used forrandom coordinates. If this is a positive number, the 
side length will equal the largest element of the distance
matrix times boxSizeMult. If this is a negative number,
the side length will equal -boxSizeMult (i.e. independent
of the elements of the distance matrix).




randNegEigIf the embedding yields a negative eigenvalue, pick coordinates that correspond 
to this component at random



numZeroFail : fail embedding if we have at least this many zero eigenvalues

pruneRmsThreshRetain only the conformations out of ‘numConfs’ after embedding that are at least 
this far apart from each other. 
RMSD is computed on the heavy atoms. 
Pruning is greedy; i.e. the first embedded conformation
is retained and from then on only those that are at
least pruneRmsThresh away from all retained conformations
are kept. The pruning is done after embedding and 
bounds violation minimization. No pruning by default.




coordMapa dictionary mapping atom IDs->coordinates. Use this to require some atoms to have fixed coordinates in the resulting 
conformation.




forceToltolerance to be used during the force-field minimization with the distance geometry force field.




ignoreSmoothingFailurestry to embed the molecule even if triangle smoothingof the bounds matrix fails.



enforceChirality : enforce the correct chirality if chiral centers are present.

numThreadsnumber of threads to use while embedding. This only has an effect if the RDKit
was built with multi-thread support.

If set to zero, the max supported by the system will be used.



useExpTorsionAnglePrefs : impose experimental torsion angle preferences
useBasicKnowledge : impose basic knowledge such as flat rings
printExpTorsionAngles : print the output from the experimental torsion angles


RETURNS:

List of new conformation IDs



C++ signature :std::vector<int, std::allocator<int> > EmbedMultipleConfs(RDKit::ROMol {lvalue} [,unsigned int=10 [,unsigned int=0 [,int=-1 [,bool=True [,bool=False [,double=2.0 [,bool=True [,unsigned int=1 [,double=-1.0 [,boost::python::dict {lvalue}={} [,double=0.001 [,bool=False [,bool=True [,int=1 [,bool=True [,bool=True [,bool=False [,bool=False [,bool=True [,unsigned int=2 [,bool=True]]]]]]]]]]]]]]]]]]]]])



EmbedMultipleConfs( (Mol)mol, (int)numConfs, (EmbedParameters)params) -> _vecti :
Use distance geometry to obtain multiple sets of coordinates for a molecule
ARGUMENTS:


mol : the molecule of interest
numConfs : the number of conformers to generate
params : an EmbedParameters object


RETURNS:

List of new conformation IDs


C++ signature :std::vector<int, std::allocator<int> > EmbedMultipleConfs(RDKit::ROMol {lvalue},unsigned int,RDKit::DGeomHelpers::EmbedParameters {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdDistGeom.GetExperimentalTorsions((Mol)mol[, (bool)useExpTorsionAnglePrefs=True[, (bool)useSmallRingTorsions=False[, (bool)useMacrocycleTorsions=True[, (bool)useBasicKnowledge=True[, (int)ETversion=2[, (bool)printExpTorsionAngles=False]]]]]]) → tuple :¶
returns information about the bonds corresponding to experimental torsions


C++ signature :boost::python::tuple GetExperimentalTorsions(RDKit::ROMol [,bool=True [,bool=False [,bool=True [,bool=True [,unsigned int=2 [,bool=False]]]]]])




GetExperimentalTorsions( (Mol)mol, (EmbedParameters)embedParams) -> tuple :returns information about the bonds corresponding to experimental torsions

C++ signature :boost::python::tuple GetExperimentalTorsions(RDKit::ROMol,RDKit::DGeomHelpers::EmbedParameters)
--------------------------------------------------------------------------------
rdkit.Chem.rdDistGeom.GetMoleculeBoundsMatrix((Mol)mol[, (bool)set15bounds=True[, (bool)scaleVDW=False[, (bool)doTriangleSmoothing=True[, (bool)useMacrocycle14config=False]]]]) → object :¶
Returns the distance bounds matrix for a molecule

ARGUMENTS:


mol : the molecule of interest

set15boundsset bounds for 1-5 atom distances based on topology (otherwise stop at 1-4s)




scaleVDWscale down the sum of VDW radii when setting the lower bounds for atoms less than 5 bonds apart




doTriangleSmoothingrun triangle smoothing on the bounds matrix before returning it





RETURNS:

the bounds matrix as a Numeric array with lower bounds in 
the lower triangle and upper bounds in the upper triangle



C++ signature :_object* GetMoleculeBoundsMatrix(RDKit::ROMol {lvalue} [,bool=True [,bool=False [,bool=True [,bool=False]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdDistGeom.KDG() → EmbedParameters :¶
Returns an EmbedParameters object for the KDG method.

C++ signature :(anonymous namespace)::PyEmbedParameters* KDG()
--------------------------------------------------------------------------------
rdkit.Chem.rdDistGeom.srETKDGv3() → EmbedParameters :¶
Returns an EmbedParameters object for the ETKDG method - version 3 (small rings).

C++ signature :(anonymous namespace)::PyEmbedParameters* srETKDGv3()
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdEHTTools.RunMol((Mol)mol[, (int)confId=-1[, (bool)keepOverlapAndHamiltonianMatrices=False]]) → tuple :¶
Runs an extended Hueckel calculation for a molecule.
The molecule should have at least one conformation

ARGUMENTS:
mol: molecule to use
confId: (optional) conformation to use
keepOverlapAndHamiltonianMatrices: (optional) triggers storing the overlap 
and hamiltonian matrices in the EHTResults object


RETURNS: a 2-tuple:
a boolean indicating whether or not the calculation succeeded
an EHTResults object with the results


C++ signature :boost::python::tuple RunMol(RDKit::ROMol [,int=-1 [,bool=False]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdfiltercatalog.FilterCatalogCanSerialize() → bool :¶
Returns True if the FilterCatalog is serializable (requires boost serialization

C++ signature :bool FilterCatalogCanSerialize()
--------------------------------------------------------------------------------
rdkit.Chem.rdfiltercatalog.GetFlattenedFunctionalGroupHierarchy([(bool)normalized=False]) → dict :¶
Returns the flattened functional group hierarchy as a dictionary  of name:ROMOL_SPTR substructure items

C++ signature :boost::python::dict GetFlattenedFunctionalGroupHierarchy([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdfiltercatalog.GetFunctionalGroupHierarchy() → FilterCatalog :¶
Returns the functional group hierarchy filter catalog

C++ signature :RDKit::FilterCatalog GetFunctionalGroupHierarchy()
--------------------------------------------------------------------------------
rdkit.Chem.rdfiltercatalog.RunFilterCatalog((FilterCatalog)filterCatalog, (_vectNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE)smiles[, (int)numThreads=1]) → FilterCatalogListOfEntryList :¶
Run the filter catalog on the input list of smiles strings.
Use numThreads=0 to use all available processors. Returns a vector of vectors.  For each input smiles, a vector of FilterCatalogEntry objects are returned for each matched filter.  If a molecule matches no filter, the vector will be empty. If a smiles string can’t be parsed, a ‘Bad smiles’ entry is returned.

C++ signature :std::vector<std::vector<boost::shared_ptr<RDKit::FilterCatalogEntry const>, std::allocator<boost::shared_ptr<RDKit::FilterCatalogEntry const> > >, std::allocator<std::vector<boost::shared_ptr<RDKit::FilterCatalogEntry const>, std::allocator<boost::shared_ptr<RDKit::FilterCatalogEntry const> > > > > RunFilterCatalog(RDKit::FilterCatalog,std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > [,int=1])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdFingerprintGenerator.GetAtomPairAtomInvGen([(bool)includeChirality=False]) → AtomInvariantsGenerator :¶
Get an atom pair atom-invariant generator


ARGUMENTS:
includeChirality: if set, chirality will be taken into account for invariants



RETURNS: AtomInvariantsGenerator


C++ signature :RDKit::AtomInvariantsGenerator* GetAtomPairAtomInvGen([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdFingerprintGenerator.GetAtomPairGenerator([(int)minDistance=1[, (int)maxDistance=30[, (bool)includeChirality=False[, (bool)use2D=True[, (bool)countSimulation=True[, (AtomPairsParameters)countBounds=None[, (int)fpSize=2048[, (AtomPairsParameters)atomInvariantsGenerator=None]]]]]]]]) → FingeprintGenerator64 :¶
Get an atom pair fingerprint generator


ARGUMENTS:
minDistance: minimum distance between atoms to be considered in a pair, default is 1 bond
maxDistance: maximum distance between atoms to be considered in a pair, default is maxPathLen-1 bonds
includeChirality: if set, chirality will be used in the atom  invariants, this is ignored if atomInvariantsGenerator is provided
use2D: if set, the 2D (topological) distance matrix  will be used
countSimulation:  if set, use count simulation while  generating the fingerprint
countBounds: boundaries for count simulation, corresponding bit will be  set if the count is higher than the number provided for that spot
fpSize: size of the generated fingerprint, does not affect the sparse versions
atomInvariantsGenerator: atom invariants to be used during fingerprint generation





This generator supports the following AdditionalOutput types:

atomToBits: which bits each atom is involved in
atomCounts: how many bits each atom sets
bitInfoMap: map from bitId to (atomId, radius) pairs


RETURNS: FingerprintGenerator

C++ signature :RDKit::FingerprintGenerator<unsigned long>* GetAtomPairGenerator([ unsigned int=1 [,unsigned int=30 [,bool=False [,bool=True [,bool=True [,boost::python::api::object {lvalue}=None [,unsigned int=2048 [,boost::python::api::object {lvalue}=None]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdFingerprintGenerator.GetCountFPs([(list)molecules=[][, (FPType)fpType=rdkit.Chem.rdFingerprintGenerator.FPType.MorganFP]]) → list :¶

C++ signature :boost::python::list GetCountFPs([ boost::python::list {lvalue}=[] [,RDKit::FPType=rdkit.Chem.rdFingerprintGenerator.FPType.MorganFP]])
--------------------------------------------------------------------------------
rdkit.Chem.rdFingerprintGenerator.GetFPs([(list)molecules=[][, (FPType)fpType=rdkit.Chem.rdFingerprintGenerator.FPType.MorganFP]]) → list :¶

C++ signature :boost::python::list GetFPs([ boost::python::list {lvalue}=[] [,RDKit::FPType=rdkit.Chem.rdFingerprintGenerator.FPType.MorganFP]])
--------------------------------------------------------------------------------
rdkit.Chem.rdFingerprintGenerator.GetMorganAtomInvGen([(bool)includeRingMembership=False]) → AtomInvariantsGenerator :¶
Get a morgan atom invariants generator


ARGUMENTS:
includeRingMembership: if set, whether or not the atom is in a ring will be used in the invariant list



RETURNS: AtomInvariantsGenerator


C++ signature :RDKit::AtomInvariantsGenerator* GetMorganAtomInvGen([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdFingerprintGenerator.GetMorganBondInvGen([(bool)useBondTypes=True[, (bool)useChirality=False]]) → BondInvariantsGenerator :¶
Get a morgan bond invariants generator


ARGUMENTS:
useBondTypes: if set, bond types will be included as a part of the bond invariants
useChirality: if set, chirality information will be included as a part of the bond invariants



RETURNS: BondInvariantsGenerator


C++ signature :RDKit::BondInvariantsGenerator* GetMorganBondInvGen([ bool=True [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdFingerprintGenerator.GetMorganFeatureAtomInvGen([(AtomPairsParameters)patterns=None]) → AtomInvariantsGenerator :¶
Get a morgan feature atom invariants generator


ARGUMENTS:
patterns: if provided should contain the queries used to assign atom-types. if not provided, feature definitions adapted from reference: Gobbi and Poppinger, Biotech. Bioeng. _61_ 47-54 (1998) will be used for Donor, Acceptor, Aromatic, Halogen, Basic, Acidic.



RETURNS: AtomInvariantsGenerator


C++ signature :RDKit::AtomInvariantsGenerator* GetMorganFeatureAtomInvGen([ boost::python::api::object {lvalue}=None])
--------------------------------------------------------------------------------
rdkit.Chem.rdFingerprintGenerator.GetMorganGenerator([(int)radius=3[, (bool)countSimulation=False[, (bool)includeChirality=False[, (bool)useBondTypes=True[, (bool)onlyNonzeroInvariants=False[, (bool)includeRingMembership=True[, (AtomPairsParameters)countBounds=None[, (int)fpSize=2048[, (AtomPairsParameters)atomInvariantsGenerator=None[, (AtomPairsParameters)bondInvariantsGenerator=None[, (bool)includeRedundantEnvironments=False]]]]]]]]]]]) → FingeprintGenerator64 :¶
Get a morgan fingerprint generator


ARGUMENTS:
radius:  the number of iterations to grow the fingerprint
countSimulation: if set, use count simulation while generating the fingerprint
includeChirality: if set, chirality information will be added to the generated fingerprint
useBondTypes: if set, bond types will be included as a part of the default bond invariants
countBounds: boundaries for count simulation, corresponding bit will be  set if the count is higher than the number provided for that spot
fpSize: size of the generated fingerprint, does not affect the sparse versions
atomInvariantsGenerator: atom invariants to be used during fingerprint generation





This generator supports the following AdditionalOutput types:

atomToBits: which bits each atom is the center of
atomCounts: how many bits each atom sets
bitInfoMap: map from bitId to (atomId1, radius) pairs


RETURNS: FingerprintGenerator

C++ signature :RDKit::FingerprintGenerator<unsigned long>* GetMorganGenerator([ unsigned int=3 [,bool=False [,bool=False [,bool=True [,bool=False [,bool=True [,boost::python::api::object {lvalue}=None [,unsigned int=2048 [,boost::python::api::object {lvalue}=None [,boost::python::api::object {lvalue}=None [,bool=False]]]]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdFingerprintGenerator.GetRDKitAtomInvGen() → AtomInvariantsGenerator :¶
Get an RDKit atom invariants generator

RETURNS: AtomInvariantsGenerator


C++ signature :RDKit::AtomInvariantsGenerator* GetRDKitAtomInvGen()
--------------------------------------------------------------------------------
rdkit.Chem.rdFingerprintGenerator.GetRDKitFPGenerator([(int)minPath=1[, (int)maxPath=7[, (bool)useHs=True[, (bool)branchedPaths=True[, (bool)useBondOrder=True[, (bool)countSimulation=False[, (AtomPairsParameters)countBounds=None[, (int)fpSize=2048[, (int)numBitsPerFeature=2[, (AtomPairsParameters)atomInvariantsGenerator=None]]]]]]]]]]) → FingeprintGenerator64 :¶
Get an RDKit fingerprint generator


ARGUMENTS:
minPath: the minimum path length (in bonds) to be included
maxPath: the maximum path length (in bonds) to be included
useHs: toggles inclusion of Hs in paths (if the molecule has explicit Hs)
branchedPaths: toggles generation of branched subgraphs, not just linear paths
useBondOrder: toggles inclusion of bond orders in the path hashes
countSimulation:  if set, use count simulation while  generating the fingerprint
countBounds: boundaries for count simulation, corresponding bit will be  set if the count is higher than the number provided for that spot
fpSize: size of the generated fingerprint, does not affect the sparse versions
numBitsPerFeature: the number of bits set per path/subgraph found
atomInvariantsGenerator: atom invariants to be used during fingerprint generation





This generator supports the following AdditionalOutput types:

atomToBits: which bits each atom is involved in
atomCounts: how many bits each atom sets
bitPaths: map from bitId to vectors of bond indices for the individual subgraphs


RETURNS: FingerprintGenerator

C++ signature :RDKit::FingerprintGenerator<unsigned long>* GetRDKitFPGenerator([ unsigned int=1 [,unsigned int=7 [,bool=True [,bool=True [,bool=True [,bool=False [,boost::python::api::object {lvalue}=None [,unsigned int=2048 [,unsigned int=2 [,boost::python::api::object {lvalue}=None]]]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdFingerprintGenerator.GetSparseCountFPs([(list)molecules=[][, (FPType)fpType=rdkit.Chem.rdFingerprintGenerator.FPType.MorganFP]]) → list :¶

C++ signature :boost::python::list GetSparseCountFPs([ boost::python::list {lvalue}=[] [,RDKit::FPType=rdkit.Chem.rdFingerprintGenerator.FPType.MorganFP]])
--------------------------------------------------------------------------------
rdkit.Chem.rdFingerprintGenerator.GetSparseFPs([(list)molecules=[][, (FPType)fpType=rdkit.Chem.rdFingerprintGenerator.FPType.MorganFP]]) → list :¶

C++ signature :boost::python::list GetSparseFPs([ boost::python::list {lvalue}=[] [,RDKit::FPType=rdkit.Chem.rdFingerprintGenerator.FPType.MorganFP]])
--------------------------------------------------------------------------------
rdkit.Chem.rdFingerprintGenerator.GetTopologicalTorsionGenerator([(bool)includeChirality=False[, (int)torsionAtomCount=4[, (bool)countSimulation=True[, (AtomPairsParameters)countBounds=None[, (int)fpSize=2048[, (AtomPairsParameters)atomInvariantsGenerator=None]]]]]]) → FingeprintGenerator64 :¶
Get an atom pair fingerprint generator


ARGUMENTS:
includeChirality: includeChirality argument for both the default atom invariants generator and the fingerprint arguments
torsionAtomCount: the number of atoms to include in the “torsions”
countSimulation:  if set, use count simulation while  generating the fingerprint
countBounds: boundaries for count simulation, corresponding bit will be  set if the count is higher than the number provided for that spot
fpSize: size of the generated fingerprint, does not affect the sparse versions
atomInvariantsGenerator: atom invariants to be used during fingerprint generation





This generator supports the following AdditionalOutput types:

atomToBits: which bits each atom is involved in
atomCounts: how many bits each atom sets
bitPaths: map from bitId to vectors of atom indices


RETURNS: FingerprintGenerator

C++ signature :RDKit::FingerprintGenerator<unsigned long>* GetTopologicalTorsionGenerator([ bool=False [,unsigned int=4 [,bool=True [,boost::python::api::object {lvalue}=None [,unsigned int=2048 [,boost::python::api::object {lvalue}=None]]]]]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdFMCS.FindMCS((AtomPairsParameters)mols[, (bool)maximizeBonds=True[, (float)threshold=1.0[, (int)timeout=3600[, (bool)verbose=False[, (bool)matchValences=False[, (bool)ringMatchesRingOnly=False[, (bool)completeRingsOnly=False[, (bool)matchChiralTag=False[, (AtomCompare)atomCompare=rdkit.Chem.rdFMCS.AtomCompare.CompareElements[, (BondCompare)bondCompare=rdkit.Chem.rdFMCS.BondCompare.CompareOrder[, (RingCompare)ringCompare=rdkit.Chem.rdFMCS.RingCompare.IgnoreRingFusion[, (str)seedSmarts='']]]]]]]]]]]]) → MCSResult :¶
Find the MCS for a set of molecules


C++ signature :RDKit::MCSResult* FindMCS(boost::python::api::object [,bool=True [,double=1.0 [,unsigned int=3600 [,bool=False [,bool=False [,bool=False [,bool=False [,bool=False [,RDKit::AtomComparator=rdkit.Chem.rdFMCS.AtomCompare.CompareElements [,RDKit::BondComparator=rdkit.Chem.rdFMCS.BondCompare.CompareOrder [,RDKit::RingComparator=rdkit.Chem.rdFMCS.RingCompare.IgnoreRingFusion [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’]]]]]]]]]]]])




FindMCS( (AtomPairsParameters)mols, (MCSParameters)parameters) -> MCSResult :Find the MCS for a set of molecules

C++ signature :RDKit::MCSResult* FindMCS(boost::python::api::object,RDKit::PyMCSParameters {lvalue})
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.GetUFFAngleBendParams((Mol)mol, (int)idx1, (int)idx2, (int)idx3) → object :¶
Retrieves UFF angle bend parameters for atoms with indexes idx1, idx2, idx3 as a (ka, theta0) tuple, or None if no parameters could be found

C++ signature :_object* GetUFFAngleBendParams(RDKit::ROMol,unsigned int,unsigned int,unsigned int)
--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.GetUFFBondStretchParams((Mol)mol, (int)idx1, (int)idx2) → object :¶
Retrieves UFF bond stretch parameters for atoms with indexes idx1, idx2 as a (kb, r0) tuple, or None if no parameters could be found

C++ signature :_object* GetUFFBondStretchParams(RDKit::ROMol,unsigned int,unsigned int)
--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.GetUFFInversionParams((Mol)mol, (int)idx1, (int)idx2, (int)idx3, (int)idx4) → object :¶
Retrieves UFF inversion parameters for atoms with indexes idx1, idx2, idx3, idx4 as a K float value, or None if no parameters could be found

C++ signature :_object* GetUFFInversionParams(RDKit::ROMol,unsigned int,unsigned int,unsigned int,unsigned int)
--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.GetUFFTorsionParams((Mol)mol, (int)idx1, (int)idx2, (int)idx3, (int)idx4) → object :¶
Retrieves UFF torsion parameters for atoms with indexes idx1, idx2, idx3, idx4 as a V float value, or None if no parameters could be found

C++ signature :_object* GetUFFTorsionParams(RDKit::ROMol,unsigned int,unsigned int,unsigned int,unsigned int)
--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.GetUFFVdWParams((Mol)mol, (int)idx1, (int)idx2) → object :¶
Retrieves UFF van der Waals parameters for atoms with indexes idx1, idx2 as a (x_ij, D_ij) tuple, or None if no parameters could be found

C++ signature :_object* GetUFFVdWParams(RDKit::ROMol,unsigned int,unsigned int)
--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.MMFFGetMoleculeForceField((Mol)mol, (MMFFMolProperties)pyMMFFMolProperties[, (float)nonBondedThresh=100.0[, (int)confId=-1[, (bool)ignoreInterfragInteractions=True]]]) → ForceField :¶
returns a MMFF force field for a molecule

ARGUMENTS:


mol : the molecule of interest

pyMMFFMolPropertiesPyMMFFMolProperties object as returnedby MMFFGetMoleculeProperties()




nonBondedThreshused to exclude long-range non-bondedinteractions (defaults to 100.0)



confId : indicates which conformer to optimize

ignoreInterfragInteractionsif true, nonbonded terms betweenfragments will not be added to the forcefield







C++ signature :ForceFields::PyForceField* MMFFGetMoleculeForceField(RDKit::ROMol {lvalue},ForceFields::PyMMFFMolProperties* [,double=100.0 [,int=-1 [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.MMFFGetMoleculeProperties((Mol)mol[, (str)mmffVariant='MMFF94'[, (int)mmffVerbosity=0]]) → MMFFMolProperties :¶

returns a PyMMFFMolProperties object for amolecule, which is required by MMFFGetMoleculeForceField()
and can be used to get/set MMFF properties
ARGUMENTS:


mol : the molecule of interest

mmffVariant“MMFF94” or “MMFF94s”(defaults to “MMFF94”)



mmffVerbosity : 0: none; 1: low; 2: high (defaults to 0).



C++ signature :ForceFields::PyMMFFMolProperties* MMFFGetMoleculeProperties(RDKit::ROMol {lvalue} [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’MMFF94’ [,unsigned int=0]])
--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.MMFFHasAllMoleculeParams((Mol)mol) → bool :¶
checks if MMFF parameters are available for all of a molecule’s atoms

ARGUMENTS:


mol : the molecule of interest




C++ signature :bool MMFFHasAllMoleculeParams(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.MMFFOptimizeMolecule((Mol)mol[, (str)mmffVariant='MMFF94'[, (int)maxIters=200[, (float)nonBondedThresh=100.0[, (int)confId=-1[, (bool)ignoreInterfragInteractions=True]]]]]) → int :¶
uses MMFF to optimize a molecule’s structure

ARGUMENTS:


mol : the molecule of interest
mmffVariant : “MMFF94” or “MMFF94s”
maxIters : the maximum number of iterations (defaults to 200)

nonBondedThreshused to exclude long-range non-bondedinteractions (defaults to 100.0)



confId : indicates which conformer to optimize

ignoreInterfragInteractionsif true, nonbonded terms betweenfragments will not be added to the forcefield






RETURNS: 0 if the optimization converged, -1 if the forcefield couldnot be set up, 1 if more iterations are required.




C++ signature :int MMFFOptimizeMolecule(RDKit::ROMol {lvalue} [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’MMFF94’ [,int=200 [,double=100.0 [,int=-1 [,bool=True]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.MMFFOptimizeMoleculeConfs((Mol)self[, (int)numThreads=1[, (int)maxIters=200[, (str)mmffVariant='MMFF94'[, (float)nonBondedThresh=100.0[, (bool)ignoreInterfragInteractions=True]]]]]) → object :¶
uses MMFF to optimize all of a molecule’s conformations

ARGUMENTS:


mol : the molecule of interest

numThreadsthe number of threads to use, only has an effect if the RDKitwas built with thread support (defaults to 1)
If set to zero, the max supported by the system will be used.



maxIters : the maximum number of iterations (defaults to 200)
mmffVariant : “MMFF94” or “MMFF94s”

nonBondedThreshused to exclude long-range non-bondedinteractions (defaults to 100.0)




ignoreInterfragInteractionsif true, nonbonded terms betweenfragments will not be added to the forcefield.







RETURNS: a list of (not_converged, energy) 2-tuples. If not_converged is 0 the optimization converged for that conformer.

C++ signature :boost::python::api::object MMFFOptimizeMoleculeConfs(RDKit::ROMol {lvalue} [,int=1 [,int=200 [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’MMFF94’ [,double=100.0 [,bool=True]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.MMFFSanitizeMolecule((Mol)mol) → int :¶
sanitizes a molecule according to MMFF requirements.


mol : the molecule of interest.



C++ signature :unsigned int MMFFSanitizeMolecule(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.OptimizeMolecule((ForceField)ff[, (int)maxIters=200]) → int :¶
uses the supplied force field to optimize a molecule’s structure

ARGUMENTS:


ff : the force field
maxIters : the maximum number of iterations (defaults to 200)


RETURNS: 0 if the optimization converged, 1 if more iterations are required.


C++ signature :int OptimizeMolecule(ForceFields::PyForceField {lvalue} [,int=200])
--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.OptimizeMoleculeConfs((Mol)mol, (ForceField)ff[, (int)numThreads=1[, (int)maxIters=200]]) → object :¶
uses the supplied force field to optimize all of a molecule’s conformations

ARGUMENTS:


mol : the molecule of interest
ff : the force field

numThreadsthe number of threads to use, only has an effect if the RDKitwas built with thread support (defaults to 1)
If set to zero, the max supported by the system will be used.



maxIters : the maximum number of iterations (defaults to 200)



RETURNS: a list of (not_converged, energy) 2-tuples. If not_converged is 0 the optimization converged for that conformer.




C++ signature :boost::python::api::object OptimizeMoleculeConfs(RDKit::ROMol {lvalue},ForceFields::PyForceField {lvalue} [,int=1 [,int=200]])
--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.UFFGetMoleculeForceField((Mol)mol[, (float)vdwThresh=10.0[, (int)confId=-1[, (bool)ignoreInterfragInteractions=True]]]) → ForceField :¶
returns a UFF force field for a molecule

ARGUMENTS:


mol : the molecule of interest

vdwThreshused to exclude long-range van der Waals interactions(defaults to 10.0)



confId : indicates which conformer to optimize

ignoreInterfragInteractionsif true, nonbonded terms betweenfragments will not be added to the forcefield.







C++ signature :ForceFields::PyForceField* UFFGetMoleculeForceField(RDKit::ROMol {lvalue} [,double=10.0 [,int=-1 [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.UFFHasAllMoleculeParams((Mol)mol) → bool :¶
checks if UFF parameters are available for all of a molecule’s atoms

ARGUMENTS:


mol : the molecule of interest.




C++ signature :bool UFFHasAllMoleculeParams(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.UFFOptimizeMolecule((Mol)self[, (int)maxIters=200[, (float)vdwThresh=10.0[, (int)confId=-1[, (bool)ignoreInterfragInteractions=True]]]]) → int :¶
uses UFF to optimize a molecule’s structure

ARGUMENTS:


mol : the molecule of interest
maxIters : the maximum number of iterations (defaults to 200)

vdwThreshused to exclude long-range van der Waals interactions(defaults to 10.0)



confId : indicates which conformer to optimize

ignoreInterfragInteractionsif true, nonbonded terms betweenfragments will not be added to the forcefield.





RETURNS: 0 if the optimization converged, 1 if more iterations are required.


C++ signature :int UFFOptimizeMolecule(RDKit::ROMol {lvalue} [,int=200 [,double=10.0 [,int=-1 [,bool=True]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdForceFieldHelpers.UFFOptimizeMoleculeConfs((Mol)self[, (int)numThreads=1[, (int)maxIters=200[, (float)vdwThresh=10.0[, (bool)ignoreInterfragInteractions=True]]]]) → object :¶
uses UFF to optimize all of a molecule’s conformations

ARGUMENTS:


mol : the molecule of interest

numThreadsthe number of threads to use, only has an effect if the RDKitwas built with thread support (defaults to 1)
If set to zero, the max supported by the system will be used.



maxIters : the maximum number of iterations (defaults to 200)

vdwThreshused to exclude long-range van der Waals interactions(defaults to 10.0)




ignoreInterfragInteractionsif true, nonbonded terms betweenfragments will not be added to the forcefield.






RETURNS: a list of (not_converged, energy) 2-tuples. If not_converged is 0 the optimization converged for that conformer.




C++ signature :boost::python::api::object UFFOptimizeMoleculeConfs(RDKit::ROMol {lvalue} [,int=1 [,int=200 [,double=10.0 [,bool=True]]]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdFreeSASA.CalcSASA((Mol)mol, (AtomPairsParameters)radii[, (int)confIdx=-1[, (Atom)query=None[, (SASAOpts)opts=<rdkit.Chem.rdFreeSASA.SASAOpts object at 0x761411901620>]]]) → float :¶
Compute the Solvent Accessible Surface Area using the FreeSASA library
ARGUMENTS:


mol: The molecule to compute.

radii:  A list of atom raddii where radii[atom.GetIdx()] is the radius of the atomThese can be passed in or calculated with classifyAtoms for some proteins



confIdx: Specify the conformer to use for the 3D geometry  [default -1]

query: Pass along a query atom to compute the SASA for a subset of atoms.precanned query atoms can be made with MakeFreeSasaPolarAtomQuery and
MakeFreeSasaAPolarAtomQuery for classified polar and apolar atoms respectively.



opts: a SASAOpts class specifying the algorithm to use


RETURNS:
The computed solvent accessible surface area.

C++ signature :double CalcSASA(RDKit::ROMol,boost::python::api::object [,int=-1 [,RDKit::Atom const*=None [,FreeSASA::SASAOpts=<rdkit.Chem.rdFreeSASA.SASAOpts object at 0x761411901620>]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdFreeSASA.MakeFreeSasaAPolarAtomQuery() → QueryAtom :¶
Returns an APolar atom query for use with CalcSASA.  An apolar atom has the SASAClass
and SASAClassName set to the APOLAR class.  (see classifyAtoms)

C++ signature :RDKit::QueryAtom const* MakeFreeSasaAPolarAtomQuery()
--------------------------------------------------------------------------------
rdkit.Chem.rdFreeSASA.MakeFreeSasaPolarAtomQuery() → QueryAtom :¶
Returns a polar atom query for use with CalcSASA.  An polar atom has the SASAClass
and SASAClassName set to the POLAR class.  (see classifyAtoms)

C++ signature :RDKit::QueryAtom const* MakeFreeSasaPolarAtomQuery()
--------------------------------------------------------------------------------
rdkit.Chem.rdFreeSASA.classifyAtoms((Mol)mol[, (SASAOpts)options=<rdkit.Chem.rdFreeSASA.SASAOpts object at 0x7614119015b0>]) → object :¶
Classify the atoms in the molecule returning their radii if possible.
ARGUMENTS:


mol: molecule to classify

options: FreeSASA options class specifying the classification method.Current classifiers are Protor, NACCESS and OONS
classification is stored as atom property ‘SASAClass’ for the integer value

and ‘SASAClassName’ for the string name of the class, Polar, APolar…







RETURNS:list of radii where radii[atom.GetIdx()] is the radii of the atom.
If classification fails, NONE is returned

C++ signature :boost::python::api::object classifyAtoms(RDKit::ROMol {lvalue} [,FreeSASA::SASAOpts=<rdkit.Chem.rdFreeSASA.SASAOpts object at 0x7614119015b0>])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdinchi.InchiToInchiKey((str)inchi) → str :¶
return the InChI key for an InChI string

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > InchiToInchiKey(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdinchi.InchiToMol((str)inchi[, (bool)sanitize=True[, (bool)removeHs=True]]) → tuple :¶

return a ROMol for a InChI string
Returns:
a tuple with:
the molecule
the return code from the InChI conversion
a string with any messages from the InChI conversion
a string with any log messages from the InChI conversion






C++ signature :boost::python::tuple InchiToMol(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=True [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdinchi.MolBlockToInchi((str)molblock[, (str)options='']) → tuple :¶
return the InChI for a ROMol molecule.


Arguments:
molblock: the mol block to use.
options: the InChI generation options.
Options should be prefixed with either a - or a /
Available options are explained in the InChI technical FAQ:
http://www.inchi-trust.org/fileadmin/user_upload/html/inchifaq/inchi-faq.html#15.14
and the User Guide:
http://www.inchi-trust.org/fileadmin/user_upload/software/inchi-v1.04/InChI_UserGuide.pdf


Returns:
a tuple with:
the InChI
the return code from the InChI conversion
a string with any messages from the InChI conversion
a string with any log messages from the InChI conversion
a string with the InChI AuxInfo







C++ signature :boost::python::tuple MolBlockToInchi(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’])
--------------------------------------------------------------------------------
rdkit.Chem.rdinchi.MolToInchi((Mol)mol[, (str)options='']) → tuple :¶
return the InChI for a ROMol molecule.


Arguments:
mol: the molecule to use.
options: the InChI generation options.
Options should be prefixed with either a - or a /
Available options are explained in the InChI technical FAQ:
http://www.inchi-trust.org/fileadmin/user_upload/html/inchifaq/inchi-faq.html#15.14
and the User Guide:
http://www.inchi-trust.org/fileadmin/user_upload/software/inchi-v1.04/InChI_UserGuide.pdf


Returns:
a tuple with:
the InChI
the return code from the InChI conversion
a string with any messages from the InChI conversion
a string with any log messages from the InChI conversion
a string with the InChI AuxInfo







C++ signature :boost::python::tuple MolToInchi(RDKit::ROMol [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’])
--------------------------------------------------------------------------------
rdkit.Chem.rdinchi.MolToInchiKey((Mol)mol[, (str)options='']) → str :¶
return the InChI key for a ROMol molecule.


Arguments:
mol: the molecule to use.
options: the InChI generation options.
Options should be prefixed with either a - or a /
Available options are explained in the InChI technical FAQ:
https://www.inchi-trust.org/technical-faq-2/#15.14
and the User Guide available from:
https://www.inchi-trust.org/downloads/



Returns: the InChI key


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToInchiKey(RDKit::ROMol [,char const*=’’])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdMMPA.FragmentMol((Mol)mol[, (int)maxCuts=3[, (int)maxCutBonds=20[, (str)pattern='[#6+0;!$(*=, #[!#6])]!@!=!#[*]'[, (bool)resultsAsMols=True]]]]) → tuple :¶
Does the fragmentation necessary for an MMPA analysis


C++ signature :boost::python::tuple FragmentMol(RDKit::ROMol [,unsigned int=3 [,unsigned int=20 [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’[#6+0;!$(=,#[!#6])]!@!=!#[]’ [,bool=True]]]])




FragmentMol( (Mol)mol, (int)minCuts, (int)maxCuts, (int)maxCutBonds [, (str)pattern=’[#6+0;!$(=,#[!#6])]!@!=!#[]’ [, (bool)resultsAsMols=True]]) -> tuple :Does the fragmentation necessary for an MMPA analysis

C++ signature :boost::python::tuple FragmentMol(RDKit::ROMol,unsigned int,unsigned int,unsigned int [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’[#6+0;!$(=,#[!#6])]!@!=!#[]’ [,bool=True]])



FragmentMol( (Mol)mol, (AtomPairsParameters)bondsToCut [, (int)minCuts=1 [, (int)maxCuts=3 [, (bool)resultsAsMols=True]]]) -> tuple :Does the fragmentation necessary for an MMPA analysis

C++ signature :boost::python::tuple FragmentMol(RDKit::ROMol,boost::python::api::object [,unsigned int=1 [,unsigned int=3 [,bool=True]]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdMolAlign.AlignMol((Mol)prbMol, (Mol)refMol[, (int)prbCid=-1[, (int)refCid=-1[, (AtomPairsParameters)atomMap=[][, (AtomPairsParameters)weights=[][, (bool)reflect=False[, (int)maxIters=50]]]]]]) → float :¶
Optimally (minimum RMSD) align a molecule to another molecule


The 3D transformation required to align the specied conformation in the probe molecule
to a specified conformation in the reference molecule is computed so that the root mean
squared distance between a specified set of atoms is minimized. 
This transform is then applied to the specified conformation in the probe molecule


ARGUMENTS
prbMol    molecule that is to be aligned
refMol    molecule used as the reference for the alignment

prbCid    ID of the conformation in the probe to be used for the alignment (defaults to first conformation)




refCid    ID of the conformation in the ref molecule to which the alignment is computed (defaults to first conformation)




atomMap   a vector of pairs of atom IDs (probe AtomId, ref AtomId)used to compute the alignments. If this mapping is 
not specified an attempt is made to generate one by
substructure matching



weights   Optionally specify weights for each of the atom pairs
reflect   if true reflect the conformation of the probe molecule
maxIters  maximum number of iterations used in minimizing the RMSD

RETURNS
RMSD value




C++ signature :double AlignMol(RDKit::ROMol {lvalue},RDKit::ROMol [,int=-1 [,int=-1 [,boost::python::api::object=[] [,boost::python::api::object=[] [,bool=False [,unsigned int=50]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolAlign.AlignMolConformers((Mol)mol[, (AtomPairsParameters)atomIds=[][, (AtomPairsParameters)confIds=[][, (AtomPairsParameters)weights=[][, (bool)reflect=False[, (int)maxIters=50[, (AtomPairsParameters)RMSlist=None]]]]]]) → None :¶
Align conformations in a molecule to each other


The first conformation in the molecule is used as the reference


ARGUMENTS
mol          molecule of interest
atomIds      List of atom ids to use a points for alignment - defaults to all atoms
confIds      Ids of conformations to align - defaults to all conformers
weights      Optionally specify weights for each of the atom pairs
reflect      if true reflect the conformation of the probe molecule
maxIters     maximum number of iterations used in minimizing the RMSD

RMSlist      if provided, fills in the RMS values between the referenceconformation and the other aligned conformations








C++ signature :void AlignMolConformers(RDKit::ROMol {lvalue} [,boost::python::api::object=[] [,boost::python::api::object=[] [,boost::python::api::object=[] [,bool=False [,unsigned int=50 [,boost::python::api::object=None]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolAlign.CalcRMS((Mol)prbMol, (Mol)refMol[, (int)prbId=-1[, (int)refId=-1[, (AtomPairsParameters)map=None[, (int)maxMatches=1000000[, (bool)symmetrizeConjugatedTerminalGroups=True[, (AtomPairsParameters)weights=[]]]]]]]) → float :¶

Returns the RMS between two molecules, taking symmetry into account.
In contrast to getBestRMS, the RMS is computed ‘in place’, i.e.
probe molecules are not aligned to the reference ahead of the
RMS calculation. This is useful, for example, to compute
the RMSD between docking poses and the co-crystallized ligand.
Note:
This function will attempt to match all permutations of matching atom
orders in both molecules, for some molecules it will lead to
‘combinatorial explosion’ especially if hydrogens are present.

ARGUMENTS
prbMol:      the molecule to be aligned to the reference
refMol:      the reference molecule
prbCId:      (optional) probe conformation to use
refCId:      (optional) reference conformation to use

map:         (optional) a list of lists of (probeAtomId, refAtomId)tuples with the atom-atom mappings of the two
molecules. If not provided, these will be generated
using a substructure search.




maxMatches:  (optional) if map isn’t specified, this will bethe max number of matches found in a SubstructMatch()




symmetrizeConjugatedTerminalGroups:  (optional) if set, conjugatedterminal functional groups (like nitro or carboxylate)
will be considered symmetrically



weights:     (optional) weights for mapping




RETURNS
The best RMSD found

C++ signature :double CalcRMS(RDKit::ROMol {lvalue},RDKit::ROMol {lvalue} [,int=-1 [,int=-1 [,boost::python::api::object=None [,int=1000000 [,bool=True [,boost::python::api::object=[]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolAlign.GetAlignmentTransform((Mol)prbMol, (Mol)refMol[, (int)prbCid=-1[, (int)refCid=-1[, (AtomPairsParameters)atomMap=[][, (AtomPairsParameters)weights=[][, (bool)reflect=False[, (int)maxIters=50]]]]]]) → object :¶
Compute the transformation required to align a molecule


The 3D transformation required to align the specied conformation in the probe molecule
to a specified conformation in the reference molecule is computed so that the root mean
squared distance between a specified set of atoms is minimized


ARGUMENTS
prbMol    molecule that is to be aligned
refMol    molecule used as the reference for the alignment

prbCid    ID of the conformation in the probe to be used for the alignment (defaults to first conformation)




refCid    ID of the conformation in the ref molecule to which the alignment is computed (defaults to first conformation)




atomMap   a vector of pairs of atom IDs (probe AtomId, ref AtomId)used to compute the alignments. If this mapping is 
not specified an attempt is made to generate one by
substructure matching



weights   Optionally specify weights for each of the atom pairs
reflect   if true reflect the conformation of the probe molecule
maxIters  maximum number of iterations used in minimizing the RMSD

RETURNS
a tuple of (RMSD value, transform matrix)




C++ signature :_object* GetAlignmentTransform(RDKit::ROMol,RDKit::ROMol [,int=-1 [,int=-1 [,boost::python::api::object=[] [,boost::python::api::object=[] [,bool=False [,unsigned int=50]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolAlign.GetAllConformerBestRMS((Mol)mol[, (int)numThreads=1[, (AtomPairsParameters)map=None[, (int)maxMatches=1000000[, (bool)symmetrizeConjugatedTerminalGroups=True[, (AtomPairsParameters)weights=[]]]]]]) → tuple :¶

Returns the symmetric distance matrix between the conformers of a molecule.
getBestRMS() is used to calculate the inter-conformer distances

ARGUMENTS
mol:       the molecule to be considered
numThreads:  (optional) number of threads to use

map:         (optional) a list of lists of (probeAtomId,refAtomId)tuples with the atom-atom mappings of the two
molecules. If not provided, these will be generated
using a substructure search.




maxMatches:  (optional) if map isn’t specified, this will bethe max number of matches found in a SubstructMatch()




symmetrizeConjugatedTerminalGroups:  (optional) if set, conjugatedterminal functional groups (like nitro or carboxylate)
will be considered symmetrically



weights:     (optional) weights for mapping




RETURNS
A tuple with the best RMSDS. The ordering is [(1,0),(2,0),(2,1),(3,0),… etc]

C++ signature :boost::python::tuple GetAllConformerBestRMS(RDKit::ROMol {lvalue} [,int=1 [,boost::python::api::object=None [,int=1000000 [,bool=True [,boost::python::api::object=[]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolAlign.GetBestAlignmentTransform((Mol)prbMol, (Mol)refMol[, (int)prbCid=-1[, (int)refCid=-1[, (AtomPairsParameters)map=[][, (int)maxMatches=1000000[, (bool)symmetrizeConjugatedTerminalGroups=True[, (AtomPairsParameters)weights=[][, (bool)reflect=False[, (int)maxIters=50[, (int)numThreads=1]]]]]]]]]) → object :¶

Compute the optimal RMS, transformation and atom map for aligning
two molecules, taking symmetry into account. Molecule coordinates
are left unaltered.
This function will attempt to align all permutations of matching atom
orders in both molecules, for some molecules it will lead to ‘combinatorial
explosion’ especially if hydrogens are present.
Use ‘GetAlignmentTransform’ to align molecules without changing the atom order.


ARGUMENTS
prbMol      molecule that is to be aligned
refMol      molecule used as the reference for the alignment

prbCid      ID of the conformation in the probe to be used for the alignment (defaults to first conformation)




refCid      ID of the conformation in the ref molecule to which the alignment is computed (defaults to first conformation)




map:        (optional) a list of lists of (probeAtomId, refAtomId)tuples with the atom-atom mappings of the two
molecules. If not provided, these will be generated
using a substructure search.




maxMatches  (optional) if atomMap is empty, this will be the max number ofmatches found in a SubstructMatch().




symmetrizeConjugatedTerminalGroups (optional) if set, conjugatedterminal functional groups (like nitro or carboxylate)
will be considered symmetrically.



weights     Optionally specify weights for each of the atom pairs
reflect     if true reflect the conformation of the probe molecule
maxIters    maximum number of iterations used in minimizing the RMSD
numThreads  (optional) number of threads to use

RETURNS
a tuple of (RMSD value, best transform matrix, best atom map)



C++ signature :_object* GetBestAlignmentTransform(RDKit::ROMol,RDKit::ROMol [,int=-1 [,int=-1 [,boost::python::api::object=[] [,int=1000000 [,bool=True [,boost::python::api::object=[] [,bool=False [,unsigned int=50 [,int=1]]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolAlign.GetBestRMS((Mol)prbMol, (Mol)refMol[, (int)prbId=-1[, (int)refId=-1[, (AtomPairsParameters)map=None[, (int)maxMatches=1000000[, (bool)symmetrizeConjugatedTerminalGroups=True[, (AtomPairsParameters)weights=[][, (int)numThreads=1]]]]]]]) → float :¶

Returns the optimal RMS for aligning two molecules, taking
symmetry into account. As a side-effect, the probe molecule is
left in the aligned state.
Note:
This function will attempt to align all permutations of matching atom
orders in both molecules, for some molecules it will lead to
‘combinatorial explosion’ especially if hydrogens are present.
Use ‘rdkit.Chem.AllChem.AlignMol’ to align molecules without changing
the atom order.

ARGUMENTS
prbMol:      the molecule to be aligned to the reference
refMol:      the reference molecule
prbId:       (optional) probe conformation to use
refId:       (optional) reference conformation to use

map:         (optional) a list of lists of (probeAtomId,refAtomId)tuples with the atom-atom mappings of the two
molecules. If not provided, these will be generated
using a substructure search.




maxMatches:  (optional) if map isn’t specified, this will bethe max number of matches found in a SubstructMatch()




symmetrizeConjugatedTerminalGroups:  (optional) if set, conjugatedterminal functional groups (like nitro or carboxylate)
will be considered symmetrically



weights:     (optional) weights for mapping
numThreads:  (optional) number of threads to use




RETURNS
The best RMSD found

C++ signature :double GetBestRMS(RDKit::ROMol {lvalue},RDKit::ROMol {lvalue} [,int=-1 [,int=-1 [,boost::python::api::object=None [,int=1000000 [,bool=True [,boost::python::api::object=[] [,int=1]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolAlign.GetCrippenO3A((Mol)prbMol, (Mol)refMol[, (list)prbCrippenContribs=[][, (list)refCrippenContribs=[][, (int)prbCid=-1[, (int)refCid=-1[, (bool)reflect=False[, (int)maxIters=50[, (int)options=0[, (list)constraintMap=[][, (list)constraintWeights=[]]]]]]]]]]) → O3A :¶

Get an O3A object with atomMap and weights vectors to overlay
the probe molecule onto the reference molecule based on
Crippen logP atom contributions


ARGUMENTS
prbMol                   molecule that is to be aligned
refMol                   molecule used as the reference for the alignment

prbCrippenContribs       Crippen atom contributions for the probe moleculeas a list of (logp, mr) tuples, as returned
by _CalcCrippenContribs()




refCrippenContribs       Crippen atom contributions for the reference moleculeas a list of (logp, mr) tuples, as returned
by _CalcCrippenContribs()




prbCid                   ID of the conformation in the probe to be used for the alignment (defaults to first conformation)




refCid                   ID of the conformation in the ref molecule to which the alignment is computed (defaults to first conformation)




reflect                  if true reflect the conformation of the probe molecule(defaults to false)




maxIters                 maximum number of iterations used in minimizing the RMSD(defaults to 50)




options                  least 2 significant bits encode accuracy(0: maximum, 3: minimum; defaults to 0)
bit 3 triggers local optimization of the alignment
(no computation of the cost matrix; defaults: off)




constraintMap            a vector of pairs of atom IDs (probe AtomId, ref AtomId)which shall be used for the alignment (defaults to [])




constraintWeights        optionally specify weights for each of the constraints(weights default to 100.0)




RETURNS
The O3A object



C++ signature :RDKit::MolAlign::PyO3A* GetCrippenO3A(RDKit::ROMol {lvalue},RDKit::ROMol {lvalue} [,boost::python::list=[] [,boost::python::list=[] [,int=-1 [,int=-1 [,bool=False [,unsigned int=50 [,unsigned int=0 [,boost::python::list=[] [,boost::python::list=[]]]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolAlign.GetCrippenO3AForProbeConfs((Mol)prbMol, (Mol)refMol[, (int)numThreads=1[, (list)prbCrippenContribs=[][, (list)refCrippenContribs=[][, (int)refCid=-1[, (bool)reflect=False[, (int)maxIters=50[, (int)options=0[, (list)constraintMap=[][, (list)constraintWeights=[]]]]]]]]]]) → tuple :¶

Get a vector of O3A objects for the overlay of all 
the probe molecule’s conformations onto the reference molecule based on
MMFF atom types and charges


ARGUMENTS
prbMol                   molecule that is to be aligned
refMol                   molecule used as the reference for the alignment

numThreadsthe number of threads to use, only has an effect ifthe RDKit was built with thread support (defaults to 1)




prbCrippenContribs       Crippen atom contributions for the probe moleculeas a list of (logp, mr) tuples, as returned
by _CalcCrippenContribs()




refCrippenContribs       Crippen atom contributions for the reference moleculeas a list of (logp, mr) tuples, as returned
by _CalcCrippenContribs()




refCid                   ID of the conformation in the ref molecule to which the alignment is computed (defaults to first conformation)




reflect                  if true reflect the conformation of the probe molecule(defaults to false)




maxIters                 maximum number of iterations used in minimizing the RMSD(defaults to 50)




options                  least 2 significant bits encode accuracy(0: maximum, 3: minimum; defaults to 0)
bit 3 triggers local optimization of the alignment
(no computation of the cost matrix; defaults: off)




constraintMap            a vector of pairs of atom IDs (probe AtomId, ref AtomId)which shall be used for the alignment (defaults to [])




constraintWeights        optionally specify weights for each of the constraints(weights default to 100.0)




RETURNS
A vector of O3A objects



C++ signature :boost::python::tuple GetCrippenO3AForProbeConfs(RDKit::ROMol {lvalue},RDKit::ROMol {lvalue} [,int=1 [,boost::python::list=[] [,boost::python::list=[] [,int=-1 [,bool=False [,unsigned int=50 [,unsigned int=0 [,boost::python::list=[] [,boost::python::list=[]]]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolAlign.GetO3A((Mol)prbMol, (Mol)refMol[, (AtomPairsParameters)prbPyMMFFMolProperties=None[, (AtomPairsParameters)refPyMMFFMolProperties=None[, (int)prbCid=-1[, (int)refCid=-1[, (bool)reflect=False[, (int)maxIters=50[, (int)options=0[, (list)constraintMap=[][, (list)constraintWeights=[]]]]]]]]]]) → O3A :¶

Get an O3A object with atomMap and weights vectors to overlay
the probe molecule onto the reference molecule based on
MMFF atom types and charges


ARGUMENTS
prbMol                   molecule that is to be aligned
refMol                   molecule used as the reference for the alignment

prbPyMMFFMolProperties   PyMMFFMolProperties object for the probe molecule as returnedby SetupMMFFForceField()




refPyMMFFMolProperties   PyMMFFMolProperties object for the reference molecule as returnedby SetupMMFFForceField()




prbCid                   ID of the conformation in the probe to be used for the alignment (defaults to first conformation)




refCid                   ID of the conformation in the ref molecule to which the alignment is computed (defaults to first conformation)




reflect                  if true reflect the conformation of the probe molecule(defaults to false)




maxIters                 maximum number of iterations used in minimizing the RMSD(defaults to 50)




options                  least 2 significant bits encode accuracy(0: maximum, 3: minimum; defaults to 0)
bit 3 triggers local optimization of the alignment
(no computation of the cost matrix; defaults: off)




constraintMap            a vector of pairs of atom IDs (probe AtomId, ref AtomId)which shall be used for the alignment (defaults to [])




constraintWeights        optionally specify weights for each of the constraints(weights default to 100.0)




RETURNS
The O3A object



C++ signature :RDKit::MolAlign::PyO3A* GetO3A(RDKit::ROMol {lvalue},RDKit::ROMol {lvalue} [,boost::python::api::object=None [,boost::python::api::object=None [,int=-1 [,int=-1 [,bool=False [,unsigned int=50 [,unsigned int=0 [,boost::python::list=[] [,boost::python::list=[]]]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolAlign.GetO3AForProbeConfs((Mol)prbMol, (Mol)refMol[, (int)numThreads=1[, (AtomPairsParameters)prbPyMMFFMolProperties=None[, (AtomPairsParameters)refPyMMFFMolProperties=None[, (int)refCid=-1[, (bool)reflect=False[, (int)maxIters=50[, (int)options=0[, (list)constraintMap=[][, (list)constraintWeights=[]]]]]]]]]]) → tuple :¶

Get a vector of O3A objects for the overlay of all 
the probe molecule’s conformations onto the reference molecule based on
MMFF atom types and charges


ARGUMENTS
prbMol                   molecule that is to be aligned
refMol                   molecule used as the reference for the alignment

numThreadsthe number of threads to use, only has an effect ifthe RDKit was built with thread support (defaults to 1)
If set to zero, the max supported by the system will be used.




prbPyMMFFMolProperties   PyMMFFMolProperties object for the probe molecule as returnedby SetupMMFFForceField()




refPyMMFFMolProperties   PyMMFFMolProperties object for the reference molecule as returnedby SetupMMFFForceField()




refCid                   ID of the conformation in the ref molecule to which the alignment is computed (defaults to first conformation)




reflect                  if true reflect the conformation of the probe molecule(defaults to false)




maxIters                 maximum number of iterations used in minimizing the RMSD(defaults to 50)




options                  least 2 significant bits encode accuracy(0: maximum, 3: minimum; defaults to 0)
bit 3 triggers local optimization of the alignment
(no computation of the cost matrix; defaults: off)




constraintMap            a vector of pairs of atom IDs (probe AtomId, ref AtomId)which shall be used for the alignment (defaults to [])




constraintWeights        optionally specify weights for each of the constraints(weights default to 100.0)




RETURNS
A vector of O3A objects



C++ signature :boost::python::tuple GetO3AForProbeConfs(RDKit::ROMol {lvalue},RDKit::ROMol {lvalue} [,int=1 [,boost::python::api::object=None [,boost::python::api::object=None [,int=-1 [,bool=False [,unsigned int=50 [,unsigned int=0 [,boost::python::list=[] [,boost::python::list=[]]]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolAlign.RandomTransform((Mol)mol[, (int)cid=-1[, (int)seed=-1]]) → None :¶
Perform a random transformation on a molecule


ARGUMENTS
mol    molecule that is to be transformed

cid    ID of the conformation in the mol to be transformed(defaults to first conformation)




seed   seed used to initialize the random generator(defaults to -1, that is no seeding)








C++ signature :void RandomTransform(RDKit::ROMol {lvalue} [,int=-1 [,int=-1]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdMolCatalog.CreateMolCatalog() → MolCatalog :¶

C++ signature :RDCatalog::HierarchCatalog<RDKit::MolCatalogEntry, RDKit::MolCatalogParams, int>* CreateMolCatalog()
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdMolChemicalFeatures.BuildFeatureFactory((str)fileName) → MolChemicalFeatureFactory :¶
Construct a feature factory given a feature definition in a file

C++ signature :RDKit::MolChemicalFeatureFactory* BuildFeatureFactory(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolChemicalFeatures.BuildFeatureFactoryFromString((str)fdefString) → MolChemicalFeatureFactory :¶
Construct a feature factory given a feature definition block

C++ signature :RDKit::MolChemicalFeatureFactory* BuildFeatureFactoryFromString(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolChemicalFeatures.GetAtomMatch((AtomPairsParameters)featMatch[, (int)maxAts=1024]) → object :¶

Returns an empty list if any of the features passed in share an atom.Otherwise a list of lists of atom indices is returned.

C++ signature :boost::python::api::object GetAtomMatch(boost::python::api::object [,int=1024])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.BCUT2D((Mol)mol) → list :¶

Implements BCUT descriptors From J. Chem. Inf. Comput. Sci., Vol. 39, No. 1, 1999Diagonal elements are (currently) atomic mass, gasteiger charge,crippen logP and crippen MRReturns the 2D BCUT2D descriptors vector as described in
returns [mass eigen value high, mass eigen value low,gasteiger charge eigenvalue high, gasteiger charge low,
crippen lowgp  eigenvalue high, crippen lowgp  low,
crippen mr eigenvalue high, crippen mr low]

C++ signature :boost::python::list BCUT2D(RDKit::ROMol)



BCUT2D( (Mol)mol, (list)atom_props) -> tuple :
Returns a 2D BCUT (eigen value hi, eigenvalue low) given the molecule and the specified atom propsatom_props must be a list or tuple of floats equal in size to the number of atoms in mol

C++ signature :std::pair<double, double> BCUT2D(RDKit::ROMol,boost::python::list)



BCUT2D( (Mol)mol, (tuple)atom_props) -> tuple :
Returns a 2D BCUT (eigen value hi, eigenvalue low) given the molecule and the specified atom propsatom_props must be a list or tuple of floats equal in size to the number of atoms in mol

C++ signature :std::pair<double, double> BCUT2D(RDKit::ROMol,boost::python::tuple)



BCUT2D( (Mol)mol, (str)atom_propname) -> tuple :Returns a 2D BCUT (eigen value high, eigen value low) given the molecule and the specified atom prop name
atom_propname must exist on each atom and be convertible to a float

C++ signature :std::pair<double, double> BCUT2D(RDKit::ROMol,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcAUTOCORR2D((Mol)mol[, (str)CustomAtomProperty='']) → list :¶
Returns 2D Autocorrelation descriptors vector

C++ signature :boost::python::list CalcAUTOCORR2D(RDKit::ROMol [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcAUTOCORR3D((Mol)mol[, (int)confId=-1[, (str)CustomAtomProperty='']]) → list :¶
Returns 3D Autocorrelation descriptors vector

C++ signature :boost::python::list CalcAUTOCORR3D(RDKit::ROMol [,int=-1 [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcAsphericity((Mol)mol[, (int)confId=-1[, (bool)useAtomicMasses=True[, (bool)force=True]]]) → float :¶

C++ signature :double CalcAsphericity(RDKit::ROMol [,int=-1 [,bool=True [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcChi0n((Mol)mol[, (bool)force=False]) → float :¶

C++ signature :double CalcChi0n(RDKit::ROMol [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcChi0v((Mol)mol[, (bool)force=False]) → float :¶

C++ signature :double CalcChi0v(RDKit::ROMol [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcChi1n((Mol)mol[, (bool)force=False]) → float :¶

C++ signature :double CalcChi1n(RDKit::ROMol [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcChi1v((Mol)mol[, (bool)force=False]) → float :¶

C++ signature :double CalcChi1v(RDKit::ROMol [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcChi2n((Mol)mol[, (bool)force=False]) → float :¶

C++ signature :double CalcChi2n(RDKit::ROMol [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcChi2v((Mol)mol[, (bool)force=False]) → float :¶

C++ signature :double CalcChi2v(RDKit::ROMol [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcChi3n((Mol)mol[, (bool)force=False]) → float :¶

C++ signature :double CalcChi3n(RDKit::ROMol [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcChi3v((Mol)mol[, (bool)force=False]) → float :¶

C++ signature :double CalcChi3v(RDKit::ROMol [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcChi4n((Mol)mol[, (bool)force=False]) → float :¶

C++ signature :double CalcChi4n(RDKit::ROMol [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcChi4v((Mol)mol[, (bool)force=False]) → float :¶

C++ signature :double CalcChi4v(RDKit::ROMol [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcChiNn((Mol)mol, (int)n[, (bool)force=False]) → float :¶

C++ signature :double CalcChiNn(RDKit::ROMol,unsigned int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcChiNv((Mol)mol, (int)n[, (bool)force=False]) → float :¶

C++ signature :double CalcChiNv(RDKit::ROMol,unsigned int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcCoulombMat((Mol)mol[, (int)confId=-1]) → tuple :¶
Returns severals Coulomb randomized matrices

C++ signature :boost::python::tuple CalcCoulombMat(RDKit::ROMol [,int=-1])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcCrippenDescriptors((Mol)mol[, (bool)includeHs=True[, (bool)force=False]]) → tuple :¶
returns a 2-tuple with the Wildman-Crippen logp,mr values

C++ signature :boost::python::tuple CalcCrippenDescriptors(RDKit::ROMol [,bool=True [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcEEMcharges((Mol)mol[, (int)confId=-1]) → list :¶
Returns EEM atomic partial charges

C++ signature :boost::python::list CalcEEMcharges(RDKit::ROMol {lvalue} [,int=-1])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcEccentricity((Mol)mol[, (int)confId=-1[, (bool)useAtomicMasses=True[, (bool)force=True]]]) → float :¶

C++ signature :double CalcEccentricity(RDKit::ROMol [,int=-1 [,bool=True [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcExactMolWt((Mol)mol[, (bool)onlyHeavy=False]) → float :¶
returns the molecule’s exact molecular weight

C++ signature :double CalcExactMolWt(RDKit::ROMol [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcFractionCSP3((Mol)mol) → float :¶
returns the fraction of C atoms that are SP3 hybridized

C++ signature :double CalcFractionCSP3(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcGETAWAY((Mol)mol[, (int)confId=-1[, (float)precision=2[, (str)CustomAtomProperty='']]]) → list :¶
Returns the GETAWAY descriptors vector

C++ signature :boost::python::list CalcGETAWAY(RDKit::ROMol [,int=-1 [,double=2 [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcHallKierAlpha((Mol)mol[, (AtomPairsParameters)atomContribs=None]) → float :¶

C++ signature :double CalcHallKierAlpha(RDKit::ROMol [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcInertialShapeFactor((Mol)mol[, (int)confId=-1[, (bool)useAtomicMasses=True[, (bool)force=True]]]) → float :¶

C++ signature :double CalcInertialShapeFactor(RDKit::ROMol [,int=-1 [,bool=True [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcKappa1((Mol)mol) → float :¶

C++ signature :double CalcKappa1(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcKappa2((Mol)mol) → float :¶

C++ signature :double CalcKappa2(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcKappa3((Mol)mol) → float :¶

C++ signature :double CalcKappa3(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcLabuteASA((Mol)mol[, (bool)includeHs=True[, (bool)force=False]]) → float :¶
returns the Labute ASA value for a molecule

C++ signature :double CalcLabuteASA(RDKit::ROMol [,bool=True [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcMORSE((Mol)mol[, (int)confId=-1[, (str)CustomAtomProperty='']]) → list :¶
Returns Molecule Representation of Structures based on Electron diffraction descriptors

C++ signature :boost::python::list CalcMORSE(RDKit::ROMol [,int=-1 [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcMolFormula((Mol)mol[, (bool)separateIsotopes=False[, (bool)abbreviateHIsotopes=True]]) → str :¶
returns the molecule’s formula

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > CalcMolFormula(RDKit::ROMol [,bool=False [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNPR1((Mol)mol[, (int)confId=-1[, (bool)useAtomicMasses=True[, (bool)force=True]]]) → float :¶

C++ signature :double CalcNPR1(RDKit::ROMol [,int=-1 [,bool=True [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNPR2((Mol)mol[, (int)confId=-1[, (bool)useAtomicMasses=True[, (bool)force=True]]]) → float :¶

C++ signature :double CalcNPR2(RDKit::ROMol [,int=-1 [,bool=True [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumAliphaticCarbocycles((Mol)mol) → int :¶
returns the number of aliphatic (containing at least one non-aromatic bond) carbocycles for a molecule

C++ signature :unsigned int CalcNumAliphaticCarbocycles(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumAliphaticHeterocycles((Mol)mol) → int :¶
returns the number of aliphatic (containing at least one non-aromatic bond) heterocycles for a molecule

C++ signature :unsigned int CalcNumAliphaticHeterocycles(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumAliphaticRings((Mol)mol) → int :¶
returns the number of aliphatic (containing at least one non-aromatic bond) rings for a molecule

C++ signature :unsigned int CalcNumAliphaticRings(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumAmideBonds((Mol)mol) → int :¶
returns the number of amide bonds in a molecule

C++ signature :unsigned int CalcNumAmideBonds(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumAromaticCarbocycles((Mol)mol) → int :¶
returns the number of aromatic carbocycles for a molecule

C++ signature :unsigned int CalcNumAromaticCarbocycles(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumAromaticHeterocycles((Mol)mol) → int :¶
returns the number of aromatic heterocycles for a molecule

C++ signature :unsigned int CalcNumAromaticHeterocycles(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumAromaticRings((Mol)mol) → int :¶
returns the number of aromatic rings for a molecule

C++ signature :unsigned int CalcNumAromaticRings(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumAtomStereoCenters((Mol)mol) → int :¶
Returns the total number of atomic stereocenters (specified and unspecified)

C++ signature :unsigned int CalcNumAtomStereoCenters(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumAtoms((Mol)mol) → int :¶
returns the total number of atoms for a molecule

C++ signature :unsigned int CalcNumAtoms(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumBridgeheadAtoms((Mol)mol[, (AtomPairsParameters)atoms=None]) → int :¶
Returns the number of bridgehead atoms (atoms shared between rings that share at least two bonds)

C++ signature :unsigned int CalcNumBridgeheadAtoms(RDKit::ROMol [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumHBA((Mol)mol) → int :¶
returns the number of H-bond acceptors for a molecule

C++ signature :unsigned int CalcNumHBA(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumHBD((Mol)mol) → int :¶
returns the number of H-bond donors for a molecule

C++ signature :unsigned int CalcNumHBD(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumHeavyAtoms((Mol)mol) → int :¶
returns the number of heavy atoms for a molecule

C++ signature :unsigned int CalcNumHeavyAtoms(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumHeteroatoms((Mol)mol) → int :¶
returns the number of heteroatoms for a molecule

C++ signature :unsigned int CalcNumHeteroatoms(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumHeterocycles((Mol)mol) → int :¶
returns the number of heterocycles for a molecule

C++ signature :unsigned int CalcNumHeterocycles(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumLipinskiHBA((Mol)mol) → int :¶
returns the number of Lipinski H-bond acceptors for a molecule

C++ signature :unsigned int CalcNumLipinskiHBA(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumLipinskiHBD((Mol)mol) → int :¶
returns the number of Lipinski H-bond donors for a molecule

C++ signature :unsigned int CalcNumLipinskiHBD(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumRings((Mol)mol) → int :¶
returns the number of rings for a molecule

C++ signature :unsigned int CalcNumRings(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumRotatableBonds((Mol)mol, (bool)strict) → int :¶

returns the number of rotatable bonds for a molecule.
strict = NumRotatableBondsOptions.NonStrict - Simple rotatable bond definition.
strict = NumRotatableBondsOptions.Strict - (default) does not count things like

amide or ester bonds


strict = NumRotatableBondsOptions.StrictLinkages - handles linkages between ringsystems.
- Single bonds between aliphatic ring Cs are always rotatable. This

means that the central bond in CC1CCCC(C)C1-C1C(C)CCCC1C is now 
considered rotatable; it was not before


Heteroatoms in the linked rings no longer affect whether or not
the linking bond is rotatable

the linking bond in systems like Cc1cccc(C)c1-c1c(C)cccc1 is nowconsidered non-rotatable








C++ signature :unsigned int CalcNumRotatableBonds(RDKit::ROMol,bool)



CalcNumRotatableBonds( (Mol)mol [, (NumRotatableBondsOptions)strict=rdkit.Chem.rdMolDescriptors.NumRotatableBondsOptions.Default]) -> int :
returns the number of rotatable bonds for a molecule.strict = NumRotatableBondsOptions.NonStrict - Simple rotatable bond definition.
strict = NumRotatableBondsOptions.Strict - (default) does not count things like

amide or ester bonds


strict = NumRotatableBondsOptions.StrictLinkages - handles linkages between ringsystems.
- Single bonds between aliphatic ring Cs are always rotatable. This

means that the central bond in CC1CCCC(C)C1-C1C(C)CCCC1C is now 
considered rotatable; it was not before


Heteroatoms in the linked rings no longer affect whether or not
the linking bond is rotatable

the linking bond in systems like Cc1cccc(C)c1-c1c(C)cccc1 is nowconsidered non-rotatable







C++ signature :unsigned int CalcNumRotatableBonds(RDKit::ROMol [,RDKit::Descriptors::NumRotatableBondsOptions=rdkit.Chem.rdMolDescriptors.NumRotatableBondsOptions.Default])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumSaturatedCarbocycles((Mol)mol) → int :¶
returns the number of saturated carbocycles for a molecule

C++ signature :unsigned int CalcNumSaturatedCarbocycles(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumSaturatedHeterocycles((Mol)mol) → int :¶
returns the number of saturated heterocycles for a molecule

C++ signature :unsigned int CalcNumSaturatedHeterocycles(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumSaturatedRings((Mol)mol) → int :¶
returns the number of saturated rings for a molecule

C++ signature :unsigned int CalcNumSaturatedRings(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumSpiroAtoms((Mol)mol[, (AtomPairsParameters)atoms=None]) → int :¶
Returns the number of spiro atoms (atoms shared between rings that share exactly one atom)

C++ signature :unsigned int CalcNumSpiroAtoms(RDKit::ROMol [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcNumUnspecifiedAtomStereoCenters((Mol)mol) → int :¶
Returns the number of unspecified atomic stereocenters

C++ signature :unsigned int CalcNumUnspecifiedAtomStereoCenters(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcOxidationNumbers((Mol)mol) → None :¶
Adds the oxidation number/state to the atoms of a molecule as property OxidationNumber on each atom.  Use Pauling electronegativities.  This is experimental code, still under development.

C++ signature :void CalcOxidationNumbers(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcPBF((Mol)mol[, (int)confId=-1]) → float :¶
Returns the PBF (plane of best fit) descriptor (https://doi.org/10.1021/ci300293f)

C++ signature :double CalcPBF(RDKit::ROMol [,int=-1])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcPMI1((Mol)mol[, (int)confId=-1[, (bool)useAtomicMasses=True[, (bool)force=True]]]) → float :¶

C++ signature :double CalcPMI1(RDKit::ROMol [,int=-1 [,bool=True [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcPMI2((Mol)mol[, (int)confId=-1[, (bool)useAtomicMasses=True[, (bool)force=True]]]) → float :¶

C++ signature :double CalcPMI2(RDKit::ROMol [,int=-1 [,bool=True [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcPMI3((Mol)mol[, (int)confId=-1[, (bool)useAtomicMasses=True[, (bool)force=True]]]) → float :¶

C++ signature :double CalcPMI3(RDKit::ROMol [,int=-1 [,bool=True [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcPhi((Mol)mol) → float :¶

C++ signature :double CalcPhi(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcRDF((Mol)mol[, (int)confId=-1[, (str)CustomAtomProperty='']]) → list :¶
Returns radial distribution fonction descriptors (RDF)

C++ signature :boost::python::list CalcRDF(RDKit::ROMol [,int=-1 [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcRadiusOfGyration((Mol)mol[, (int)confId=-1[, (bool)useAtomicMasses=True[, (bool)force=True]]]) → float :¶

C++ signature :double CalcRadiusOfGyration(RDKit::ROMol [,int=-1 [,bool=True [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcSpherocityIndex((Mol)mol[, (int)confId=-1[, (bool)force=True]]) → float :¶

C++ signature :double CalcSpherocityIndex(RDKit::ROMol [,int=-1 [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcTPSA((Mol)mol[, (bool)force=False[, (bool)includeSandP=False]]) → float :¶
returns the TPSA value for a molecule

C++ signature :double CalcTPSA(RDKit::ROMol [,bool=False [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CalcWHIM((Mol)mol[, (int)confId=-1[, (float)thresh=0.001[, (str)CustomAtomProperty='']]]) → list :¶
Returns the WHIM descriptors vector

C++ signature :boost::python::list CalcWHIM(RDKit::ROMol [,int=-1 [,double=0.001 [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.CustomProp_VSA_((Mol)mol, (str)customPropName, (AtomPairsParameters)bins[, (bool)force=False]) → list :¶

C++ signature :boost::python::list CustomProp_VSA_(RDKit::ROMol,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,boost::python::api::object [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetAtomFeatures((Mol)mol, (int)atomid[, (bool)addchiral=False]) → list :¶
Returns the Atom Features vector

C++ signature :boost::python::list GetAtomFeatures(RDKit::ROMol,int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetAtomPairAtomCode((Atom)atom[, (int)branchSubtract=0[, (bool)includeChirality=False]]) → int :¶
Returns the atom code (hash) for an atom

C++ signature :unsigned int GetAtomPairAtomCode(RDKit::Atom const* [,unsigned int=0 [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetAtomPairCode((int)atom1Code, (int)atom2Code, (int)distance[, (bool)includeChirality=False]) → int :¶
Returns the atom-pair code (hash) for a pair of atoms separated by a certain number of bonds

C++ signature :unsigned int GetAtomPairCode(unsigned int,unsigned int,unsigned int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetAtomPairFingerprint((Mol)mol[, (int)minLength=1[, (int)maxLength=30[, (AtomPairsParameters)fromAtoms=0[, (AtomPairsParameters)ignoreAtoms=0[, (AtomPairsParameters)atomInvariants=0[, (bool)includeChirality=False[, (bool)use2D=True[, (int)confId=-1]]]]]]]]) → IntSparseIntVect :¶
Returns the atom-pair fingerprint for a molecule as an IntSparseIntVect

C++ signature :RDKit::SparseIntVect<int>* GetAtomPairFingerprint(RDKit::ROMol [,unsigned int=1 [,unsigned int=30 [,boost::python::api::object=0 [,boost::python::api::object=0 [,boost::python::api::object=0 [,bool=False [,bool=True [,int=-1]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetConnectivityInvariants((Mol)mol[, (bool)includeRingMembership=True]) → list :¶
Returns connectivity invariants (ECFP-like) for a molecule.

C++ signature :boost::python::list GetConnectivityInvariants(RDKit::ROMol [,bool=True])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetFeatureInvariants((Mol)mol) → list :¶
Returns feature invariants (FCFP-like) for a molecule.

C++ signature :boost::python::list GetFeatureInvariants(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetHashedAtomPairFingerprint((Mol)mol[, (int)nBits=2048[, (int)minLength=1[, (int)maxLength=30[, (AtomPairsParameters)fromAtoms=0[, (AtomPairsParameters)ignoreAtoms=0[, (AtomPairsParameters)atomInvariants=0[, (bool)includeChirality=False[, (bool)use2D=True[, (int)confId=-1]]]]]]]]]) → IntSparseIntVect :¶
Returns the hashed atom-pair fingerprint for a molecule as an IntSparseIntVect

C++ signature :RDKit::SparseIntVect<int>* GetHashedAtomPairFingerprint(RDKit::ROMol [,unsigned int=2048 [,unsigned int=1 [,unsigned int=30 [,boost::python::api::object=0 [,boost::python::api::object=0 [,boost::python::api::object=0 [,bool=False [,bool=True [,int=-1]]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetHashedAtomPairFingerprintAsBitVect((Mol)mol[, (int)nBits=2048[, (int)minLength=1[, (int)maxLength=30[, (AtomPairsParameters)fromAtoms=0[, (AtomPairsParameters)ignoreAtoms=0[, (AtomPairsParameters)atomInvariants=0[, (int)nBitsPerEntry=4[, (bool)includeChirality=False[, (bool)use2D=True[, (int)confId=-1]]]]]]]]]]) → ExplicitBitVect :¶
Returns the atom-pair fingerprint for a molecule as an ExplicitBitVect

C++ signature :ExplicitBitVect* GetHashedAtomPairFingerprintAsBitVect(RDKit::ROMol [,unsigned int=2048 [,unsigned int=1 [,unsigned int=30 [,boost::python::api::object=0 [,boost::python::api::object=0 [,boost::python::api::object=0 [,unsigned int=4 [,bool=False [,bool=True [,int=-1]]]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetHashedMorganFingerprint((Mol)mol, (int)radius[, (int)nBits=2048[, (AtomPairsParameters)invariants=[][, (AtomPairsParameters)fromAtoms=[][, (bool)useChirality=False[, (bool)useBondTypes=True[, (bool)useFeatures=False[, (AtomPairsParameters)bitInfo=None[, (bool)includeRedundantEnvironments=False]]]]]]]]) → UIntSparseIntVect :¶
Returns a hashed Morgan fingerprint for a molecule

C++ signature :RDKit::SparseIntVect<unsigned int>* GetHashedMorganFingerprint(RDKit::ROMol,unsigned int [,unsigned int=2048 [,boost::python::api::object=[] [,boost::python::api::object=[] [,bool=False [,bool=True [,bool=False [,boost::python::api::object=None [,bool=False]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetHashedTopologicalTorsionFingerprint((Mol)mol[, (int)nBits=2048[, (int)targetSize=4[, (AtomPairsParameters)fromAtoms=0[, (AtomPairsParameters)ignoreAtoms=0[, (AtomPairsParameters)atomInvariants=0[, (bool)includeChirality=False]]]]]]) → LongSparseIntVect :¶
Returns the hashed topological-torsion fingerprint for a molecule as a LongIntSparseIntVect

C++ signature :RDKit::SparseIntVect<long>* GetHashedTopologicalTorsionFingerprint(RDKit::ROMol [,unsigned int=2048 [,unsigned int=4 [,boost::python::api::object=0 [,boost::python::api::object=0 [,boost::python::api::object=0 [,bool=False]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetHashedTopologicalTorsionFingerprintAsBitVect((Mol)mol[, (int)nBits=2048[, (int)targetSize=4[, (AtomPairsParameters)fromAtoms=0[, (AtomPairsParameters)ignoreAtoms=0[, (AtomPairsParameters)atomInvariants=0[, (int)nBitsPerEntry=4[, (bool)includeChirality=False]]]]]]]) → ExplicitBitVect :¶
Returns the topological-torsion fingerprint for a molecule as an ExplicitBitVect

C++ signature :ExplicitBitVect* GetHashedTopologicalTorsionFingerprintAsBitVect(RDKit::ROMol [,unsigned int=2048 [,unsigned int=4 [,boost::python::api::object=0 [,boost::python::api::object=0 [,boost::python::api::object=0 [,unsigned int=4 [,bool=False]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetMACCSKeysFingerprint((Mol)mol) → ExplicitBitVect :¶
Returns the MACCS keys for a molecule as an ExplicitBitVect

C++ signature :ExplicitBitVect* GetMACCSKeysFingerprint(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetMorganFingerprint((Mol)mol, (int)radius[, (AtomPairsParameters)invariants=[][, (AtomPairsParameters)fromAtoms=[][, (bool)useChirality=False[, (bool)useBondTypes=True[, (bool)useFeatures=False[, (bool)useCounts=True[, (AtomPairsParameters)bitInfo=None[, (bool)includeRedundantEnvironments=False]]]]]]]]) → UIntSparseIntVect :¶
Returns a Morgan fingerprint for a molecule

C++ signature :RDKit::SparseIntVect<unsigned int>* GetMorganFingerprint(RDKit::ROMol,unsigned int [,boost::python::api::object=[] [,boost::python::api::object=[] [,bool=False [,bool=True [,bool=False [,bool=True [,boost::python::api::object=None [,bool=False]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetMorganFingerprintAsBitVect((Mol)mol, (int)radius[, (int)nBits=2048[, (AtomPairsParameters)invariants=[][, (AtomPairsParameters)fromAtoms=[][, (bool)useChirality=False[, (bool)useBondTypes=True[, (bool)useFeatures=False[, (AtomPairsParameters)bitInfo=None[, (bool)includeRedundantEnvironments=False]]]]]]]]) → ExplicitBitVect :¶
Returns a Morgan fingerprint for a molecule as a bit vector

C++ signature :ExplicitBitVect* GetMorganFingerprintAsBitVect(RDKit::ROMol,unsigned int [,unsigned int=2048 [,boost::python::api::object=[] [,boost::python::api::object=[] [,bool=False [,bool=True [,bool=False [,boost::python::api::object=None [,bool=False]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetTopologicalTorsionFingerprint((Mol)mol[, (int)targetSize=4[, (AtomPairsParameters)fromAtoms=0[, (AtomPairsParameters)ignoreAtoms=0[, (AtomPairsParameters)atomInvariants=0[, (bool)includeChirality=False]]]]]) → LongSparseIntVect :¶
Returns the topological-torsion fingerprint for a molecule as a LongIntSparseIntVect

C++ signature :RDKit::SparseIntVect<long>* GetTopologicalTorsionFingerprint(RDKit::ROMol [,unsigned int=4 [,boost::python::api::object=0 [,boost::python::api::object=0 [,boost::python::api::object=0 [,bool=False]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetUSR((Mol)mol[, (int)confId=-1]) → list :¶
Returns a USR descriptor for one conformer of a molecule

C++ signature :boost::python::list GetUSR(RDKit::ROMol [,int=-1])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetUSRCAT((Mol)mol[, (AtomPairsParameters)atomSelections=None[, (int)confId=-1]]) → list :¶
Returns a USRCAT descriptor for one conformer of a molecule

C++ signature :boost::python::list GetUSRCAT(RDKit::ROMol [,boost::python::api::object=None [,int=-1]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetUSRDistributions((AtomPairsParameters)coords[, (AtomPairsParameters)points=None]) → list :¶
Returns the four USR distance distributions for a set of coordinates

C++ signature :boost::python::list GetUSRDistributions(boost::python::api::object [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetUSRDistributionsFromPoints((AtomPairsParameters)coords, (AtomPairsParameters)points) → list :¶
Returns the USR distance distributions for a set of coordinates and points

C++ signature :boost::python::list GetUSRDistributionsFromPoints(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetUSRFromDistributions((AtomPairsParameters)distances) → list :¶
Returns the USR descriptor from a set of distance distributions

C++ signature :boost::python::list GetUSRFromDistributions(boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.GetUSRScore((AtomPairsParameters)descriptor1, (AtomPairsParameters)descriptor2[, (AtomPairsParameters)weights=[]]) → float :¶
Returns the USR score for two USR or USRCAT descriptors

C++ signature :double GetUSRScore(boost::python::api::object,boost::python::api::object [,boost::python::api::object=[]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.MQNs_((Mol)mol[, (bool)force=False]) → list :¶

C++ signature :boost::python::list MQNs_(RDKit::ROMol [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.MakePropertyRangeQuery((str)name, (float)min, (float)max) → PropertyRangeQuery :¶
Generates a Range property for the specified property, between min and max
query = MakePropertyRangeQuery(‘exactmw’, 0, 500)
query.Match( mol )

C++ signature :Queries::RangeQuery<double, RDKit::ROMol const&, true>* MakePropertyRangeQuery(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,double,double)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.PEOE_VSA_((Mol)mol[, (AtomPairsParameters)bins=[][, (bool)force=False]]) → list :¶

C++ signature :boost::python::list PEOE_VSA_(RDKit::ROMol [,boost::python::api::object=[] [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.SMR_VSA_((Mol)mol[, (AtomPairsParameters)bins=[][, (bool)force=False]]) → list :¶

C++ signature :boost::python::list SMR_VSA_(RDKit::ROMol [,boost::python::api::object=[] [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolDescriptors.SlogP_VSA_((Mol)mol[, (AtomPairsParameters)bins=[][, (bool)force=False]]) → list :¶

C++ signature :boost::python::list SlogP_VSA_(RDKit::ROMol [,boost::python::api::object=[] [,bool=False]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdMolEnumerator.Enumerate((Mol)mol[, (int)maxPerOperation=0]) → MolBundle :¶

do an enumeration and return a MolBundle.

If maxPerOperation is >0 that will be used as the maximum number of molecules which can be returned by any given operation.




Limitations:
the current implementation does not support molecules which include both
SRUs and LINKNODEs
Overlapping SRUs, i.e. where one monomer is contained within another, are
not supported


C++ signature :RDKit::MolBundle* Enumerate(RDKit::ROMol [,unsigned int=0])



Enumerate( (Mol)mol, (MolEnumeratorParams)enumParams) -> MolBundle :do an enumeration for the supplied parameter type and return a MolBundle
Limitations:


Overlapping SRUs, i.e. where one monomer is contained within another, are
not supported



C++ signature :RDKit::MolBundle* Enumerate(RDKit::ROMol,RDKit::MolEnumerator::MolEnumeratorParams)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.AddMetadataToPNGFile((dict)metadata, (AtomPairsParameters)filename) → object :¶
Adds metadata to PNG data read from a file.

ARGUMENTS:



metadata: dict with the metadata to be written(keys and values should be strings)



filename: the PNG filename



RETURNS:the updated PNG data




C++ signature :boost::python::api::object AddMetadataToPNGFile(boost::python::dict,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.AddMetadataToPNGString((dict)metadata, (AtomPairsParameters)png) → object :¶
Adds metadata to a PNG string.

ARGUMENTS:



metadata: dict with the metadata to be written(keys and values should be strings)



png: the PNG string



RETURNS:the updated PNG data




C++ signature :boost::python::api::object AddMetadataToPNGString(boost::python::dict,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.AtomFromSmarts((str)SMARTS) → Atom :¶
Construct an atom from a SMARTS string

C++ signature :RDKit::Atom* AtomFromSmarts(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.AtomFromSmiles((str)SMILES) → Atom :¶
Construct an atom from a SMILES string

C++ signature :RDKit::Atom* AtomFromSmiles(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.BondFromSmarts((str)SMILES) → Bond :¶
Construct a bond from a SMARTS string

C++ signature :RDKit::Bond* BondFromSmarts(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.BondFromSmiles((str)SMILES) → Bond :¶
Construct a bond from a SMILES string

C++ signature :RDKit::Bond* BondFromSmiles(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.CanonicalRankAtoms((Mol)mol[, (bool)breakTies=True[, (bool)includeChirality=True[, (bool)includeIsotopes=True[, (bool)includeAtomMaps=True]]]]) → _vectj :¶

Returns the canonical atom ranking for each atom of a molecule fragment.If breakTies is False, this returns the symmetry class for each atom.  The symmetry
class is used by the canonicalization routines to type each atom based on the whole
chemistry of the molecular graph.  Any atom with the same rank (symmetry class) is
indistinguishable.  For example:
>>> mol = MolFromSmiles('C1NCN1')
>>> list(CanonicalRankAtoms(mol, breakTies=False))
[0,1,0,1]


In this case the carbons have the same symmetry class and the nitrogens have the same
symmetry class.  From the perspective of the Molecular Graph, they are identical.
ARGUMENTS:


mol: the molecule
breakTies: (optional) force breaking of ranked ties [default=True]
includeChirality: (optional) use chiral information when computing rank [default=True]
includeIsotopes: (optional) use isotope information when computing rank [default=True]
includeAtomMaps: (optional) use atom map information when computing rank [default=True]


RETURNS:

a string


C++ signature :std::vector<unsigned int, std::allocator<unsigned int> > CanonicalRankAtoms(RDKit::ROMol [,bool=True [,bool=True [,bool=True [,bool=True]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.CanonicalRankAtomsInFragment((Mol)mol, (AtomPairsParameters)atomsToUse[, (AtomPairsParameters)bondsToUse=0[, (AtomPairsParameters)atomSymbols=0[, (bool)breakTies=True[, (bool)includeChirality=True[, (bool)includeIsotopes=True[, (bool)includeAtomMaps=True]]]]]]) → _vecti :¶

Returns the canonical atom ranking for each atom of a molecule fragmentSee help(CanonicalRankAtoms) for more information.
>>> mol = MolFromSmiles('C1NCN1.C1NCN1')
>>> list(CanonicalRankAtomsInFragment(mol, atomsToUse=range(0,4), breakTies=False))
[4,6,4,6,-1,-1,-1,-1]
>>> list(CanonicalRankAtomsInFragment(mol, atomsToUse=range(4,8), breakTies=False))
[-1,-1,-1,-1,4,6,4,6]


ARGUMENTS:


mol: the molecule
atomsToUse : a list of atoms to include in the fragment
bondsToUse : (optional) a list of bonds to include in the fragment
if not provided, all bonds between the atoms provided
will be included.
atomSymbols : (optional) a list with the symbols to use for the atoms
in the SMILES. This should have be mol.GetNumAtoms() long.
breakTies: (optional) force breaking of ranked ties
includeChirality: (optional) use chiral information when computing rank [default=True]
includeIsotopes: (optional) use isotope information when computing rank [default=True]
includeAtomMaps: (optional) use atom map information when computing rank [default=True]


RETURNS:

a string


C++ signature :std::vector<int, std::allocator<int> > CanonicalRankAtomsInFragment(RDKit::ROMol,boost::python::api::object [,boost::python::api::object=0 [,boost::python::api::object=0 [,bool=True [,bool=True [,bool=True [,bool=True]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.CanonicalizeEnhancedStereo((Mol)mol) → None :¶

C++ signature :void CanonicalizeEnhancedStereo(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.CreateAtomBoolPropertyList((Mol)mol, (str)propName[, (str)missingValueMarker=''[, (int)lineSize=190]]) → None :¶
creates a list property on the molecule from individual atom property values

C++ signature :void CreateAtomBoolPropertyList(RDKit::ROMol {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’ [,unsigned int=190]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.CreateAtomDoublePropertyList((Mol)mol, (str)propName[, (str)missingValueMarker=''[, (int)lineSize=190]]) → None :¶
creates a list property on the molecule from individual atom property values

C++ signature :void CreateAtomDoublePropertyList(RDKit::ROMol {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’ [,unsigned int=190]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.CreateAtomIntPropertyList((Mol)mol, (str)propName[, (str)missingValueMarker=''[, (int)lineSize=190]]) → None :¶
creates a list property on the molecule from individual atom property values

C++ signature :void CreateAtomIntPropertyList(RDKit::ROMol {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’ [,unsigned int=190]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.CreateAtomStringPropertyList((Mol)mol, (str)propName[, (str)missingValueMarker=''[, (int)lineSize=190]]) → None :¶
creates a list property on the molecule from individual atom property values

C++ signature :void CreateAtomStringPropertyList(RDKit::ROMol {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’’ [,unsigned int=190]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MetadataFromPNGFile((AtomPairsParameters)filename) → dict :¶
Returns a dict with all metadata from the PNG file. Keys are strings, values are bytes.

C++ signature :boost::python::dict MetadataFromPNGFile(boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MetadataFromPNGString((AtomPairsParameters)png) → dict :¶
Returns a dict with all metadata from the PNG string. Keys are strings, values are bytes.

C++ signature :boost::python::dict MetadataFromPNGString(boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFragmentToCXSmarts((Mol)mol, (AtomPairsParameters)atomsToUse[, (AtomPairsParameters)bondsToUse=0[, (bool)isomericSmarts=True]]) → str :¶

Returns a SMARTS string for a fragment of a moleculeARGUMENTS:


mol: the molecule
atomsToUse: indices of atoms to include in the SMARTS string
bondsToUse: indices of bonds to include in the SMARTS string (optional)
isomericSmarts: (optional) include information about stereochemistry in
the SMARTS.  Defaults to true.


RETURNS:

a string


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolFragmentToCXSmarts(RDKit::ROMol,boost::python::api::object [,boost::python::api::object=0 [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFragmentToCXSmiles((Mol)mol, (SmilesWriteParams)params, (AtomPairsParameters)atomsToUse[, (AtomPairsParameters)bondsToUse=0[, (AtomPairsParameters)atomSymbols=0[, (AtomPairsParameters)bondSymbols=0]]]) → str :¶

Returns the CXSMILES string for a fragment of a molecule
ARGUMENTS:


mol: the molecule
params: the SmilesWriteParams
atomsToUse : a list of atoms to include in the fragment
bondsToUse : (optional) a list of bonds to include in the fragment
if not provided, all bonds between the atoms provided
will be included.
atomSymbols : (optional) a list with the symbols to use for the atoms
in the SMILES. This should have be mol.GetNumAtoms() long.
bondSymbols : (optional) a list with the symbols to use for the bonds
in the SMILES. This should have be mol.GetNumBonds() long.


RETURNS:

a string



C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolFragmentToCXSmiles(RDKit::ROMol,RDKit::SmilesWriteParams,boost::python::api::object [,boost::python::api::object=0 [,boost::python::api::object=0 [,boost::python::api::object=0]]])



MolFragmentToCXSmiles( (Mol)mol, (AtomPairsParameters)atomsToUse [, (AtomPairsParameters)bondsToUse=0 [, (AtomPairsParameters)atomSymbols=0 [, (AtomPairsParameters)bondSymbols=0 [, (bool)isomericSmiles=True [, (bool)kekuleSmiles=False [, (int)rootedAtAtom=-1 [, (bool)canonical=True [, (bool)allBondsExplicit=False [, (bool)allHsExplicit=False]]]]]]]]]) -> str :
Returns the CXSMILES string for a fragment of a moleculeARGUMENTS:


mol: the molecule
atomsToUse : a list of atoms to include in the fragment
bondsToUse : (optional) a list of bonds to include in the fragment
if not provided, all bonds between the atoms provided
will be included.
atomSymbols : (optional) a list with the symbols to use for the atoms
in the SMILES. This should have be mol.GetNumAtoms() long.
bondSymbols : (optional) a list with the symbols to use for the bonds
in the SMILES. This should have be mol.GetNumBonds() long.
isomericSmiles: (optional) include information about stereochemistry in
the SMILES.  Defaults to true.
kekuleSmiles: (optional) use the Kekule form (no aromatic bonds) in
the SMILES.  Defaults to false.
rootedAtAtom: (optional) if non-negative, this forces the SMILES 
to start at a particular atom. Defaults to -1.
canonical: (optional) if false no attempt will be made to canonicalize
the molecule. Defaults to true.
allBondsExplicit: (optional) if true, all bond orders will be explicitly indicated
in the output SMILES. Defaults to false.
allHsExplicit: (optional) if true, all H counts will be explicitly indicated
in the output SMILES. Defaults to false.


RETURNS:

a string


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolFragmentToCXSmiles(RDKit::ROMol,boost::python::api::object [,boost::python::api::object=0 [,boost::python::api::object=0 [,boost::python::api::object=0 [,bool=True [,bool=False [,int=-1 [,bool=True [,bool=False [,bool=False]]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFragmentToSmarts((Mol)mol, (AtomPairsParameters)atomsToUse[, (AtomPairsParameters)bondsToUse=0[, (bool)isomericSmarts=True]]) → str :¶

Returns a SMARTS string for a fragment of a moleculeARGUMENTS:


mol: the molecule
atomsToUse: indices of atoms to include in the SMARTS string
bondsToUse: indices of bonds to include in the SMARTS string (optional)
isomericSmarts: (optional) include information about stereochemistry in
the SMARTS.  Defaults to true.


RETURNS:

a string


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolFragmentToSmarts(RDKit::ROMol,boost::python::api::object [,boost::python::api::object=0 [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFragmentToSmiles((Mol)mol, (SmilesWriteParams)params, (AtomPairsParameters)atomsToUse[, (AtomPairsParameters)bondsToUse=0[, (AtomPairsParameters)atomSymbols=0[, (AtomPairsParameters)bondSymbols=0]]]) → str :¶

Returns the canonical SMILES string for a fragment of a molecule
ARGUMENTS:


mol: the molecule
params: the SmilesWriteParams
atomsToUse : a list of atoms to include in the fragment
bondsToUse : (optional) a list of bonds to include in the fragment
if not provided, all bonds between the atoms provided
will be included.
atomSymbols : (optional) a list with the symbols to use for the atoms
in the SMILES. This should have be mol.GetNumAtoms() long.
bondSymbols : (optional) a list with the symbols to use for the bonds
in the SMILES. This should have be mol.GetNumBonds() long.


RETURNS:

a string



C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolFragmentToSmiles(RDKit::ROMol,RDKit::SmilesWriteParams,boost::python::api::object [,boost::python::api::object=0 [,boost::python::api::object=0 [,boost::python::api::object=0]]])



MolFragmentToSmiles( (Mol)mol, (AtomPairsParameters)atomsToUse [, (AtomPairsParameters)bondsToUse=0 [, (AtomPairsParameters)atomSymbols=0 [, (AtomPairsParameters)bondSymbols=0 [, (bool)isomericSmiles=True [, (bool)kekuleSmiles=False [, (int)rootedAtAtom=-1 [, (bool)canonical=True [, (bool)allBondsExplicit=False [, (bool)allHsExplicit=False]]]]]]]]]) -> str :
Returns the canonical SMILES string for a fragment of a moleculeARGUMENTS:


mol: the molecule
atomsToUse : a list of atoms to include in the fragment
bondsToUse : (optional) a list of bonds to include in the fragment
if not provided, all bonds between the atoms provided
will be included.
atomSymbols : (optional) a list with the symbols to use for the atoms
in the SMILES. This should have be mol.GetNumAtoms() long.
bondSymbols : (optional) a list with the symbols to use for the bonds
in the SMILES. This should have be mol.GetNumBonds() long.
isomericSmiles: (optional) include information about stereochemistry in
the SMILES.  Defaults to true.
kekuleSmiles: (optional) use the Kekule form (no aromatic bonds) in
the SMILES.  Defaults to false.
rootedAtAtom: (optional) if non-negative, this forces the SMILES 
to start at a particular atom. Defaults to -1.
canonical: (optional) if false no attempt will be made to canonicalize
the molecule. Defaults to true.
allBondsExplicit: (optional) if true, all bond orders will be explicitly indicated
in the output SMILES. Defaults to false.
allHsExplicit: (optional) if true, all H counts will be explicitly indicated
in the output SMILES. Defaults to false.


RETURNS:

a string


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolFragmentToSmiles(RDKit::ROMol,boost::python::api::object [,boost::python::api::object=0 [,boost::python::api::object=0 [,boost::python::api::object=0 [,bool=True [,bool=False [,int=-1 [,bool=True [,bool=False [,bool=False]]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromFASTA((AtomPairsParameters)text[, (bool)sanitize=True[, (int)flavor=0]]) → Mol :¶
Construct a molecule from a FASTA string (currently only supports peptides).

ARGUMENTS:


text: string containing the FASTA
sanitize: (optional) toggles sanitization of the molecule.
Defaults to True.





flavor: (optional)
0 Protein, L amino acids (default)
1 Protein, D amino acids
2 RNA, no cap
3 RNA, 5’ cap
4 RNA, 3’ cap
5 RNA, both caps
6 DNA, no cap
7 DNA, 5’ cap
8 DNA, 3’ cap
9 DNA, both caps



RETURNS:

a Mol object, None on failure.




C++ signature :RDKit::ROMol* MolFromFASTA(boost::python::api::object [,bool=True [,int=0]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromHELM((AtomPairsParameters)text[, (bool)sanitize=True]) → Mol :¶
Construct a molecule from a HELM string (currently only supports peptides).

ARGUMENTS:


text: string containing the HELM
sanitize: (optional) toggles sanitization of the molecule.
Defaults to true.


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromHELM(boost::python::api::object [,bool=True])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromMol2Block((str)molBlock[, (bool)sanitize=True[, (bool)removeHs=True[, (bool)cleanupSubstructures=True]]]) → Mol :¶
Construct a molecule from a Tripos Mol2 block.


NOTE:The parser expects the atom-typing scheme used by Corina.
Atom types from Tripos’ dbtranslate are less supported.
Other atom typing schemes are unlikely to work.


ARGUMENTS:


mol2Block: string containing the Mol2 block
sanitize: (optional) toggles sanitization of the molecule.
Defaults to True.
removeHs: (optional) toggles removing hydrogens from the molecule.
This only make sense when sanitization is done.
Defaults to true.
cleanupSubstructures: (optional) toggles standardizing some 
substructures found in mol2 files.
Defaults to true.


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromMol2Block(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=True [,bool=True [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromMol2File((str)molFileName[, (bool)sanitize=True[, (bool)removeHs=True[, (bool)cleanupSubstructures=True]]]) → Mol :¶
Construct a molecule from a Tripos Mol2 file.


NOTE:The parser expects the atom-typing scheme used by Corina.
Atom types from Tripos’ dbtranslate are less supported.
Other atom typing schemes are unlikely to work.


ARGUMENTS:


fileName: name of the file to read
sanitize: (optional) toggles sanitization of the molecule.
Defaults to true.
removeHs: (optional) toggles removing hydrogens from the molecule.
This only make sense when sanitization is done.
Defaults to true.
cleanupSubstructures: (optional) toggles standardizing some 
substructures found in mol2 files.
Defaults to true.


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromMol2File(char const* [,bool=True [,bool=True [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromMolBlock((AtomPairsParameters)molBlock[, (bool)sanitize=True[, (bool)removeHs=True[, (bool)strictParsing=True]]]) → Mol :¶
Construct a molecule from a Mol block.


ARGUMENTS:


molBlock: string containing the Mol block
sanitize: (optional) toggles sanitization of the molecule.
Defaults to True.
removeHs: (optional) toggles removing hydrogens from the molecule.
This only make sense when sanitization is done.
Defaults to true.
strictParsing: (optional) if this is false, the parser is more lax about.
correctness of the content.
Defaults to true.


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromMolBlock(boost::python::api::object [,bool=True [,bool=True [,bool=True]]])




MolFromMolBlock( (AtomPairsParameters)molBlock [, (bool)sanitize=True [, (bool)removeHs=True [, (bool)strictParsing=True]]]) -> Mol :Construct a molecule from a Mol block.

ARGUMENTS:


molBlock: string containing the Mol block
sanitize: (optional) toggles sanitization of the molecule.
Defaults to True.
removeHs: (optional) toggles removing hydrogens from the molecule.
This only make sense when sanitization is done.
Defaults to true.
strictParsing: (optional) if this is false, the parser is more lax about.
correctness of the content.
Defaults to true.


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromMolBlock(boost::python::api::object [,bool=True [,bool=True [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromMolFile((str)molFileName[, (bool)sanitize=True[, (bool)removeHs=True[, (bool)strictParsing=True]]]) → Mol :¶
Construct a molecule from a Mol file.


ARGUMENTS:


fileName: name of the file to read
sanitize: (optional) toggles sanitization of the molecule.
Defaults to true.
removeHs: (optional) toggles removing hydrogens from the molecule.
This only make sense when sanitization is done.
Defaults to true.
strictParsing: (optional) if this is false, the parser is more lax about.
correctness of the content.
Defaults to true.


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromMolFile(char const* [,bool=True [,bool=True [,bool=True]]])




MolFromMolFile( (str)molFileName [, (bool)sanitize=True [, (bool)removeHs=True [, (bool)strictParsing=True]]]) -> Mol :Construct a molecule from a Mol file.

ARGUMENTS:


fileName: name of the file to read
sanitize: (optional) toggles sanitization of the molecule.
Defaults to true.
removeHs: (optional) toggles removing hydrogens from the molecule.
This only make sense when sanitization is done.
Defaults to true.
strictParsing: (optional) if this is false, the parser is more lax about.
correctness of the content.
Defaults to true.


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromMolFile(char const* [,bool=True [,bool=True [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromMrvBlock((AtomPairsParameters)mrvBlock[, (bool)sanitize=True[, (bool)removeHs=True]]) → Mol :¶
Construct a molecule from a Marvin (mrv) block.

ARGUMENTS:


molBlock: string containing the Marvin block
sanitize: (optional) toggles sanitization of the molecule.
Defaults to True.
removeHs: (optional) toggles removing hydrogens from the molecule.
This only make sense when sanitization is done.
Defaults to true.


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromMrvBlock(boost::python::api::object [,bool=True [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromMrvFile((str)molFileName[, (bool)sanitize=True[, (bool)removeHs=True]]) → Mol :¶
Construct a molecule from a Marvin (Mrv) file.

ARGUMENTS:


fileName: name of the file to read
sanitize: (optional) toggles sanitization of the molecule.
Defaults to true.
removeHs: (optional) toggles removing hydrogens from the molecule.
This only make sense when sanitization is done.
Defaults to true.


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromMrvFile(char const* [,bool=True [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromPDBBlock((AtomPairsParameters)molBlock[, (bool)sanitize=True[, (bool)removeHs=True[, (int)flavor=0[, (bool)proximityBonding=True]]]]) → Mol :¶
Construct a molecule from a PDB block.

ARGUMENTS:


molBlock: string containing the PDB block
sanitize: (optional) toggles sanitization of the molecule.
Defaults to True.
removeHs: (optional) toggles removing hydrogens from the molecule.
This only make sense when sanitization is done.
Defaults to true.
flavor: (optional)
proximityBonding: (optional) toggles automatic proximity bonding


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromPDBBlock(boost::python::api::object [,bool=True [,bool=True [,unsigned int=0 [,bool=True]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromPDBFile((str)molFileName[, (bool)sanitize=True[, (bool)removeHs=True[, (int)flavor=0[, (bool)proximityBonding=True]]]]) → Mol :¶
Construct a molecule from a PDB file.

ARGUMENTS:


fileName: name of the file to read
sanitize: (optional) toggles sanitization of the molecule.
Defaults to true.
removeHs: (optional) toggles removing hydrogens from the molecule.
This only make sense when sanitization is done.
Defaults to true.
flavor: (optional)
proximityBonding: (optional) toggles automatic proximity bonding


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromPDBFile(char const* [,bool=True [,bool=True [,unsigned int=0 [,bool=True]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromPNGFile((str)filename[, (AtomPairsParameters)params=None]) → Mol :¶
Construct a molecule from metadata in a PNG file.

ARGUMENTS:


filename: the PNG filename
params: used to provide optional parameters for the metadata parsing



RETURNS:a Mol object, None on failure.




C++ signature :RDKit::ROMol* MolFromPNGFile(char const* [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromPNGString((AtomPairsParameters)png[, (AtomPairsParameters)params=None]) → Mol :¶
Construct a molecule from metadata in a PNG string.

ARGUMENTS:


png: the PNG string
params: used to provide optional parameters for the metadata parsing



RETURNS:a Mol object, None on failure.




C++ signature :RDKit::ROMol* MolFromPNGString(boost::python::api::object [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromRDKitSVG((AtomPairsParameters)molBlock[, (bool)sanitize=True[, (bool)removeHs=True]]) → Mol :¶
Construct a molecule from an RDKit-generate SVG string.

ARGUMENTS:


svg: string containing the SVG data (must include molecule metadata)
sanitize: (optional) toggles sanitization of the molecule.
Defaults to True.
removeHs: (optional) toggles removing hydrogens from the molecule.
This only make sense when sanitization is done.
Defaults to true.


RETURNS:

a Mol object, None on failure.

NOTE: this functionality should be considered beta.


C++ signature :RDKit::ROMol* MolFromRDKitSVG(boost::python::api::object [,bool=True [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromSequence((AtomPairsParameters)text[, (bool)sanitize=True[, (int)flavor=0]]) → Mol :¶
Construct a molecule from a sequence string (currently only supports peptides).

ARGUMENTS:


text: string containing the sequence
sanitize: (optional) toggles sanitization of the molecule.
Defaults to True.

flavor: (optional)
0 Protein, L amino acids (default)
1 Protein, D amino acids
2 RNA, no cap
3 RNA, 5’ cap
4 RNA, 3’ cap
5 RNA, both caps
6 DNA, no cap
7 DNA, 5’ cap
8 DNA, 3’ cap
9 DNA, both caps






RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromSequence(boost::python::api::object [,bool=True [,int=0]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromSmarts((AtomPairsParameters)SMARTS[, (bool)mergeHs=False[, (dict)replacements={}]]) → Mol :¶
Construct a molecule from a SMARTS string.


ARGUMENTS:


SMARTS: the smarts string
mergeHs: (optional) toggles the merging of explicit Hs in the query into the attached
atoms.  So, for example, ‘C[H]’ becomes ‘[C;!H0]’.
Defaults to 0.
replacements: (optional) a dictionary of replacement strings (see below)
Defaults to {}. See the documentation for MolFromSmiles for an explanation.


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromSmarts(boost::python::api::object [,bool=False [,boost::python::dict={}]])




MolFromSmarts( (AtomPairsParameters)SMARTS, (SmartsParserParams)params) -> Mol :Construct a molecule from a SMARTS string.

ARGUMENTS:


SMARTS: the smarts string
params: used to provide optional parameters for the SMARTS parsing


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromSmarts(boost::python::api::object,RDKit::v1::SmartsParserParams)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromSmiles((AtomPairsParameters)SMILES, (SmilesParserParams)params) → Mol :¶
Construct a molecule from a SMILES string.


ARGUMENTS:


SMILES: the smiles string
params: used to provide optional parameters for the SMILES parsing


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromSmiles(boost::python::api::object,RDKit::v1::SmilesParserParams)




MolFromSmiles( (AtomPairsParameters)SMILES [, (bool)sanitize=True [, (dict)replacements={}]]) -> Mol :Construct a molecule from a SMILES string.

ARGUMENTS:


SMILES: the smiles string
sanitize: (optional) toggles sanitization of the molecule.
Defaults to True.
replacements: (optional) a dictionary of replacement strings (see below)
Defaults to {}.


RETURNS:


a Mol object, None on failure.

The optional replacements dict can be used to do string substitution of abbreviations 
in the input SMILES. The set of substitutions is repeatedly looped through until 
the string no longer changes. It is the responsibility of the caller to make sure 
that substitutions results in legal and sensible SMILES.
Examples of replacements:

CC{Q}C with {‘{Q}’:’OCCO’} -> CCOCCOC
C{A}C{Q}C with {‘{Q}’:’OCCO’, ‘{A}’:’C1(CC1)’} -> CC1(CC1)COCCOC
C{A}C{Q}C with {‘{Q}’:’{X}CC{X}’, ‘{A}’:’C1CC1’, ‘{X}’:’N’} -> CC1CC1CNCCNC




C++ signature :RDKit::ROMol* MolFromSmiles(boost::python::api::object [,bool=True [,boost::python::dict={}]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromTPLBlock((AtomPairsParameters)tplBlock[, (bool)sanitize=True[, (bool)skipFirstConf=False]]) → Mol :¶
Construct a molecule from a TPL block.

ARGUMENTS:


fileName: name of the file to read
sanitize: (optional) toggles sanitization of the molecule.
Defaults to True.
skipFirstConf: (optional) skips reading the first conformer.
Defaults to False.
This should be set to True when reading TPLs written by 
the CombiCode.


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromTPLBlock(boost::python::api::object [,bool=True [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromTPLFile((str)fileName[, (bool)sanitize=True[, (bool)skipFirstConf=False]]) → Mol :¶
Construct a molecule from a TPL file.

ARGUMENTS:


fileName: name of the file to read
sanitize: (optional) toggles sanitization of the molecule.
Defaults to True.
skipFirstConf: (optional) skips reading the first conformer.
Defaults to False.
This should be set to True when reading TPLs written by 
the CombiCode.


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromTPLFile(char const* [,bool=True [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromXYZBlock((AtomPairsParameters)xyzFileName) → Mol :¶
Construct a molecule from an XYZ string.

ARGUMENTS:


xyzBlock: the XYZ data to read


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromXYZBlock(boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolFromXYZFile((str)xyzFileName) → Mol :¶
Construct a molecule from an XYZ file.

ARGUMENTS:


xyzname: name of the file to read


RETURNS:

a Mol object, None on failure.



C++ signature :RDKit::ROMol* MolFromXYZFile(char const*)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolMetadataToPNGFile((Mol)mol, (AtomPairsParameters)filename[, (bool)includePkl=True[, (bool)includeSmiles=True[, (bool)includeMol=False]]]) → object :¶
Adds molecular metadata to PNG data read from a file.

ARGUMENTS:


mol: the molecule
filename: the PNG filename
includePkl: include the RDKit’s internal binary format in the output
includeSmiles: include CXSmiles in the output
includeMol: include CTAB (Mol) in the output



RETURNS:the updated PNG data




C++ signature :boost::python::api::object MolMetadataToPNGFile(RDKit::ROMol,boost::python::api::object [,bool=True [,bool=True [,bool=False]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolMetadataToPNGString((Mol)mol, (AtomPairsParameters)png[, (bool)includePkl=True[, (bool)includeSmiles=True[, (bool)includeMol=False]]]) → object :¶
Adds molecular metadata to a PNG string.

ARGUMENTS:


mol: the molecule
png: the PNG string
includePkl: include the RDKit’s internal binary format in the output
includeSmiles: include CXSmiles in the output
includeMol: include CTAB (Mol) in the output



RETURNS:the updated PNG data




C++ signature :boost::python::api::object MolMetadataToPNGString(RDKit::ROMol,boost::python::api::object [,bool=True [,bool=True [,bool=False]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToCMLBlock((Mol)mol[, (int)confId=-1[, (bool)kekulize=True]]) → str :¶

Writes a CML block for a moleculeARGUMENTS:


mol: the molecule
confId: (optional) selects which conformation to output
kekulize: (optional) triggers kekulization of the molecule before it’s written



C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToCMLBlock(RDKit::ROMol [,int=-1 [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToCMLFile((Mol)mol, (str)filename[, (int)confId=-1[, (bool)kekulize=True]]) → None :¶

Writes a CML file for a moleculeARGUMENTS:


mol: the molecule
filename: the file to write to
confId: (optional) selects which conformation to output
kekulize: (optional) triggers kekulization of the molecule before it’s written



C++ signature :void MolToCMLFile(RDKit::ROMol,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,int=-1 [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToCXSmarts((Mol)mol[, (bool)isomericSmiles=True]) → str :¶

Returns a SMARTS string for a moleculeARGUMENTS:


mol: the molecule
isomericSmiles: (optional) include information about stereochemistry in
the SMARTS.  Defaults to true.


RETURNS:

a string


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToCXSmarts(RDKit::ROMol [,bool=True])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToCXSmiles((Mol)mol, (SmilesWriteParams)params[, (int)flags=rdkit.Chem.rdmolfiles.CXSmilesFields.CX_ALL[, (RestoreBondDirOption)restoreBondDirs=rdkit.Chem.rdmolfiles.RestoreBondDirOption.RestoreBondDirOptionClear]]) → str :¶
Returns the CXSMILES string for a molecule


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToCXSmiles(RDKit::ROMol,RDKit::SmilesWriteParams [,unsigned int=rdkit.Chem.rdmolfiles.CXSmilesFields.CX_ALL [,RDKit::RestoreBondDirOption=rdkit.Chem.rdmolfiles.RestoreBondDirOption.RestoreBondDirOptionClear]])




MolToCXSmiles( (Mol)mol [, (bool)isomericSmiles=True [, (bool)kekuleSmiles=False [, (int)rootedAtAtom=-1 [, (bool)canonical=True [, (bool)allBondsExplicit=False [, (bool)allHsExplicit=False [, (bool)doRandom=False]]]]]]]) -> str :
Returns the CXSMILES string for a moleculeARGUMENTS:


mol: the molecule
isomericSmiles: (optional) include information about stereochemistry in
the SMILES.  Defaults to true.
kekuleSmiles: (optional) use the Kekule form (no aromatic bonds) in
the SMILES.  Defaults to false.
rootedAtAtom: (optional) if non-negative, this forces the SMILES 
to start at a particular atom. Defaults to -1.
canonical: (optional) if false no attempt will be made to canonicalize
the molecule. Defaults to true.
allBondsExplicit: (optional) if true, all bond orders will be explicitly indicated
in the output SMILES. Defaults to false.
allHsExplicit: (optional) if true, all H counts will be explicitly indicated
in the output SMILES. Defaults to false.
doRandom: (optional) if true, randomized the trasversal of the molecule graph,
so we can generate random smiles. Defaults to false.


RETURNS:

a string


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToCXSmiles(RDKit::ROMol [,bool=True [,bool=False [,int=-1 [,bool=True [,bool=False [,bool=False [,bool=False]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToFASTA((Mol)mol) → str :¶

Returns the FASTA string for a moleculeARGUMENTS:


mol: the molecule


NOTE: the molecule should contain monomer information in AtomMonomerInfo structures
RETURNS:

a string


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToFASTA(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToHELM((Mol)mol) → str :¶

Returns the HELM string for a moleculeARGUMENTS:


mol: the molecule


NOTE: the molecule should contain monomer information in AtomMonomerInfo structures
RETURNS:

a string


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToHELM(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToMolBlock((Mol)mol, (MolWriterParams)params[, (int)confId=-1]) → str :¶

Returns a Mol block for a molecule

Arguments:
mol: the molecule
params: the MolWriterParams
confId: (optional) selects which conformation to output (-1 = default)



RETURNS:

a string



C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToMolBlock(RDKit::ROMol,RDKit::MolWriterParams [,int=-1])



MolToMolBlock( (Mol)mol [, (bool)includeStereo=True [, (int)confId=-1 [, (bool)kekulize=True [, (bool)forceV3000=False]]]]) -> str :
Returns a Mol block for a moleculeARGUMENTS:


mol: the molecule
includeStereo: (optional) toggles inclusion of stereochemical
information in the output
confId: (optional) selects which conformation to output (-1 = default)
kekulize: (optional) triggers kekulization of the molecule before it’s written,
as suggested by the MDL spec.
forceV3000 (optional) force generation a V3000 mol block (happens automatically with 
more than 999 atoms or bonds)


RETURNS:

a string


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToMolBlock(RDKit::ROMol [,bool=True [,int=-1 [,bool=True [,bool=False]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToMolFile((Mol)mol, (str)filename, (MolWriterParams)params[, (int)confId=-1]) → None :¶

Writes a Mol file for a molecule
ARGUMENTS:


mol: the molecule
filename: the file to write to
params: the MolWriterParams
confId: (optional) selects which conformation to output (-1 = default)




C++ signature :void MolToMolFile(RDKit::ROMol,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,RDKit::MolWriterParams [,int=-1])



MolToMolFile( (Mol)mol, (str)filename [, (bool)includeStereo=True [, (int)confId=-1 [, (bool)kekulize=True [, (bool)forceV3000=False]]]]) -> None :
Writes a Mol file for a moleculeARGUMENTS:


mol: the molecule
filename: the file to write to
includeStereo: (optional) toggles inclusion of stereochemical
information in the output
confId: (optional) selects which conformation to output (-1 = default)
kekulize: (optional) triggers kekulization of the molecule before it’s written,
as suggested by the MDL spec.
forceV3000 (optional) force generation a V3000 mol block (happens automatically with 
more than 999 atoms or bonds)



C++ signature :void MolToMolFile(RDKit::ROMol,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=True [,int=-1 [,bool=True [,bool=False]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToMrvBlock((Mol)mol[, (bool)includeStereo=True[, (int)confId=-1[, (bool)kekulize=True[, (bool)prettyPrint=False]]]]) → str :¶

Returns a Marvin (Mrv) Mol block for a molecule
ARGUMENTS:


mol: the molecule
includeStereo: (optional) toggles inclusion of stereochemical
information in the output
confId: (optional) selects which conformation to output (-1 = default)
kekulize: (optional) triggers kekulization of the molecule before it’s written.
prettyPrint: (optional) makes the output more human readable.


RETURNS:

a string



C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToMrvBlock(RDKit::ROMol [,bool=True [,int=-1 [,bool=True [,bool=False]]]])



MolToMrvBlock( (Mol)mol, (object)params [, (int)confId=-1]) -> str :
Returns a Marvin (Mrv) Mol block for a moleculeARGUMENTS:


mol: the molecule
params: marvin write params
confId: (optional) selects which conformation to output (-1 = default)


RETURNS:

a string


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToMrvBlock(RDKit::ROMol,RDKit::MrvWriterParams [,int=-1])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToMrvFile((Mol)mol, (str)filename[, (bool)includeStereo=True[, (int)confId=-1[, (bool)kekulize=True[, (bool)prettyPrint=False]]]]) → None :¶

Writes a Marvin (MRV) file for a molecule
ARGUMENTS:


mol: the molecule
filename: the file to write to
includeStereo: (optional) toggles inclusion of stereochemical
information in the output
confId: (optional) selects which conformation to output (-1 = default)
kekulize: (optional) triggers kekulization of the molecule before it’s written.
prettyPrint: (optional) makes the output more human readable.


RETURNS:

a string



C++ signature :void MolToMrvFile(RDKit::ROMol,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=True [,int=-1 [,bool=True [,bool=False]]]])



MolToMrvFile( (Mol)mol, (str)filename, (object)params [, (int)confId=-1]) -> None :
Writes a Marvin (MRV) file for a moleculeARGUMENTS:


mol: the molecule
filename: the file to write to
params: marvin write params
confId: (optional) selects which conformation to output (-1 = default)


RETURNS:

a string


C++ signature :void MolToMrvFile(RDKit::ROMol,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,RDKit::MrvWriterParams [,int=-1])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToPDBBlock((Mol)mol[, (int)confId=-1[, (int)flavor=0]]) → str :¶

Returns a PDB block for a moleculeARGUMENTS:


mol: the molecule
confId: (optional) selects which conformation to output (-1 = default)

flavor: (optional) 
flavor & 1 : Write MODEL/ENDMDL lines around each record
flavor & 2 : Don’t write any CONECT records
flavor & 4 : Write CONECT records in both directions
flavor & 8 : Don’t use multiple CONECTs to encode bond order
flavor & 16 : Write MASTER record
flavor & 32 : Write TER record






RETURNS:

a string


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToPDBBlock(RDKit::ROMol [,int=-1 [,unsigned int=0]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToPDBFile((Mol)mol, (str)filename[, (int)confId=-1[, (int)flavor=0]]) → None :¶

Writes a PDB file for a moleculeARGUMENTS:


mol: the molecule
filename: name of the file to write
confId: (optional) selects which conformation to output (-1 = default)

flavor: (optional) 
flavor & 1 : Write MODEL/ENDMDL lines around each record
flavor & 2 : Don’t write any CONECT records
flavor & 4 : Write CONECT records in both directions
flavor & 8 : Don’t use multiple CONECTs to encode bond order
flavor & 16 : Write MASTER record
flavor & 32 : Write TER record






RETURNS:

a string


C++ signature :void MolToPDBFile(RDKit::ROMol,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,int=-1 [,unsigned int=0]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToRandomSmilesVect((Mol)mol, (int)numSmiles[, (int)randomSeed=0[, (bool)isomericSmiles=True[, (bool)kekuleSmiles=False[, (bool)allBondsExplicit=False[, (bool)allHsExplicit=False]]]]]) → list :¶
returns a list of SMILES generated using the randomSmiles algorithm

C++ signature :boost::python::list MolToRandomSmilesVect(RDKit::ROMol,unsigned int [,unsigned int=0 [,bool=True [,bool=False [,bool=False [,bool=False]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToSequence((Mol)mol) → str :¶

Returns the sequence string for a moleculeARGUMENTS:


mol: the molecule


NOTE: the molecule should contain monomer information in AtomMonomerInfo structures
RETURNS:

a string


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToSequence(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToSmarts((Mol)mol[, (bool)isomericSmiles=True[, (int)rootedAtAtom=-1]]) → str :¶

Returns a SMARTS string for a molecule
ARGUMENTS:


mol: the molecule
isomericSmiles: (optional) include information about stereochemistry in
the SMARTS.  Defaults to true.
rootedAtomAtom: (optional) the atom index to start the SMARTS from.


RETURNS:

a string



C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToSmarts(RDKit::ROMol [,bool=True [,int=-1]])



MolToSmarts( (Mol)mol, (SmilesWriteParams)params) -> str :
Returns a SMARTS string for a moleculeARGUMENTS:


mol: the molecule
params: SmilesWriteParams controlling the SMARTS generation


RETURNS:

a string


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToSmarts(RDKit::ROMol,RDKit::SmilesWriteParams)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToSmiles((Mol)mol, (SmilesWriteParams)params) → str :¶
Returns the canonical SMILES string for a molecule


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToSmiles(RDKit::ROMol,RDKit::SmilesWriteParams)




MolToSmiles( (Mol)mol [, (bool)isomericSmiles=True [, (bool)kekuleSmiles=False [, (int)rootedAtAtom=-1 [, (bool)canonical=True [, (bool)allBondsExplicit=False [, (bool)allHsExplicit=False [, (bool)doRandom=False]]]]]]]) -> str :
Returns the canonical SMILES string for a moleculeARGUMENTS:


mol: the molecule
isomericSmiles: (optional) include information about stereochemistry in
the SMILES.  Defaults to true.
kekuleSmiles: (optional) use the Kekule form (no aromatic bonds) in
the SMILES.  Defaults to false.
rootedAtAtom: (optional) if non-negative, this forces the SMILES 
to start at a particular atom. Defaults to -1.
canonical: (optional) if false no attempt will be made to canonicalize
the molecule. Defaults to true.
allBondsExplicit: (optional) if true, all bond orders will be explicitly indicated
in the output SMILES. Defaults to false.
allHsExplicit: (optional) if true, all H counts will be explicitly indicated
in the output SMILES. Defaults to false.
doRandom: (optional) if true, randomize the traversal of the molecule graph,
so we can generate random smiles. Defaults to false.


RETURNS:

a string


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToSmiles(RDKit::ROMol [,bool=True [,bool=False [,int=-1 [,bool=True [,bool=False [,bool=False [,bool=False]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToTPLBlock((Mol)mol[, (str)partialChargeProp='_GasteigerCharge'[, (bool)writeFirstConfTwice=False]]) → str :¶
Returns the Tpl block for a molecule.

ARGUMENTS:


mol: the molecule
partialChargeProp: name of the property to use for partial charges
Defaults to ‘_GasteigerCharge’.
writeFirstConfTwice: Defaults to False.
This should be set to True when writing TPLs to be read by 
the CombiCode.


RETURNS:

a string



C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToTPLBlock(RDKit::ROMol [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’_GasteigerCharge’ [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToTPLFile((Mol)mol, (str)fileName[, (str)partialChargeProp='_GasteigerCharge'[, (bool)writeFirstConfTwice=False]]) → None :¶
Writes a molecule to a TPL file.

ARGUMENTS:


mol: the molecule
fileName: name of the file to write
partialChargeProp: name of the property to use for partial charges
Defaults to ‘_GasteigerCharge’.
writeFirstConfTwice: Defaults to False.
This should be set to True when writing TPLs to be read by 
the CombiCode.




C++ signature :void MolToTPLFile(RDKit::ROMol,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’_GasteigerCharge’ [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToV3KMolBlock((Mol)mol, (MolWriterParams)params[, (int)confId=-1]) → str :¶

Returns a V3000 Mol block for a molecule
ARGUMENTS:




mol: the molecule



params: the MolWriterParams
confId: (optional) selects which conformation to output (-1 = default)


RETURNS:

a string




C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToV3KMolBlock(RDKit::ROMol,RDKit::MolWriterParams [,int=-1])



MolToV3KMolBlock( (Mol)mol [, (bool)includeStereo=True [, (int)confId=-1 [, (bool)kekulize=True]]]) -> str :
Returns a V3000 Mol block for a moleculeARGUMENTS:




mol: the molecule



includeStereo: (optional) toggles inclusion of stereochemical
information in the output
confId: (optional) selects which conformation to output (-1 = default)
kekulize: (optional) triggers kekulization of the molecule before it’s written,
as suggested by the MDL spec.


RETURNS:

a string



C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToV3KMolBlock(RDKit::ROMol [,bool=True [,int=-1 [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToV3KMolFile((Mol)mol, (str)filename[, (MolWriterParams)params=True[, (int)confId=-1]]) → None :¶

Writes a V3000 Mol file for a molecule
ARGUMENTS:


mol: the molecule
filename: the file to write to
params: the MolWriterParams
confId: (optional) selects which conformation to output (-1 = default)




C++ signature :void MolToV3KMolFile(RDKit::ROMol,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,RDKit::MolWriterParams=True [,int=-1]])



MolToV3KMolFile( (Mol)mol, (str)filename [, (bool)includeStereo=True [, (int)confId=-1 [, (bool)kekulize=True]]]) -> None :
Writes a V3000 Mol file for a moleculeARGUMENTS:


mol: the molecule
filename: the file to write to
includeStereo: (optional) toggles inclusion of stereochemical
information in the output
confId: (optional) selects which conformation to output (-1 = default)
kekulize: (optional) triggers kekulization of the molecule before it’s written,
as suggested by the MDL spec.



C++ signature :void MolToV3KMolFile(RDKit::ROMol,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=True [,int=-1 [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToXYZBlock((Mol)mol[, (int)confId=-1[, (int)precision=6]]) → str :¶

Returns a XYZ block for a moleculeARGUMENTS:


mol: the molecule
confId: (optional) selects which conformation to output (-1 = default)
precision: precision of the coordinates


RETURNS:

a string


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToXYZBlock(RDKit::ROMol [,int=-1 [,unsigned int=6]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolToXYZFile((Mol)mol, (str)filename[, (int)confId=-1[, (int)precision=6]]) → None :¶

Writes a XYZ file for a moleculeARGUMENTS:


mol: the molecule
filename: the file to write to
confId: (optional) selects which conformation to output (-1 = default)
precision: precision of the coordinates



C++ signature :void MolToXYZFile(RDKit::ROMol,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,int=-1 [,unsigned int=6]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolsFromCDXML((AtomPairsParameters)cdxml[, (bool)sanitize=True[, (bool)removeHs=True]]) → tuple :¶
Construct a molecule from a cdxml string.

Note that the CDXML format is large and complex, the RDKit doesn’t support
full functionality, just the base ones required for molecule and
reaction parsing.
ARGUMENTS:


filename: the cdxml string
sanitize: if True, sanitize the molecules [default True]
removeHs: if True, convert explicit Hs into implicit Hs. [default True]



RETURNS:an iterator of parsed Mol objects.




C++ signature :boost::python::tuple MolsFromCDXML(boost::python::api::object [,bool=True [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolsFromCDXMLFile((str)filename[, (bool)sanitize=True[, (bool)removeHs=True]]) → object :¶
Construct a molecule from a cdxml file.

Note that the CDXML format is large and complex, the RDKit doesn’t support
full functionality, just the base ones required for molecule and
reaction parsing.
ARGUMENTS:


filename: the cdxml filename
sanitize: if True, sanitize the molecules [default True]
removeHs: if True, convert explicit Hs into implicit Hs. [default True]



RETURNS:an iterator of parsed Mol objects.




C++ signature :boost::python::api::object MolsFromCDXMLFile(char const* [,bool=True [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolsFromPNGFile((str)filename[, (str)tag='rdkitPKL'[, (AtomPairsParameters)params=None]]) → object :¶
returns a tuple of molecules constructed from the PNG file

C++ signature :boost::python::api::object MolsFromPNGFile(char const* [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’rdkitPKL’ [,boost::python::api::object=None]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.MolsFromPNGString((AtomPairsParameters)png[, (str)tag='rdkitPKL'[, (AtomPairsParameters)params=None]]) → tuple :¶
returns a tuple of molecules constructed from the PNG string

C++ signature :boost::python::tuple MolsFromPNGString(boost::python::api::object [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’rdkitPKL’ [,boost::python::api::object=None]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolfiles.SmilesMolSupplierFromText((str)text[, (str)delimiter=' '[, (int)smilesColumn=0[, (int)nameColumn=1[, (bool)titleLine=True[, (bool)sanitize=True]]]]]) → SmilesMolSupplier :¶

C++ signature :RDKit::v1::SmilesMolSupplier* SmilesMolSupplierFromText(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’ ‘ [,int=0 [,int=1 [,bool=True [,bool=True]]]]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdMolHash.MolHash((Mol)mol, (HashFunction)func[, (bool)useCxSmiles=False[, (int)cxFlagsToSkip=0]]) → str :¶
Generate a hash for a molecule. The func argument determines which hash is generated.

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolHash(RDKit::ROMol,RDKit::MolHash::HashFunction [,bool=False [,unsigned int=0]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdMolInterchange.JSONToMols((str)jsonBlock[, (AtomPairsParameters)params=None]) → tuple :¶
Convert JSON to a tuple of molecules


ARGUMENTS:
jsonBlock: the molecule to work with
params: (optional) JSONParseParameters controlling the JSON parsing


RETURNS:a tuple of Mols




C++ signature :boost::python::tuple JSONToMols(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolInterchange.MolToJSON((Mol)mol[, (AtomPairsParameters)params=None]) → str :¶
Convert a single molecule to JSON


ARGUMENTS:
mol: the molecule to work with


RETURNS:a string




C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolToJSON(RDKit::ROMol [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolInterchange.MolsToJSON((AtomPairsParameters)mols[, (AtomPairsParameters)params=None]) → str :¶
Convert a set of molecules to JSON


ARGUMENTS:
mols: the molecules to work with


RETURNS:a string




C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > MolsToJSON(boost::python::api::object [,boost::python::api::object=None])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.AddHs((Mol)mol[, (bool)explicitOnly=False[, (bool)addCoords=False[, (AtomPairsParameters)onlyOnAtoms=None[, (bool)addResidueInfo=False]]]]) → Mol :¶
Adds hydrogens to the graph of a molecule.

ARGUMENTS:


mol: the molecule to be modified
explicitOnly: (optional) if this toggle is set, only explicit Hs will
be added to the molecule.  Default value is 0 (add implicit and explicit Hs).
addCoords: (optional) if this toggle is set, The Hs will have 3D coordinates
set.  Default value is 0 (no 3D coords).
onlyOnAtoms: (optional) if this sequence is provided, only these atoms will be
considered to have Hs added to them
addResidueInfo: (optional) if this is true, add residue info to
hydrogen atoms (useful for PDB files).


RETURNS: a new molecule with added Hs
NOTES:


The original molecule is not modified.
Much of the code assumes that Hs are not included in the molecular
topology, so be very careful with the molecule that comes back from
this function.




C++ signature :RDKit::ROMol* AddHs(RDKit::ROMol [,bool=False [,bool=False [,boost::python::api::object=None [,bool=False]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.AddRecursiveQuery((Mol)mol, (Mol)query, (int)atomIdx[, (bool)preserveExistingQuery=True]) → None :¶
Adds a recursive query to an atom

ARGUMENTS:


mol: the molecule to be modified
query: the molecule to be used as the recursive query (this will be copied)
atomIdx: the atom to modify
preserveExistingQuery: (optional) if this is set, existing query information on the atom will be preserved


RETURNS: None


C++ signature :void AddRecursiveQuery(RDKit::ROMol {lvalue},RDKit::ROMol,unsigned int [,bool=True])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.AddStereoAnnotations((Mol)mol[, (str)absLabel='abs ({cip})'[, (str)orLabel='or{id}'[, (str)andLabel='and{id}'[, (str)cipLabel='({cip})'[, (str)bondLabel='({cip})']]]]]) → None :¶
add R/S, relative stereo, and E/Z annotations to atoms and bonds



Arguments:
mol: molecule to modify
absLabel: label for atoms in an ABS stereo group
orLabel: label for atoms in an OR stereo group
andLabel: label for atoms in an AND stereo group
cipLabel: label for chiral atoms that aren’t in a stereo group.
bondLabel: label for CIP stereochemistry on bonds




If any label is empty, the corresponding annotations will not be added.

The labels can contain the following placeholders:
{id} - the stereo group’s index
{cip} - the atom or bond’s CIP stereochemistry



Note that CIP labels will only be added if CIP stereochemistry has been
assigned to the molecule.


C++ signature :void AddStereoAnnotations(RDKit::ROMol {lvalue} [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’abs ({cip})’ [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’or{id}’ [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’and{id}’ [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’({cip})’ [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’({cip})’]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.AddWavyBondsForStereoAny((Mol)mol[, (bool)clearDoubleBondFlags=True[, (int)addWhenImpossible=1000]]) → None :¶

set wavy bonds around double bonds with STEREOANY stereo
ARGUMENTS :
molecule : the molecule to updaten -
conformer : the conformer to use to determine wedge direction




C++ signature :void AddWavyBondsForStereoAny(RDKit::ROMol {lvalue} [,bool=True [,unsigned int=1000]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.AdjustQueryProperties((Mol)mol[, (AtomPairsParameters)params=None]) → Mol :¶
Returns a new molecule where the query properties of atoms have been modified.

C++ signature :RDKit::ROMol* AdjustQueryProperties(RDKit::ROMol [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.AdjustQueryPropertiesWithGenericGroups((Mol)mol[, (AtomPairsParameters)params=None]) → Mol :¶
Returns a new molecule where the query properties of atoms have been modified and generic group queries have been prepared.

C++ signature :RDKit::ROMol* AdjustQueryPropertiesWithGenericGroups(RDKit::ROMol [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.AssignAtomChiralTagsFromMolParity((Mol)mol[, (bool)replaceExistingTags=True]) → None :¶

Sets the chiral tags on a molecule’s atoms based onthe molParity atom property.
ARGUMENTS:


mol: the molecule to use
replaceExistingTags: if True, existing stereochemistry information will be cleared

before running the calculation.


C++ signature :void AssignAtomChiralTagsFromMolParity(RDKit::ROMol {lvalue} [,bool=True])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.AssignAtomChiralTagsFromStructure((Mol)mol[, (int)confId=-1[, (bool)replaceExistingTags=True]]) → None :¶

Sets the chiral tags on a molecule’s atoms based ona 3D conformation.
NOTE that this does not check to see if atoms are chiral centers (i.e. all
substituents are different), it merely sets the chiral type flags based on the
coordinates and atom ordering. Use AssignStereochemistryFrom3D() if you
want chiral flags only on actual stereocenters.
ARGUMENTS:


mol: the molecule to use
confId: the conformer id to use, -1 for the default
replaceExistingTags: if True, existing stereochemistry information will be cleared

before running the calculation.


C++ signature :void AssignAtomChiralTagsFromStructure(RDKit::ROMol {lvalue} [,int=-1 [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.AssignChiralTypesFromBondDirs((Mol)mol[, (int)confId=-1[, (bool)replaceExistingTags=True]]) → None :¶
Uses bond directions to assign ChiralTypes to a molecule’s atoms.

ARGUMENTS:


mol: the molecule to use
confId: (optional) the conformation to use
replaceExistingTags: (optional) replace any existing information about stereochemistry




C++ signature :void AssignChiralTypesFromBondDirs(RDKit::ROMol {lvalue} [,int=-1 [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.AssignRadicals((Mol)mol) → None :¶
Assigns radical counts to atoms

ARGUMENTS:


mol: the molecule to use


NOTES:


The molecule is modified in place.




C++ signature :void AssignRadicals(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.AssignStereochemistry((Mol)mol[, (bool)cleanIt=False[, (bool)force=False[, (bool)flagPossibleStereoCenters=False]]]) → None :¶

Assign stereochemistry tags to atoms and bonds.If useLegacyStereoPerception is true, it also does the CIP stereochemistry
assignment for the molecule’s atoms (R/S) and double bonds (Z/E).
This assignment is based on legacy code which is fast, but is
known to incorrectly assign CIP labels in some cases.
instead, to assign CIP labels based on an accurate, though slower,
implementation of the CIP rules, call CIPLabeler::assignCIPLabels().
Chiral atoms will have a property ‘_CIPCode’ indicating their chiral code.
ARGUMENTS:


mol: the molecule to use

cleanIt: (optional) if provided, any existing values of the property _CIPCodewill be cleared, atoms with a chiral specifier that aren’t


actually chiral (e.g. atoms with duplicate substituents or only 2 substituents,
etc.) will have their chiral code set to CHI_UNSPECIFIED. Bonds with 
STEREOCIS/STEREOTRANS specified that have duplicate substituents based upon the CIP 
atom ranks will be marked STEREONONE.

force: (optional) causes the calculation to be repeated, even if it has already
been done
flagPossibleStereoCenters (optional)   set the _ChiralityPossible property on
atoms that are possible stereocenters



C++ signature :void AssignStereochemistry(RDKit::ROMol {lvalue} [,bool=False [,bool=False [,bool=False]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.AssignStereochemistryFrom3D((Mol)mol[, (int)confId=-1[, (bool)replaceExistingTags=True]]) → None :¶

Uses a conformer (should be 3D) to assign ChiralTypes to a molecule’s atoms
and stereo flags to its bonds

ARGUMENTS:


mol: the molecule to use
confId: (optional) the conformation to use
replaceExistingTags: (optional) replace any existing information about stereochemistry



C++ signature :void AssignStereochemistryFrom3D(RDKit::ROMol {lvalue} [,int=-1 [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.AtomHasConjugatedBond((Atom)atom) → bool :¶
returns whether or not the atom is involved in a conjugated bond

C++ signature :bool AtomHasConjugatedBond(RDKit::Atom const*)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.Cleanup((Mol)mol) → None :¶
cleans up certain common bad functionalities in the molecule

ARGUMENTS:


mol: the molecule to use


NOTES:


The molecule is modified in place.




C++ signature :void Cleanup(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.CleanupAtropisomers((Mol)mol) → None :¶
removes bogus atropisomeric markers (e.g. those without sp2 begin and end atoms)

ARGUMENTS:


mol: the molecule to use


NOTES:


The molecule is modified in place.




C++ signature :void CleanupAtropisomers(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.CleanupChirality((Mol)mol) → None :¶
removes bogus chirality markers (e.g. tetrahedral flags on non-sp3 centers)

ARGUMENTS:


mol: the molecule to use


NOTES:


The molecule is modified in place.




C++ signature :void CleanupChirality(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.CleanupOrganometallics((Mol)mol) → None :¶
cleans up certain common bad functionalities in the organometallic molecule


Note that this function is experimental and may either change in behavior
or be replaced with something else in future releases.

ARGUMENTS :



mol : the molecule to use

NOTES :

The molecule is modified in place.



C++ signature :void CleanupOrganometallics(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.CollapseAttachmentPoints((Mol)mol[, (bool)markedOnly=True]) → None :¶
dummy atoms in the graph are removed and replaced with attachment point annotations on the attached atoms


Arguments:
mol: molecule to be modified
markedOnly: if true, only dummy atoms with the _fromAttachPoint
property will be collapsed


In order for a dummy atom to be considered for collapsing it must have:
degree 1 with a single or unspecified bond
the bond to it can not be wedged
either no query or be an AtomNullQuery





C++ signature :void CollapseAttachmentPoints(RDKit::ROMol {lvalue} [,bool=True])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.CombineMols((Mol)mol1, (Mol)mol2[, (Point3D)offset=<rdkit.Geometry.rdGeometry.Point3D object at 0x7614e45656c0>]) → Mol :¶
Combine the atoms from two molecules to produce a third

C++ signature :RDKit::ROMol* CombineMols(RDKit::ROMol,RDKit::ROMol [,RDGeom::Point3D=<rdkit.Geometry.rdGeometry.Point3D object at 0x7614e45656c0>])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.ConvertGenericQueriesToSubstanceGroups((Mol)mol) → None :¶
documentation

C++ signature :void ConvertGenericQueriesToSubstanceGroups(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.CountAtomElec((Atom)atom) → int :¶
returns the number of electrons available on an atom to donate for aromaticity

C++ signature :int CountAtomElec(RDKit::Atom const*)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.DativeBondsToHaptic((Mol)mol) → Mol :¶
Does the reverse of hapticBondsToDative.  If there are multiple
contiguous atoms attached by dative bonds to an atom (probably a metal
atom), the dative bonds will be replaced by a dummy atom in their
centre attached to the (metal) atom by a dative bond, which is
labelled with ENDPTS of the atoms that had the original dative bonds.
ARGUMENTS:


mol: the molecule to use



RETURNS:a modified copy of the molecule

C++ signature :RDKit::ROMol* DativeBondsToHaptic(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.DeleteSubstructs((Mol)mol, (Mol)query[, (bool)onlyFrags=False[, (bool)useChirality=False]]) → Mol :¶
Removes atoms matching a substructure query from a molecule

ARGUMENTS:


mol: the molecule to be modified
query: the molecule to be used as a substructure query
onlyFrags: (optional) if this toggle is set, atoms will only be removed if
the entire fragment in which they are found is matched by the query.
See below for examples.
Default value is 0 (remove the atoms whether or not the entire fragment matches)
useChirality: (optional) match the substructure query using chirality


RETURNS: a new molecule with the substructure removed
NOTES:


The original molecule is not modified.


EXAMPLES:

The following examples substitute SMILES/SMARTS strings for molecules, you’d have
to actually use molecules:


DeleteSubstructs(‘CCOC’,’OC’) -> ‘CC’
DeleteSubstructs(‘CCOC’,’OC’,1) -> ‘CCOC’
DeleteSubstructs(‘CCOCCl.Cl’,’Cl’,1) -> ‘CCOCCl’
DeleteSubstructs(‘CCOCCl.Cl’,’Cl’) -> ‘CCOC’





C++ signature :RDKit::ROMol* DeleteSubstructs(RDKit::ROMol,RDKit::ROMol [,bool=False [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.DetectBondStereoChemistry((Mol)mol, (Conformer)conformer) → None :¶

Assign stereochemistry to bonds based on coordinates and a conformer.
DEPRECATED

ARGUMENTS:


mol: the molecule to be modified
conformer: Conformer providing the coordinates



C++ signature :void DetectBondStereoChemistry(RDKit::ROMol {lvalue},RDKit::Conformer const*)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.DetectBondStereochemistry((Mol)mol[, (int)confId=-1]) → None :¶

DEPRECATED
mol: the molecule to be modified
confId: Conformer to use for the coordinates


C++ signature :void DetectBondStereochemistry(RDKit::ROMol {lvalue} [,int=-1])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.DetectChemistryProblems((Mol)mol[, (int)sanitizeOps=rdkit.Chem.rdmolops.SanitizeFlags.SANITIZE_ALL]) → tuple :¶
checks for chemistry problems

C++ signature :boost::python::tuple DetectChemistryProblems(RDKit::ROMol [,unsigned int=rdkit.Chem.rdmolops.SanitizeFlags.SANITIZE_ALL])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.ExpandAttachmentPoints((Mol)mol[, (bool)addAsQueries=True[, (bool)addCoords=True]]) → None :¶
attachment points encoded as attachPt properties are added to the graph as dummy atoms


Arguments:
mol: molecule to be modified

addAsQueries: if true, the dummy atoms will be added as null queries(i.e. they will match any atom in a substructure search)




addCoords: if true and the molecule has one or more conformers, positions for the attachment points will be added to the conformer(s)








C++ signature :void ExpandAttachmentPoints(RDKit::ROMol {lvalue} [,bool=True [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.FastFindRings((Mol)mol) → None :¶
Does a non-SSSR ring finding for a molecule.

ARGUMENTS:


mol: the molecule to use.


RETURNS: Nothing


C++ signature :void FastFindRings(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.FindAllPathsOfLengthN((Mol)mol, (int)length[, (bool)useBonds=True[, (bool)useHs=False[, (int)rootedAtAtom=-1[, (bool)onlyShortestPaths=False]]]]) → _listSt6vectorIiSaIiEE :¶
Finds all paths of a particular length in a molecule

ARGUMENTS:


mol: the molecule to use
length: an integer with the target length for the paths.
useBonds: (optional) toggles the use of bond indices in the paths.
Otherwise atom indices are used.  Note this behavior is different
from that for subgraphs.
Defaults to 1.
rootedAtAtom: (optional) if nonzero, only paths from the specified
atom will be returned.
onlyShortestPaths: (optional) if set then only paths which are <= the shortest
path between the begin and end atoms will be included in the results


RETURNS: a tuple of tuples with IDs for the bonds.
NOTES:


Difference between _subgraphs_ and _paths_
Subgraphs are potentially branched, whereas paths (in our 
terminology at least) cannot be.  So, the following graph: 

     C--0--C--1--C--3--C
           |
           2
           |
           C

has 3 _subgraphs_ of length 3: (0,1,2),(0,1,3),(2,1,3)
but only 2 _paths_ of length 3: (0,1,3),(2,1,3)







C++ signature :std::__cxx11::list<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > FindAllPathsOfLengthN(RDKit::ROMol,unsigned int [,bool=True [,bool=False [,int=-1 [,bool=False]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.FindAllSubgraphsOfLengthMToN((Mol)mol, (int)min, (int)max[, (bool)useHs=False[, (int)rootedAtAtom=-1]]) → object :¶

Finds all subgraphs of a particular length in a moleculeSee documentation for FindAllSubgraphsOfLengthN for definitions

C++ signature :boost::python::api::object FindAllSubgraphsOfLengthMToN(RDKit::ROMol,unsigned int,unsigned int [,bool=False [,int=-1]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.FindAllSubgraphsOfLengthN((Mol)mol, (int)length[, (bool)useHs=False[, (int)rootedAtAtom=-1]]) → _listSt6vectorIiSaIiEE :¶
Finds all subgraphs of a particular length in a molecule

ARGUMENTS:


mol: the molecule to use
length: an integer with the target number of bonds for the subgraphs.
useHs: (optional) toggles whether or not bonds to Hs that are part of the graph
should be included in the results.
Defaults to 0.
rootedAtAtom: (optional) if nonzero, only subgraphs from the specified
atom will be returned.


RETURNS: a tuple of 2-tuples with bond IDs
NOTES:


Difference between _subgraphs_ and _paths_
Subgraphs are potentially branched, whereas paths (in our 
terminology at least) cannot be.  So, the following graph: 

     C--0--C--1--C--3--C
           |
           2
           |
           C





has 3 _subgraphs_ of length 3: (0,1,2),(0,1,3),(2,1,3)
but only 2 _paths_ of length 3: (0,1,3),(2,1,3)


C++ signature :std::__cxx11::list<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > FindAllSubgraphsOfLengthN(RDKit::ROMol,unsigned int [,bool=False [,int=-1]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.FindAtomEnvironmentOfRadiusN((Mol)mol, (int)radius, (int)rootedAtAtom[, (bool)useHs=False[, (bool)enforceSize=True[, (AtomPairsParameters)atomMap=None]]]) → _vecti :¶

Find bonds of a particular radius around an atom. 
Return empty result if there is no bond at the requested radius.

ARGUMENTS:


mol: the molecule to use
radius: an integer with the target radius for the environment.
rootedAtAtom: the atom to consider
useHs: (optional) toggles whether or not bonds to Hs that are part of the graph
should be included in the results.
Defaults to 0.
enforceSize (optional) If set to False, all bonds within the requested radius is 
collected. Defaults to 1.
atomMap: (optional) If provided, it will measure the minimum distance of the atom 
from the rooted atom (start with 0 from the rooted atom). The result is a pair of 
the atom ID and the distance.


RETURNS: a vector of bond IDs

C++ signature :std::vector<int, std::allocator<int> > FindAtomEnvironmentOfRadiusN(RDKit::ROMol,unsigned int,unsigned int [,bool=False [,bool=True [,boost::python::api::object=None]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.FindPotentialStereo((Mol)mol[, (bool)cleanIt=False[, (bool)flagPossible=True]]) → _vectN5RDKit9Chirality10StereoInfoE :¶
find potential stereo elements in a molecule and returns them as StereoInfo objects
Note that this function is still somewhat experimental and the API
and results may change in a future release.

C++ signature :std::vector<RDKit::Chirality::StereoInfo, std::allocator<RDKit::Chirality::StereoInfo> > FindPotentialStereo(RDKit::ROMol {lvalue} [,bool=False [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.FindPotentialStereoBonds((Mol)mol[, (bool)cleanIt=False]) → None :¶

Find bonds than can be cis/trans in a molecule and mark them as ‘any’.
This function finds any double bonds that can potentially be part
of a cis/trans system. No attempt is made here to mark them cis or trans

ARGUMENTS:


mol: the molecule to use

cleanIt: (optional) if this option is set to true, any previous marking of _CIPCodeon the bond is cleared - otherwise it is left untouched






C++ signature :void FindPotentialStereoBonds(RDKit::ROMol {lvalue} [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.FindRingFamilies((Mol)mol) → None :¶
generate Unique Ring Families

C++ signature :void FindRingFamilies(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.FindUniqueSubgraphsOfLengthN((Mol)mol, (int)length[, (bool)useHs=False[, (bool)useBO=True[, (int)rootedAtAtom=-1]]]) → _listSt6vectorIiSaIiEE :¶
Finds unique subgraphs of a particular length in a molecule

ARGUMENTS:


mol: the molecule to use
length: an integer with the target number of bonds for the subgraphs.
useHs: (optional) toggles whether or not bonds to Hs that are part of the graph
should be included in the results.
Defaults to 0.
useBO: (optional) Toggles use of bond orders in distinguishing one subgraph from
another.
Defaults to 1.
rootedAtAtom: (optional) if nonzero, only subgraphs from the specified
atom will be returned.


RETURNS: a tuple of tuples with bond IDs


C++ signature :std::__cxx11::list<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > FindUniqueSubgraphsOfLengthN(RDKit::ROMol,unsigned int [,bool=False [,bool=True [,int=-1]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.FragmentOnBRICSBonds((Mol)mol) → Mol :¶
Return a new molecule with all BRICS bonds broken

C++ signature :RDKit::ROMol* FragmentOnBRICSBonds(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.FragmentOnBonds((Mol)mol, (AtomPairsParameters)bondIndices[, (bool)addDummies=True[, (AtomPairsParameters)dummyLabels=None[, (AtomPairsParameters)bondTypes=None[, (list)cutsPerAtom=[]]]]]) → Mol :¶
Return a new molecule with all specified bonds broken

ARGUMENTS:


mol            - the molecule to be modified
bondIndices    - indices of the bonds to be broken
addDummies  - toggles addition of dummy atoms to indicate where 
bonds were broken
dummyLabels - used to provide the labels to be used for the dummies.
the first element in each pair is the label for the dummy
that replaces the bond’s beginAtom, the second is for the 
dummy that replaces the bond’s endAtom. If not provided, the
dummies are labeled with atom indices.
bondTypes - used to provide the bond type to use between the
fragments and the dummy atoms. If not provided, defaults to single.
cutsPerAtom - used to return the number of cuts made at each atom.



RETURNS:a new Mol with the modifications




C++ signature :RDKit::ROMol* FragmentOnBonds(RDKit::ROMol,boost::python::api::object [,bool=True [,boost::python::api::object=None [,boost::python::api::object=None [,boost::python::list=[]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.FragmentOnSomeBonds((Mol)mol, (AtomPairsParameters)bondIndices[, (int)numToBreak=1[, (bool)addDummies=True[, (AtomPairsParameters)dummyLabels=None[, (AtomPairsParameters)bondTypes=None[, (bool)returnCutsPerAtom=False]]]]]) → tuple :¶
fragment on some bonds

C++ signature :boost::python::tuple FragmentOnSomeBonds(RDKit::ROMol,boost::python::api::object [,unsigned int=1 [,bool=True [,boost::python::api::object=None [,boost::python::api::object=None [,bool=False]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.Get3DDistanceMatrix((Mol)mol[, (int)confId=-1[, (bool)useAtomWts=False[, (bool)force=False[, (str)prefix='']]]]) → object :¶
Returns the molecule’s 3D distance matrix.

ARGUMENTS:


mol: the molecule to use
confId: (optional) chooses the conformer Id to use
Default value is -1.
useAtomWts: (optional) toggles using atom weights for the diagonal elements of the
matrix (to return a “Balaban” distance matrix).
Default value is 0.
force: (optional) forces the calculation to proceed, even if there is a cached value.
Default value is 0.
prefix: (optional, internal use) sets the prefix used in the property cache
Default value is .


RETURNS: a Numeric array of floats with the distance matrix


C++ signature :_object* Get3DDistanceMatrix(RDKit::ROMol {lvalue} [,int=-1 [,bool=False [,bool=False [,char const*=’’]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.GetAdjacencyMatrix((Mol)mol[, (bool)useBO=False[, (int)emptyVal=0[, (bool)force=False[, (str)prefix='']]]]) → object :¶
Returns the molecule’s adjacency matrix.

ARGUMENTS:


mol: the molecule to use
useBO: (optional) toggles use of bond orders in calculating the matrix.
Default value is 0.
emptyVal: (optional) sets the elements of the matrix between non-adjacent atoms
Default value is 0.
force: (optional) forces the calculation to proceed, even if there is a cached value.
Default value is 0.
prefix: (optional, internal use) sets the prefix used in the property cache
Default value is .


RETURNS: a Numeric array of floats containing the adjacency matrix


C++ signature :_object* GetAdjacencyMatrix(RDKit::ROMol {lvalue} [,bool=False [,int=0 [,bool=False [,char const*=’’]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.GetAllowNontetrahedralChirality() → bool :¶
returns whether or not recognition of non-tetrahedral chirality from 3D structures is enabled

C++ signature :bool GetAllowNontetrahedralChirality()
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.GetDistanceMatrix((Mol)mol[, (bool)useBO=False[, (bool)useAtomWts=False[, (bool)force=False[, (str)prefix='']]]]) → object :¶
Returns the molecule’s topological distance matrix.

ARGUMENTS:


mol: the molecule to use
useBO: (optional) toggles use of bond orders in calculating the distance matrix.
Default value is 0.
useAtomWts: (optional) toggles using atom weights for the diagonal elements of the
matrix (to return a “Balaban” distance matrix).
Default value is 0.
force: (optional) forces the calculation to proceed, even if there is a cached value.
Default value is 0.
prefix: (optional, internal use) sets the prefix used in the property cache
Default value is .


RETURNS: a Numeric array of floats with the distance matrix


C++ signature :_object* GetDistanceMatrix(RDKit::ROMol {lvalue} [,bool=False [,bool=False [,bool=False [,char const*=’’]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.GetFormalCharge((Mol)mol) → int :¶
Returns the formal charge for the molecule.

ARGUMENTS:


mol: the molecule to use




C++ signature :int GetFormalCharge(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.GetMolFrags((Mol)mol[, (bool)asMols=False[, (bool)sanitizeFrags=True[, (AtomPairsParameters)frags=None[, (AtomPairsParameters)fragsMolAtomMapping=None]]]]) → tuple :¶
Finds the disconnected fragments from a molecule.

For example, for the molecule ‘CC(=O)[O-].[NH3+]C’ GetMolFrags() returns
((0, 1, 2, 3), (4, 5))
ARGUMENTS:


mol: the molecule to use
asMols: (optional) if this is provided and true, the fragments
will be returned as molecules instead of atom ids.
sanitizeFrags: (optional) if this is provided and true, the fragments
molecules will be sanitized before returning them.

frags: (optional, defaults to None) if asMols is true and this is providedas an empty list, the result will be mol.GetNumAtoms() long on return and
will contain the fragment assignment for each Atom



fragsMolAtomMapping: (optional, defaults to None) if asMols is true and this
is provided as an empty list, the result will be numFrags long on 
return, and each entry will contain the indices of the Atoms in that fragment:
[(0, 1, 2, 3), (4, 5)]



RETURNS: a tuple of tuples with IDs for the atoms in each fragmentor a tuple of molecules.




C++ signature :boost::python::tuple GetMolFrags(RDKit::ROMol [,bool=False [,bool=True [,boost::python::api::object=None [,boost::python::api::object=None]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.GetMostSubstitutedCoreMatch((Mol)mol, (Mol)core, (AtomPairsParameters)matches) → object :¶
Postprocesses the results of a mol.GetSubstructMatches(core) call 
where mol has explicit Hs and core bears terminal dummy atoms (i.e., R groups). 
It returns the match with the largest number of non-hydrogen matches to 
the terminal dummy atoms.

ARGUMENTS:


mol: the molecule GetSubstructMatches was run on
core: the molecule used as a substructure query
matches: the result returned by GetSubstructMatches



RETURNS: the tuple where terminal dummy atoms in the core match the largest number of non-hydrogen atoms in mol




C++ signature :_object* GetMostSubstitutedCoreMatch(RDKit::ROMol,RDKit::ROMol,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.GetSSSR((Mol)mol[, (bool)includeDativeBonds=False]) → _vectSt6vectorIiSaIiEE :¶
Get the smallest set of simple rings for a molecule.

ARGUMENTS:


mol: the molecule to use.
includeDativeBonds: whether or not dative bonds should be included in the ring finding.



RETURNS: a sequence of sequences containing the rings found as atom idsThe length of this will be equal to NumBonds-NumAtoms+1 for single-fragment molecules.




C++ signature :std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > GetSSSR(RDKit::ROMol {lvalue} [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.GetShortestPath((Mol)mol, (int)aid1, (int)aid2) → tuple :¶
Find the shortest path between two atoms using the Bellman-Ford algorithm.

ARGUMENTS:


mol: the molecule to use
idx1: index of the first atom
idx2: index of the second atom




C++ signature :boost::python::tuple GetShortestPath(RDKit::ROMol,int,int)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.GetSymmSSSR((Mol)mol[, (bool)includeDativeBonds=False]) → _vectSt6vectorIiSaIiEE :¶
Get a symmetrized SSSR for a molecule.

The symmetrized SSSR is at least as large as the SSSR for a molecule.
In certain highly-symmetric cases (e.g. cubane), the symmetrized SSSR can be
a bit larger (i.e. the number of symmetrized rings is >= NumBonds-NumAtoms+1).
ARGUMENTS:


mol: the molecule to use.
includeDativeBonds: whether or not dative bonds should be included in the ring finding.


RETURNS: a sequence of sequences containing the rings found as atom ids


C++ signature :std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > GetSymmSSSR(RDKit::ROMol {lvalue} [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.GetUseLegacyStereoPerception() → bool :¶
returns whether or not the legacy stereo perception code is being used

C++ signature :bool GetUseLegacyStereoPerception()
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.HapticBondsToDative((Mol)mol) → Mol :¶
One way of showing haptic bonds (such as cyclopentadiene to
iron in ferrocene) is to use a dummy atom with a dative bond to the
iron atom with the bond labelled with the atoms involved in the
organic end of the bond.  Another way is to have explicit dative
bonds from the atoms of the haptic group to the metal atom.  This
function converts the former representation to the latter.
ARGUMENTS:


mol: the molecule to use



RETURNS:a modified copy of the molecule

C++ signature :RDKit::ROMol* HapticBondsToDative(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.HasQueryHs((Mol)mol) → tuple :¶
Check to see if the molecule has query Hs, this is normally used on query molecules
such as those returned from MolFromSmarts
Example:

(hasQueryHs, hasUnmergeableQueryHs) = HasQueryHs(mol)

if hasUnmergeableQueryHs, these query hs cannot be removed by calling
MergeQueryHs

C++ signature :boost::python::tuple HasQueryHs(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.Kekulize((Mol)mol[, (bool)clearAromaticFlags=False]) → None :¶
Kekulizes the molecule

ARGUMENTS:


mol: the molecule to use
clearAromaticFlags: (optional) if this toggle is set, all atoms and bonds in the
molecule will be marked non-aromatic following the kekulization.
Default value is False.


NOTES:


The molecule is modified in place.
this does not modify query bonds which have bond type queries (like those
which come from SMARTS) or rings containing them.
even if clearAromaticFlags is False the BondType for all modified
aromatic bonds will be changed from AROMATIC to SINGLE or DOUBLE
Kekulization.




C++ signature :void Kekulize(RDKit::ROMol {lvalue} [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.KekulizeIfPossible((Mol)mol[, (bool)clearAromaticFlags=False]) → None :¶
Kekulizes the molecule if possible. Otherwise the molecule is not modified

ARGUMENTS:


mol: the molecule to use
clearAromaticFlags: (optional) if this toggle is set, all atoms and bonds in the 
molecule will be marked non-aromatic if the kekulization succeds.
Default value is False.


NOTES:


The molecule is modified in place.




C++ signature :void KekulizeIfPossible(RDKit::ROMol {lvalue} [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.LayeredFingerprint((Mol)mol[, (int)layerFlags=4294967295[, (int)minPath=1[, (int)maxPath=7[, (int)fpSize=2048[, (list)atomCounts=[][, (ExplicitBitVect)setOnlyBits=None[, (bool)branchedPaths=True[, (AtomPairsParameters)fromAtoms=0]]]]]]]]) → ExplicitBitVect :¶
Returns a layered fingerprint for a molecule


NOTE: This function is experimental. The API or results may change fromrelease to release.


Explanation of the algorithm below.
ARGUMENTS:


mol: the molecule to use
layerFlags: (optional) which layers to include in the fingerprint
See below for definitions. Defaults to all.
minPath: (optional) minimum number of bonds to include in the subgraphs
Defaults to 1.
maxPath: (optional) maximum number of bonds to include in the subgraphs
Defaults to 7.
fpSize: (optional) number of bits in the fingerprint
Defaults to 2048.
atomCounts: (optional) 
if provided, this should be a list at least as long as the number of atoms
in the molecule. It will be used to provide the count of the number 
of paths that set bits each atom is involved in.
NOTE: the list is not zeroed out here.
setOnlyBits: (optional) 
if provided, only bits that are set in this bit vector will be set
in the result. This is essentially the same as doing:

res &= setOnlyBits

but also has an impact on the atomCounts (if being used)

branchedPaths: (optional) if set both branched and unbranched paths will be
used in the fingerprint.
Defaults to True.
fromAtoms: (optional) a sequence of atom indices. If provided, only paths/subgraphs 
starting from these atoms will be used.
Defaults to empty.


RETURNS: a DataStructs.ExplicitBitVect with _fpSize_ bits

Layer definitions:
0x01: pure topology
0x02: bond order
0x04: atom types
0x08: presence of rings
0x10: ring sizes
0x20: aromaticity





C++ signature :ExplicitBitVect* LayeredFingerprint(RDKit::ROMol [,unsigned int=4294967295 [,unsigned int=1 [,unsigned int=7 [,unsigned int=2048 [,boost::python::list=[] [,ExplicitBitVect*=None [,bool=True [,boost::python::api::object=0]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.MergeQueryHs((Mol)mol[, (bool)mergeUnmappedOnly=False[, (bool)mergeIsotopes=False]]) → Mol :¶
merges hydrogens into their neighboring atoms as queries

C++ signature :RDKit::ROMol* MergeQueryHs(RDKit::ROMol [,bool=False [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.MolAddRecursiveQueries((Mol)mol, (dict)queries, (str)propName) → None :¶
Adds named recursive queries to atoms

C++ signature :void MolAddRecursiveQueries(RDKit::ROMol {lvalue},boost::python::dict,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.MurckoDecompose((Mol)mol) → Mol :¶
Do a Murcko decomposition and return the scaffold

C++ signature :RDKit::ROMol* MurckoDecompose(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.NeedsHs((Mol)mol) → bool :¶
returns whether or not the molecule needs to have Hs added

C++ signature :bool NeedsHs(RDKit::ROMol)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.ParseMolQueryDefFile((AtomPairsParameters)fileobj[, (bool)standardize=True[, (str)delimiter='\t'[, (str)comment='//'[, (int)nameColumn=0[, (int)smartsColumn=1]]]]]) → dict :¶
reads query definitions from a simply formatted file

C++ signature :boost::python::dict ParseMolQueryDefFile(boost::python::api::object {lvalue} [,bool=True [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’t’ [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=’//’ [,unsigned int=0 [,unsigned int=1]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.PathToSubmol((Mol)mol, (AtomPairsParameters)path[, (bool)useQuery=False[, (AtomPairsParameters)atomMap=None]]) → Mol :¶

C++ signature :RDKit::ROMol* PathToSubmol(RDKit::ROMol,boost::python::api::object {lvalue} [,bool=False [,boost::python::api::object=None]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.PatternFingerprint((Mol)mol[, (int)fpSize=2048[, (list)atomCounts=[][, (ExplicitBitVect)setOnlyBits=None[, (bool)tautomerFingerprints=False]]]]) → ExplicitBitVect :¶
A fingerprint using SMARTS patterns



NOTE: This function is experimental. The API or results may change fromrelease to release.




C++ signature :ExplicitBitVect* PatternFingerprint(RDKit::ROMol [,unsigned int=2048 [,boost::python::list=[] [,ExplicitBitVect*=None [,bool=False]]]])




PatternFingerprint( (MolBundle)mol [, (int)fpSize=2048 [, (ExplicitBitVect)setOnlyBits=None [, (bool)tautomerFingerprints=False]]]) -> ExplicitBitVect :A fingerprint using SMARTS patterns


NOTE: This function is experimental. The API or results may change fromrelease to release.




C++ signature :ExplicitBitVect* PatternFingerprint(RDKit::MolBundle [,unsigned int=2048 [,ExplicitBitVect*=None [,bool=False]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.RDKFingerprint((Mol)mol[, (int)minPath=1[, (int)maxPath=7[, (int)fpSize=2048[, (int)nBitsPerHash=2[, (bool)useHs=True[, (float)tgtDensity=0.0[, (int)minSize=128[, (bool)branchedPaths=True[, (bool)useBondOrder=True[, (AtomPairsParameters)atomInvariants=0[, (AtomPairsParameters)fromAtoms=0[, (AtomPairsParameters)atomBits=None[, (AtomPairsParameters)bitInfo=None]]]]]]]]]]]]]) → ExplicitBitVect :¶
Returns an RDKit topological fingerprint for a molecule

Explanation of the algorithm below.
ARGUMENTS:


mol: the molecule to use
minPath: (optional) minimum number of bonds to include in the subgraphs
Defaults to 1.
maxPath: (optional) maximum number of bonds to include in the subgraphs
Defaults to 7.
fpSize: (optional) number of bits in the fingerprint
Defaults to 2048.
nBitsPerHash: (optional) number of bits to set per path
Defaults to 2.
useHs: (optional) include paths involving Hs in the fingerprint if the molecule
has explicit Hs.
Defaults to True.
tgtDensity: (optional) fold the fingerprint until this minimum density has
been reached
Defaults to 0.
minSize: (optional) the minimum size the fingerprint will be folded to when
trying to reach tgtDensity
Defaults to 128.
branchedPaths: (optional) if set both branched and unbranched paths will be
used in the fingerprint.
Defaults to True.
useBondOrder: (optional) if set both bond orders will be used in the path hashes
Defaults to True.
atomInvariants: (optional) a sequence of atom invariants to use in the path hashes
Defaults to empty.
fromAtoms: (optional) a sequence of atom indices. If provided, only paths/subgraphs 
starting from these atoms will be used.
Defaults to empty.
atomBits: (optional) an empty list. If provided, the result will contain a list 
containing the bits each atom sets.
Defaults to empty.
bitInfo: (optional) an empty dict. If provided, the result will contain a dict 
with bits as keys and corresponding bond paths as values.
Defaults to empty.


RETURNS: a DataStructs.ExplicitBitVect with _fpSize_ bits
ALGORITHM:

This algorithm functions by find all subgraphs between minPath and maxPath in
length.  For each subgraph:


A hash is calculated.
The hash is used to seed a random-number generator
_nBitsPerHash_ random numbers are generated and used to set the corresponding
bits in the fingerprint





C++ signature :ExplicitBitVect* RDKFingerprint(RDKit::ROMol [,unsigned int=1 [,unsigned int=7 [,unsigned int=2048 [,unsigned int=2 [,bool=True [,double=0.0 [,unsigned int=128 [,bool=True [,bool=True [,boost::python::api::object=0 [,boost::python::api::object=0 [,boost::python::api::object=None [,boost::python::api::object=None]]]]]]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.ReapplyMolBlockWedging((Mol)mol[, (bool)allBondTypes=True]) → None :¶

Set the wedging to that which was read from the originalMolBlock, over-riding anything that was originally there.

ARGUMENTS:


molecule: the molecule to update
allBondTypes: reapply the wedging also on bonds other
than single and aromatic ones




C++ signature :void ReapplyMolBlockWedging(RDKit::ROMol {lvalue} [,bool=True])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.RemoveAllHs((Mol)mol[, (bool)sanitize=True]) → Mol :¶
Returns a copy of the molecule with all Hs removed.

C++ signature :RDKit::ROMol* RemoveAllHs(RDKit::ROMol [,bool=True])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.RemoveHs((Mol)mol[, (bool)implicitOnly=False[, (bool)updateExplicitCount=False[, (bool)sanitize=True]]]) → Mol :¶
Removes any hydrogens from the graph of a molecule.


ARGUMENTS:


mol: the molecule to be modified
implicitOnly: (optional) if this toggle is set, only implicit Hs will
be removed from the graph.  Default value is 0 (remove implicit and explicit Hs).
updateExplicitCount: (optional) if this toggle is set, the explicit H count on atoms with 
Hs will be updated. Default value is 0 (do not update explicit H count).
sanitize: (optional) if this toggle is set, the molecule will be sanitized after the Hs
are removed. Default value is 1 (do sanitize).


RETURNS: a new molecule with the Hs removed
NOTES:


The original molecule is not modified.
Hydrogens which aren’t connected to a heavy atom will not be
removed.  This prevents molecules like [H][H] from having
all atoms removed.
Labelled hydrogen (e.g. atoms with atomic number=1, but isotope > 1),
will not be removed.
two coordinate Hs, like the central H in C[H-]C, will not be removed
Hs connected to dummy atoms will not be removed
Hs that are part of the definition of double bond Stereochemistry
will not be removed
Hs that are not connected to anything else will not be removed




C++ signature :RDKit::ROMol* RemoveHs(RDKit::ROMol [,bool=False [,bool=False [,bool=True]]])




RemoveHs( (Mol)mol, (RemoveHsParameters)params [, (bool)sanitize=True]) -> Mol :Returns a copy of the molecule with Hs removed. Which Hs are removed is controlled by the params argument

C++ signature :RDKit::ROMol* RemoveHs(RDKit::ROMol,RDKit::MolOps::RemoveHsParameters [,bool=True])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.RemoveNonExplicit3DChirality((Mol)mol) → None :¶

Remove chiral markings that were derived from a 3D mol but were not explicity marked in the mol block. (wedge bond or CFG indication

ARGUMENTS:


molecule: the molecule to update




C++ signature :void RemoveNonExplicit3DChirality(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.RemoveStereochemistry((Mol)mol) → None :¶
Removes all stereochemistry info from the molecule.

C++ signature :void RemoveStereochemistry(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.RenumberAtoms((Mol)mol, (AtomPairsParameters)newOrder) → Mol :¶
Returns a copy of a molecule with renumbered atoms

ARGUMENTS:


mol: the molecule to be modified
newOrder: the new ordering the atoms (should be numAtoms long)
for example: if newOrder is [3,2,0,1], then atom 3 in the original 
molecule will be atom 0 in the new one




C++ signature :RDKit::ROMol* RenumberAtoms(RDKit::ROMol,boost::python::api::object {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.ReplaceCore((Mol)mol, (Mol)core, (AtomPairsParameters)matches[, (bool)replaceDummies=True[, (bool)labelByIndex=False[, (bool)requireDummyMatch=False]]]) → Mol :¶

Removes the core of a molecule and labels the sidechains with dummy atoms based onThe matches indices given in the matching vector matches.
Calling:

ReplaceCore(mol,core,mol.GetSubstructMatch(core))
ARGUMENTS:


mol: the molecule to be modified
coreQuery: the molecule to be used as a substructure query for recognizing the core
matches: a matching vector of the type returned by mol.GetSubstructMatch(…)
replaceDummies: toggles replacement of atoms that match dummies in the query
labelByIndex: toggles labeling the attachment point dummy atoms with 
the index of the core atom they’re attached to.
requireDummyMatch: if the molecule has side chains that attach at points not
flagged with a dummy, it will be rejected (None is returned)


RETURNS: a new molecule with the core removed
NOTES:


The original molecule is not modified.



EXAMPLES:

>>> from rdkit.Chem import MolToSmiles, MolFromSmiles, ReplaceCore
>>> mol = MolFromSmiles('C1ONNCC1')
>>> core = MolFromSmiles('NN')


>>> MolToSmiles(ReplaceCore(mol, core, mol.GetSubstructMatch(core)))
'[1*]OCCC[2*]'


Since NN is symmetric, we should actually get two matches here if we don’t
uniquify the matches.
>>> [MolToSmiles(ReplaceCore(mol, core, match))
...     for match in mol.GetSubstructMatches(core, uniquify=False)]
['[1*]OCCC[2*]', '[1*]CCCO[2*]']




C++ signature :RDKit::ROMol* ReplaceCore(RDKit::ROMol,RDKit::ROMol,boost::python::api::object [,bool=True [,bool=False [,bool=False]]])



ReplaceCore( (Mol)mol, (Mol)coreQuery [, (bool)replaceDummies=True [, (bool)labelByIndex=False [, (bool)requireDummyMatch=False [, (bool)useChirality=False]]]]) -> Mol :Removes the core of a molecule and labels the sidechains with dummy atoms.

ARGUMENTS:


mol: the molecule to be modified
coreQuery: the molecule to be used as a substructure query for recognizing the core
replaceDummies: toggles replacement of atoms that match dummies in the query
labelByIndex: toggles labeling the attachment point dummy atoms with 
the index of the core atom they’re attached to.
requireDummyMatch: if the molecule has side chains that attach at points not
flagged with a dummy, it will be rejected (None is returned)
useChirality: use chirality matching in the coreQuery


RETURNS: a new molecule with the core removed
NOTES:


The original molecule is not modified.


EXAMPLES:

>>> from rdkit.Chem import MolToSmiles, MolFromSmiles, MolFromSmarts, ReplaceCore


Basic usage: remove a core as specified by SMILES (or another molecule).
To get the atom labels which are stored as an isotope of the matched atom, 
the output must be written as isomeric smiles.  
A small confusion is that atom isotopes of 0 aren’t shown in smiles strings.
Here we remove a ring and leave the decoration (r-group) behind.
>>> MolToSmiles(ReplaceCore(MolFromSmiles('CCCC1CCC1'),MolFromSmiles('C1CCC1')),
...             isomericSmiles=True)
'[1*]CCC'


The isotope label by default is matched by the first connection found. In order to
indicate which atom the decoration is attached in the core query, use labelByIndex=True.
Here the attachment is from the third atom in the smiles string, which is indexed by 3
in the core, like all good computer scientists expect, atoms indices start at 0.
>>> MolToSmiles(ReplaceCore(MolFromSmiles('CCN1CCC1'),MolFromSmiles('C1CCN1'),
...                         labelByIndex=True),
...   isomericSmiles=True)
'[3*]CC'


Non-core matches just return None
>>> ReplaceCore(MolFromSmiles('CCC1CC1'),MolFromSmiles('C1CCC1'))


The bond between atoms are considered part of the core and are removed as well
>>> MolToSmiles(ReplaceCore(MolFromSmiles('C1CC2C1CCC2'),MolFromSmiles('C1CCC1')),
...             isomericSmiles=True)
'[1*]CCC[2*]'
>>> MolToSmiles(ReplaceCore(MolFromSmiles('C1CNCC1'),MolFromSmiles('N')),
...             isomericSmiles=True)
'[1*]CCCC[2*]'


When using dummy atoms, cores should be read in as SMARTS.  When read as SMILES
dummy atoms only match other dummy atoms.
The replaceDummies flag indicates whether matches to the dummy atoms should be considered as part
of the core or as part of the decoration (r-group)
>>> MolToSmiles(ReplaceCore(MolFromSmiles('C1CNCC1'),MolFromSmarts('[*]N[*]'),
...                         replaceDummies=True),
...             isomericSmiles=True)
'[1*]CC[2*]'
>>> MolToSmiles(ReplaceCore(MolFromSmiles('C1CNCC1'),MolFromSmarts('[*]N[*]'),
...                         replaceDummies=False),
...             isomericSmiles=True)
'[1*]CCCC[2*]'


>>> MolToSmiles(ReplaceCore(MolFromSmiles('C1CCC1CN'),MolFromSmarts('C1CCC1[*]'),
...                         replaceDummies=False),
...             isomericSmiles=True)
'[1*]CN'





C++ signature :RDKit::ROMol* ReplaceCore(RDKit::ROMol,RDKit::ROMol [,bool=True [,bool=False [,bool=False [,bool=False]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.ReplaceSidechains((Mol)mol, (Mol)coreQuery[, (bool)useChirality=False]) → Mol :¶
Replaces sidechains in a molecule with dummy atoms for their attachment points.

ARGUMENTS:


mol: the molecule to be modified
coreQuery: the molecule to be used as a substructure query for recognizing the core
useChirality: (optional) match the substructure query using chirality


RETURNS: a new molecule with the sidechains removed
NOTES:


The original molecule is not modified.


EXAMPLES:

The following examples substitute SMILES/SMARTS strings for molecules, you’d have
to actually use molecules:


ReplaceSidechains(‘CCC1CCC1’,’C1CCC1’) -> ‘[Xa]C1CCC1’
ReplaceSidechains(‘CCC1CC1’,’C1CCC1’) -> ‘’
ReplaceSidechains(‘C1CC2C1CCC2’,’C1CCC1’) -> ‘[Xa]C1CCC1[Xb]’





C++ signature :RDKit::ROMol* ReplaceSidechains(RDKit::ROMol,RDKit::ROMol [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.ReplaceSubstructs((Mol)mol, (Mol)query, (Mol)replacement[, (bool)replaceAll=False[, (int)replacementConnectionPoint=0[, (bool)useChirality=False]]]) → object :¶
Replaces atoms matching a substructure query in a molecule

ARGUMENTS:


mol: the molecule to be modified
query: the molecule to be used as a substructure query
replacement: the molecule to be used as the replacement
replaceAll: (optional) if this toggle is set, all substructures matching
the query will be replaced in a single result, otherwise each result will
contain a separate replacement.
Default value is False (return multiple replacements)
replacementConnectionPoint: (optional) index of the atom in the replacement that
the bond should be made to.
useChirality: (optional) match the substructure query using chirality


RETURNS: a tuple of new molecules with the substructures replaced removed
NOTES:


The original molecule is not modified.
A bond is only formed to the remaining atoms, if any, that were bonded 
to the first atom in the substructure query. (For finer control over
substructure replacement, consider using ChemicalReaction.)


EXAMPLES:

The following examples substitute SMILES/SMARTS strings for molecules, you’d have
to actually use molecules:


ReplaceSubstructs(‘CCOC’,’O[CH3]’,’NC’) -> (‘CCNC’,)
ReplaceSubstructs(‘COCCOC’,’O[CH3]’,’NC’) -> (‘COCCNC’,’CNCCOC’)
ReplaceSubstructs(‘COCCOC’,’O[CH3]’,’NC’,True) -> (‘CNCCNC’,)
ReplaceSubstructs(‘COCCOC’,’O[CH3]’,’CN’,True,1) -> (‘CNCCNC’,)
ReplaceSubstructs(‘CCOC’,’[CH3]O’,’NC’) -> (‘CC.CN’,)





C++ signature :_object* ReplaceSubstructs(RDKit::ROMol,RDKit::ROMol,RDKit::ROMol [,bool=False [,unsigned int=0 [,bool=False]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.SanitizeMol((Mol)mol[, (int)sanitizeOps=rdkit.Chem.rdmolops.SanitizeFlags.SANITIZE_ALL[, (bool)catchErrors=False]]) → SanitizeFlags :¶
Kekulize, check valencies, set aromaticity, conjugation and hybridization



The molecule is modified in place.
If sanitization fails, an exception will be thrown unless catchErrors is set


ARGUMENTS:


mol: the molecule to be modified
sanitizeOps: (optional) sanitization operations to be carried out
these should be constructed by or’ing together the
operations in rdkit.Chem.SanitizeFlags
catchErrors: (optional) if provided, instead of raising an exception
when sanitization fails (the default behavior), the 
first operation that failed (as defined in rdkit.Chem.SanitizeFlags)
is returned. Zero is returned on success.




C++ signature :RDKit::MolOps::SanitizeFlags SanitizeMol(RDKit::ROMol {lvalue} [,unsigned long=rdkit.Chem.rdmolops.SanitizeFlags.SANITIZE_ALL [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.SetAllowNontetrahedralChirality((bool)val) → None :¶
toggles recognition of non-tetrahedral chirality from 3D structures

C++ signature :void SetAllowNontetrahedralChirality(bool)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.SetAromaticity((Mol)mol[, (AromaticityModel)model=rdkit.Chem.rdmolops.AromaticityModel.AROMATICITY_DEFAULT]) → None :¶
does aromaticity perception

ARGUMENTS:


mol: the molecule to use
model: the model to use


NOTES:


The molecule is modified in place.




C++ signature :void SetAromaticity(RDKit::ROMol {lvalue} [,RDKit::MolOps::AromaticityModel=rdkit.Chem.rdmolops.AromaticityModel.AROMATICITY_DEFAULT])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.SetBondStereoFromDirections((Mol)mol) → None :¶
Uses the directions of neighboring bonds to set cis/trans stereo on double bonds.

ARGUMENTS:


mol: the molecule to be modified




C++ signature :void SetBondStereoFromDirections(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.SetConjugation((Mol)mol) → None :¶
finds conjugated bonds

ARGUMENTS:


mol: the molecule to use


NOTES:


The molecule is modified in place.




C++ signature :void SetConjugation(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.SetDoubleBondNeighborDirections((Mol)mol[, (AtomPairsParameters)conf=None]) → None :¶
Uses the stereo info on double bonds to set the directions of neighboring single bonds

ARGUMENTS:


mol: the molecule to be modified




C++ signature :void SetDoubleBondNeighborDirections(RDKit::ROMol {lvalue} [,boost::python::api::object=None])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.SetGenericQueriesFromProperties((Mol)mol[, (bool)useAtomLabels=True[, (bool)useSGroups=True]]) → None :¶
documentation

C++ signature :void SetGenericQueriesFromProperties(RDKit::ROMol {lvalue} [,bool=True [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.SetHybridization((Mol)mol) → None :¶
Assigns hybridization states to atoms

ARGUMENTS:


mol: the molecule to use


NOTES:


The molecule is modified in place.




C++ signature :void SetHybridization(RDKit::ROMol {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.SetTerminalAtomCoords((Mol)mol, (int)idx, (int)otherIdx) → None :¶
Sets Cartesian coordinates for a terminal atom.

Useful for growing an atom off a molecule with sensible 
coordinates based on the geometry of the neighbor.
NOTE: this sets the appropriate coordinates in all of the molecule’s conformers 
ARGUMENTS:


mol: the molecule the atoms belong to.
idx: index of the terminal atom whose coordinates are set.
mol: index of the bonded neighbor atom.


RETURNS: Nothing


C++ signature :void SetTerminalAtomCoords(RDKit::ROMol {lvalue},unsigned int,unsigned int)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.SetUseLegacyStereoPerception((bool)val) → None :¶
sets usage of the legacy stereo perception code

C++ signature :void SetUseLegacyStereoPerception(bool)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.SortMatchesByDegreeOfCoreSubstitution((Mol)mol, (Mol)core, (AtomPairsParameters)matches) → object :¶
Postprocesses the results of a mol.GetSubstructMatches(core) call 
where mol has explicit Hs and core bears terminal dummy atoms (i.e., R groups). 
It returns a copy of matches sorted by decreasing number of non-hydrogen matches 
to the terminal dummy atoms.

ARGUMENTS:


mol: the molecule GetSubstructMatches was run on
core: the molecule used as a substructure query
matches: the result returned by GetSubstructMatches



RETURNS: a copy of matches sorted by decreasing number of non-hydrogen matches to the terminal dummy atoms




C++ signature :_object* SortMatchesByDegreeOfCoreSubstitution(RDKit::ROMol,RDKit::ROMol,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.SplitMolByPDBChainId((Mol)mol[, (AtomPairsParameters)whiteList=None[, (bool)negateList=False]]) → dict :¶
Splits a molecule into pieces based on PDB chain information.

ARGUMENTS:


mol: the molecule to use
whiteList: only residues in this list will be returned
negateList: if set, negates the white list inclusion logic


RETURNS: a dictionary keyed by chain id with molecules as the values


C++ signature :boost::python::dict SplitMolByPDBChainId(RDKit::ROMol [,boost::python::api::object=None [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.SplitMolByPDBResidues((Mol)mol[, (AtomPairsParameters)whiteList=None[, (bool)negateList=False]]) → dict :¶
Splits a molecule into pieces based on PDB residue information.

ARGUMENTS:


mol: the molecule to use
whiteList: only residues in this list will be returned
negateList: if set, negates the white list inclusion logic


RETURNS: a dictionary keyed by residue name with molecules as the values


C++ signature :boost::python::dict SplitMolByPDBResidues(RDKit::ROMol [,boost::python::api::object=None [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.TranslateChiralFlagToStereoGroups((Mol)mol[, (StereoGroupType)zeroFlagGroupType=rdkit.Chem.rdchem.StereoGroupType.STEREO_AND]) → None :¶
Generate enhanced stereo groups based on the status of the chiral flag property.


Arguments:
mol: molecule to be modified

zeroFlagGroupType: how to handle non-grouped stereo centers when thechiral flag is set to zero






If the chiral flag is set to a value of 1 then all specified tetrahedral
chiral centers which are not already in StereoGroups will be added to an
ABS StereoGroup.
If the chiral flag is set to a value of 0 then all specified tetrahedral
chiral centers will be added to a StereoGroup of the type zeroFlagGroupType
If there is no chiral flag set (i.e. the property is not present), the
molecule will not be modified.


C++ signature :void TranslateChiralFlagToStereoGroups(RDKit::ROMol {lvalue} [,RDKit::StereoGroupType=rdkit.Chem.rdchem.StereoGroupType.STEREO_AND])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.UnfoldedRDKFingerprintCountBased((Mol)mol[, (int)minPath=1[, (int)maxPath=7[, (bool)useHs=True[, (bool)branchedPaths=True[, (bool)useBondOrder=True[, (AtomPairsParameters)atomInvariants=0[, (AtomPairsParameters)fromAtoms=0[, (AtomPairsParameters)atomBits=None[, (AtomPairsParameters)bitInfo=None]]]]]]]]]) → ULongSparseIntVect :¶
Returns an unfolded count-based version of the RDKit fingerprint for a molecule
ARGUMENTS:


mol: the molecule to use
minPath: (optional) minimum number of bonds to include in the subgraphs
Defaults to 1.
maxPath: (optional) maximum number of bonds to include in the subgraphs
Defaults to 7.
useHs: (optional) include paths involving Hs in the fingerprint if the molecule
has explicit Hs.
Defaults to True.
branchedPaths: (optional) if set both branched and unbranched paths will be
used in the fingerprint.
Defaults to True.
useBondOrder: (optional) if set both bond orders will be used in the path hashes
Defaults to True.
atomInvariants: (optional) a sequence of atom invariants to use in the path hashes
Defaults to empty.
fromAtoms: (optional) a sequence of atom indices. If provided, only paths/subgraphs 
starting from these atoms will be used.
Defaults to empty.
atomBits: (optional) an empty list. If provided, the result will contain a list 
containing the bits each atom sets.
Defaults to empty.
bitInfo: (optional) an empty dict. If provided, the result will contain a dict 
with bits as keys and corresponding bond paths as values.
Defaults to empty.



C++ signature :RDKit::SparseIntVect<unsigned long>* UnfoldedRDKFingerprintCountBased(RDKit::ROMol [,unsigned int=1 [,unsigned int=7 [,bool=True [,bool=True [,bool=True [,boost::python::api::object=0 [,boost::python::api::object=0 [,boost::python::api::object=None [,boost::python::api::object=None]]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.WedgeBond((Bond)bond, (int)fromAtomIdx, (Conformer)conf) → None :¶

Set the wedging on an individual bond from a molecule.
The wedging scheme used is that from Mol files.


ARGUMENTS:
bond: the bond to update
atom ID: the atom from which to do the wedging
conformer: the conformer to use to determine wedge direction




C++ signature :void WedgeBond(RDKit::Bond*,unsigned int,RDKit::Conformer const*)
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.WedgeMolBonds((Mol)mol, (Conformer)conformer[, (BondWedgingParameters)params=None]) → None :¶

Set the wedging on single bonds in a molecule.
The wedging scheme used is that from Mol files.

ARGUMENTS:


molecule: the molecule to update
conformer: the conformer to use to determine wedge direction



C++ signature :void WedgeMolBonds(RDKit::ROMol {lvalue},RDKit::Conformer const* [,RDKit::Chirality::BondWedgingParameters const*=None])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.molzip((Mol)a, (Mol)b[, (MolzipParams)params=<rdkit.Chem.rdmolops.MolzipParams object at 0x76141cd8d4e0>]) → Mol :¶
zip together two molecules using the given matching parameters


C++ signature :RDKit::ROMol* molzip(RDKit::ROMol,RDKit::ROMol [,RDKit::MolzipParams=<rdkit.Chem.rdmolops.MolzipParams object at 0x76141cd8d4e0>])




molzip( (Mol)a [, (MolzipParams)params=<rdkit.Chem.rdmolops.MolzipParams object at 0x76141cd8d590>]) -> Mol :zip together two molecules using the given matching parameters

C++ signature :RDKit::ROMol* molzip(RDKit::ROMol [,RDKit::MolzipParams=<rdkit.Chem.rdmolops.MolzipParams object at 0x76141cd8d590>])



molzip( (dict)row [, (MolzipParams)params=<rdkit.Chem.rdmolops.MolzipParams object at 0x76141cd8d6f0>]) -> Mol :zip an RGroupRow together to recreate the original molecule.  This correctly handles
broken cycles that can occur in decompositions.

example:
>>> from rdkit import Chem
>>> from rdkit.Chem import rdRGroupDecomposition as rgd
>>> core = Chem.MolFromSmiles('CO')
>>> mols = [Chem.MolFromSmiles('C1NNO1')]
>>> rgroups, unmatched = rgd.RGroupDecompose(core, mols)
>>> for rgroup in rgroups:
...     mol = rgd.molzip(rgroup)




C++ signature :RDKit::ROMol* molzip(boost::python::dict [,RDKit::MolzipParams=<rdkit.Chem.rdmolops.MolzipParams object at 0x76141cd8d6f0>])
--------------------------------------------------------------------------------
rdkit.Chem.rdmolops.molzipFragments((AtomPairsParameters)mols[, (MolzipParams)params=<rdkit.Chem.rdmolops.MolzipParams object at 0x76141cd8d640>]) → Mol :¶
zip together multiple molecules from an R group decomposition 
using the given matching parameters.  The first molecule in the list
must be the core

C++ signature :RDKit::ROMol* molzipFragments(boost::python::api::object {lvalue} [,RDKit::MolzipParams=<rdkit.Chem.rdmolops.MolzipParams object at 0x76141cd8d640>])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.CanonicalizeConformer((Conformer)conf[, (Point3D)center=None[, (bool)normalizeCovar=False[, (bool)ignoreHs=True]]]) → None :¶

Canonicalize the orientation of a conformer so that its principal axes
around the specified center point coincide with the x, y, z axes


ARGUMENTS:
conf : conformer of interest

centeroptionally center point about which the principal axes are computed if not specified the centroid of the conformer will be used



normalizeCovar : Optionally normalize the covariance matrix by the number of atoms




C++ signature :void CanonicalizeConformer(RDKit::Conformer {lvalue} [,RDGeom::Point3D const*=None [,bool=False [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.CanonicalizeMol((Mol)mol[, (bool)normalizeCovar=False[, (bool)ignoreHs=True]]) → None :¶
Loop over the conformers in a molecule and canonicalize their orientation

C++ signature :void CanonicalizeMol(RDKit::ROMol {lvalue} [,bool=False [,bool=True]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.ComputeCanonicalTransform((Conformer)conf[, (Point3D)center=None[, (bool)normalizeCovar=False[, (bool)ignoreHs=True]]]) → object :¶

Compute the transformation required aligna conformer so that
the principal axes align up with the x,y, z axes
The conformer itself is left unchanged


ARGUMENTS:
conf : the conformer of interest
center : optional center point to compute the principal axes around (defaults to the centroid)
normalizeCovar : optionally normalize the covariance matrix by the number of atoms




C++ signature :_object* ComputeCanonicalTransform(RDKit::Conformer [,RDGeom::Point3D const*=None [,bool=False [,bool=True]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.ComputeCentroid((Conformer)conf[, (bool)ignoreHs=True[, (_vectd)weights=None]]) → Point3D :¶

Compute the centroid of the conformation - hydrogens are ignored and no attentionis paid to the difference in sizes of the heavy atoms; however,
an optional vector of weights can be passed.

C++ signature :RDGeom::Point3D ComputeCentroid(RDKit::Conformer [,bool=True [,std::vector<double, std::allocator<double> > const*=None]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.ComputePrincipalAxesAndMoments((Conformer)conf[, (bool)ignoreHs=True[, (AtomPairsParameters)weights=None]]) → object :¶

Compute principal axes and moments of inertia for a conformer
These values are calculated from the inertia tensor:
Iij = - sum_{s=1..N}(w_s * r_{si} * r_{sj}) i != j
Iii = sum_{s=1..N} sum_{j!=i} (w_s * r_{sj} * r_{sj})
where the coordinates are relative to the center of mass.


ARGUMENTS:
conf : the conformer of interest
ignoreHs : if True, ignore hydrogen atoms
weights : if present, used to weight the atomic coordinates



Returns a (principal axes, principal moments) tuple

C++ signature :_object* ComputePrincipalAxesAndMoments(RDKit::Conformer [,bool=True [,boost::python::api::object=None]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.ComputePrincipalAxesAndMomentsFromGyrationMatrix((Conformer)conf[, (bool)ignoreHs=True[, (AtomPairsParameters)weights=None]]) → object :¶

Compute principal axes and moments from the gyration matrix of a conformer
These values are calculated from the gyration matrix/tensor:
Iij = sum_{s=1..N}(w_s * r_{si} * r_{sj}) i != j
Iii = sum_{s=1..N} sum_{t!=s}(w_s * r_{si} * r_{ti})
where the coordinates are relative to the center of mass.


ARGUMENTS:
conf : the conformer of interest
ignoreHs : if True, ignore hydrogen atoms
weights : if present, used to weight the atomic coordinates



Returns a (principal axes, principal moments) tuple

C++ signature :_object* ComputePrincipalAxesAndMomentsFromGyrationMatrix(RDKit::Conformer [,bool=True [,boost::python::api::object=None]])
--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.GetAngleDeg((Conformer)conf, (int)iAtomId, (int)jAtomId, (int)kAtomId) → float :¶
Returns the angle in degrees between atoms i, j, k

C++ signature :double GetAngleDeg(RDKit::Conformer,unsigned int,unsigned int,unsigned int)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.GetAngleRad((Conformer)conf, (int)iAtomId, (int)jAtomId, (int)kAtomId) → float :¶
Returns the angle in radians between atoms i, j, k

C++ signature :double GetAngleRad(RDKit::Conformer,unsigned int,unsigned int,unsigned int)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.GetBondLength((Conformer)conf, (int)iAtomId, (int)jAtomId) → float :¶
Returns the bond length in angstrom between atoms i, j

C++ signature :double GetBondLength(RDKit::Conformer,unsigned int,unsigned int)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.GetDihedralDeg((Conformer)conf, (int)iAtomId, (int)jAtomId, (int)kAtomId, (int)lAtomId) → float :¶
Returns the dihedral angle in degrees between atoms i, j, k, l

C++ signature :double GetDihedralDeg(RDKit::Conformer,unsigned int,unsigned int,unsigned int,unsigned int)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.GetDihedralRad((Conformer)conf, (int)iAtomId, (int)jAtomId, (int)kAtomId, (int)lAtomId) → float :¶
Returns the dihedral angle in radians between atoms i, j, k, l

C++ signature :double GetDihedralRad(RDKit::Conformer,unsigned int,unsigned int,unsigned int,unsigned int)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.SetAngleDeg((Conformer)conf, (int)iAtomId, (int)jAtomId, (int)kAtomId, (float)value) → None :¶
Sets the angle in degrees between atoms i, j, k; all atoms bonded to atom k are moved

C++ signature :void SetAngleDeg(RDKit::Conformer {lvalue},unsigned int,unsigned int,unsigned int,double)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.SetAngleRad((Conformer)conf, (int)iAtomId, (int)jAtomId, (int)kAtomId, (float)value) → None :¶
Sets the angle in radians between atoms i, j, k; all atoms bonded to atom k are moved

C++ signature :void SetAngleRad(RDKit::Conformer {lvalue},unsigned int,unsigned int,unsigned int,double)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.SetBondLength((Conformer)conf, (int)iAtomId, (int)jAtomId, (float)value) → None :¶
Sets the bond length in angstrom between atoms i, j; all atoms bonded to atom j are moved

C++ signature :void SetBondLength(RDKit::Conformer {lvalue},unsigned int,unsigned int,double)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.SetDihedralDeg((Conformer)conf, (int)iAtomId, (int)jAtomId, (int)kAtomId, (int)lAtomId, (float)value) → None :¶
Sets the dihedral angle in degrees between atoms i, j, k, l; all atoms bonded to atom l are moved

C++ signature :void SetDihedralDeg(RDKit::Conformer {lvalue},unsigned int,unsigned int,unsigned int,unsigned int,double)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.SetDihedralRad((Conformer)conf, (int)iAtomId, (int)jAtomId, (int)kAtomId, (int)lAtomId, (float)value) → None :¶
Sets the dihedral angle in radians between atoms i, j, k, l; all atoms bonded to atom l are moved

C++ signature :void SetDihedralRad(RDKit::Conformer {lvalue},unsigned int,unsigned int,unsigned int,unsigned int,double)
--------------------------------------------------------------------------------
rdkit.Chem.rdMolTransforms.TransformConformer((Conformer)conf, (AtomPairsParameters)trans) → None :¶
Transform the coordinates of a conformer

C++ signature :void TransformConformer(RDKit::Conformer {lvalue},boost::python::api::object)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdPartialCharges.ComputeGasteigerCharges((Mol)mol[, (int)nIter=12[, (bool)throwOnParamFailure=False]]) → None :¶
Compute Gasteiger partial charges for molecule

The charges are computed using an iterative procedure presented in
Ref : J.Gasteiger, M. Marseli, Iterative Equalization of Oribital Electronegatiity 
A Rapid Access to Atomic Charges, Tetrahedron Vol 36 p3219 1980
The computed charges are stored on each atom are stored a computed property ( under the name 
_GasteigerCharge). In addition, each atom also stored the total charge for the implicit hydrogens 
on the atom (under the property name _GasteigerHCharge)
ARGUMENTS:


mol : the molecule of interrest
nIter : number of iteration (defaults to 12)
throwOnParamFailure : toggles whether or not an exception should be raised if parameters
for an atom cannot be found.  If this is false (the default), all parameters for unknown
atoms will be set to zero.  This has the effect of removing that atom from the iteration.




C++ signature :void ComputeGasteigerCharges(RDKit::ROMol [,int=12 [,bool=False]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.AAtomQueryAtom([(bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms when AAtom is True.

C++ signature :RDKit::QueryAtom* AAtomQueryAtom([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.AHAtomQueryAtom([(bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms when AHAtom is True.

C++ signature :RDKit::QueryAtom* AHAtomQueryAtom([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.AtomNumEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where AtomNum is equal to the target value.

C++ signature :RDKit::QueryAtom* AtomNumEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.AtomNumGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where AtomNum is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* AtomNumGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.AtomNumLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where AtomNum is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* AtomNumLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.ExplicitDegreeEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where ExplicitDegree is equal to the target value.

C++ signature :RDKit::QueryAtom* ExplicitDegreeEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.ExplicitDegreeGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where ExplicitDegree is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* ExplicitDegreeGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.ExplicitDegreeLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where ExplicitDegree is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* ExplicitDegreeLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.ExplicitValenceEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where ExplicitValence is equal to the target value.

C++ signature :RDKit::QueryAtom* ExplicitValenceEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.ExplicitValenceGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where ExplicitValence is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* ExplicitValenceGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.ExplicitValenceLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where ExplicitValence is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* ExplicitValenceLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.FormalChargeEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where FormalCharge is equal to the target value.

C++ signature :RDKit::QueryAtom* FormalChargeEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.FormalChargeGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where FormalCharge is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* FormalChargeGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.FormalChargeLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where FormalCharge is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* FormalChargeLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HCountEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where HCount is equal to the target value.

C++ signature :RDKit::QueryAtom* HCountEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HCountGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where HCount is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* HCountGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HCountLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where HCount is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* HCountLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HasBitVectPropWithValueQueryAtom((str)propname, (ExplicitBitVect)val[, (bool)negate=False[, (float)tolerance=0]]) → QueryAtom :¶
Returns a QueryAtom that matches when the property ‘propname’ has the specified explicit bit vector value.  The Tolerance is the allowed Tanimoto difference

C++ signature :RDKit::QueryAtom* HasBitVectPropWithValueQueryAtom(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,ExplicitBitVect [,bool=False [,float=0]])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HasBoolPropWithValueQueryAtom((str)propname, (bool)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches when the property ‘propname’ has the specified boolean value.

C++ signature :RDKit::QueryAtom* HasBoolPropWithValueQueryAtom(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HasBoolPropWithValueQueryBond((str)propname, (bool)val[, (bool)negate=False]) → QueryBond :¶
Returns a QueryBond that matches when the property ‘propname’ has the specified boolean value.

C++ signature :RDKit::QueryBond* HasBoolPropWithValueQueryBond(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HasChiralTagQueryAtom([(bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms when HasChiralTag is True.

C++ signature :RDKit::QueryAtom* HasChiralTagQueryAtom([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HasDoublePropWithValueQueryAtom((str)propname, (float)val[, (bool)negate=False[, (float)tolerance=0.0]]) → QueryAtom :¶
Returns a QueryAtom that matches when the property ‘propname’ has the specified value +- tolerance

C++ signature :RDKit::QueryAtom* HasDoublePropWithValueQueryAtom(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,double [,bool=False [,double=0.0]])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HasDoublePropWithValueQueryBond((str)propname, (float)val[, (bool)negate=False[, (float)tolerance=0.0]]) → QueryBond :¶
Returns a QueryBond that matches when the property ‘propname’ has the specified value +- tolerance

C++ signature :RDKit::QueryBond* HasDoublePropWithValueQueryBond(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,double [,bool=False [,double=0.0]])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HasIntPropWithValueQueryAtom((str)propname, (int)val[, (bool)negate=False[, (int)tolerance=0]]) → QueryAtom :¶
Returns a QueryAtom that matches when the property ‘propname’ has the specified int value.

C++ signature :RDKit::QueryAtom* HasIntPropWithValueQueryAtom(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,int [,bool=False [,int=0]])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HasIntPropWithValueQueryBond((str)propname, (int)val[, (bool)negate=False[, (int)tolerance=0]]) → QueryBond :¶
Returns a QueryBond that matches when the property ‘propname’ has the specified int value.

C++ signature :RDKit::QueryBond* HasIntPropWithValueQueryBond(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,int [,bool=False [,int=0]])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HasPropQueryAtom((str)propname[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches when the property ‘propname’ exists in the atom.

C++ signature :RDKit::QueryAtom* HasPropQueryAtom(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HasPropQueryBond((str)propname[, (bool)negate=False]) → QueryBond :¶
Returns a QueryBond that matches when the property ‘propname’ exists in the bond.


C++ signature :RDKit::QueryBond* HasPropQueryBond(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=False])




HasPropQueryBond( (str)propname [, (bool)negate=False]) -> QueryBond :Returns a QueryBond that matches when the property ‘propname’ exists in the bond.

C++ signature :RDKit::QueryBond* HasPropQueryBond(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=False])



HasPropQueryBond( (str)propname [, (bool)negate=False]) -> QueryBond :Returns a QueryBond that matches when the property ‘propname’ exists in the bond.

C++ signature :RDKit::QueryBond* HasPropQueryBond(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HasStringPropWithValueQueryAtom((str)propname, (str)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches when the property ‘propname’ has the specified string value.

C++ signature :RDKit::QueryAtom* HasStringPropWithValueQueryAtom(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HasStringPropWithValueQueryBond((str)propname, (str)val[, (bool)negate=False]) → QueryBond :¶
Returns a QueryBond that matches when the property ‘propname’ has the specified string value.

C++ signature :RDKit::QueryBond* HasStringPropWithValueQueryBond(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HybridizationEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where Hybridization is equal to the target value.

C++ signature :RDKit::QueryAtom* HybridizationEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HybridizationGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where Hybridization is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* HybridizationGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.HybridizationLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where Hybridization is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* HybridizationLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.InNRingsEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where InNRings is equal to the target value.

C++ signature :RDKit::QueryAtom* InNRingsEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.InNRingsGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where InNRings is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* InNRingsGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.InNRingsLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where InNRings is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* InNRingsLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.IsAliphaticQueryAtom([(bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms when IsAliphatic is True.

C++ signature :RDKit::QueryAtom* IsAliphaticQueryAtom([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.IsAromaticQueryAtom([(bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms when IsAromatic is True.

C++ signature :RDKit::QueryAtom* IsAromaticQueryAtom([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.IsBridgeheadQueryAtom([(bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms when IsBridgehead is True.

C++ signature :RDKit::QueryAtom* IsBridgeheadQueryAtom([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.IsInRingQueryAtom([(bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms when IsInRing is True.

C++ signature :RDKit::QueryAtom* IsInRingQueryAtom([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.IsUnsaturatedQueryAtom([(bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms when IsUnsaturated is True.

C++ signature :RDKit::QueryAtom* IsUnsaturatedQueryAtom([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.IsotopeEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where Isotope is equal to the target value.

C++ signature :RDKit::QueryAtom* IsotopeEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.IsotopeGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where Isotope is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* IsotopeGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.IsotopeLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where Isotope is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* IsotopeLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.MAtomQueryAtom([(bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms when MAtom is True.

C++ signature :RDKit::QueryAtom* MAtomQueryAtom([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.MHAtomQueryAtom([(bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms when MHAtom is True.

C++ signature :RDKit::QueryAtom* MHAtomQueryAtom([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.MassEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where Mass is equal to the target value.

C++ signature :RDKit::QueryAtom* MassEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.MassGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where Mass is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* MassGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.MassLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where Mass is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* MassLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.MinRingSizeEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where MinRingSize is equal to the target value.

C++ signature :RDKit::QueryAtom* MinRingSizeEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.MinRingSizeGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where MinRingSize is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* MinRingSizeGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.MinRingSizeLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where MinRingSize is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* MinRingSizeLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.MissingChiralTagQueryAtom([(bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms when MissingChiralTag is True.

C++ signature :RDKit::QueryAtom* MissingChiralTagQueryAtom([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.NonHydrogenDegreeEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where NonHydrogenDegree is equal to the target value.

C++ signature :RDKit::QueryAtom* NonHydrogenDegreeEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.NonHydrogenDegreeGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where NonHydrogenDegree is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* NonHydrogenDegreeGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.NonHydrogenDegreeLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where NonHydrogenDegree is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* NonHydrogenDegreeLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.NumAliphaticHeteroatomNeighborsEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where NumAliphaticHeteroatomNeighbors is equal to the target value.

C++ signature :RDKit::QueryAtom* NumAliphaticHeteroatomNeighborsEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.NumAliphaticHeteroatomNeighborsGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where NumAliphaticHeteroatomNeighbors is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* NumAliphaticHeteroatomNeighborsGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.NumAliphaticHeteroatomNeighborsLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where NumAliphaticHeteroatomNeighbors is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* NumAliphaticHeteroatomNeighborsLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.NumHeteroatomNeighborsEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where NumHeteroatomNeighbors is equal to the target value.

C++ signature :RDKit::QueryAtom* NumHeteroatomNeighborsEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.NumHeteroatomNeighborsGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where NumHeteroatomNeighbors is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* NumHeteroatomNeighborsGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.NumHeteroatomNeighborsLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where NumHeteroatomNeighbors is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* NumHeteroatomNeighborsLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.NumRadicalElectronsEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where NumRadicalElectrons is equal to the target value.

C++ signature :RDKit::QueryAtom* NumRadicalElectronsEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.NumRadicalElectronsGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where NumRadicalElectrons is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* NumRadicalElectronsGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.NumRadicalElectronsLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where NumRadicalElectrons is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* NumRadicalElectronsLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.QAtomQueryAtom([(bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms when QAtom is True.

C++ signature :RDKit::QueryAtom* QAtomQueryAtom([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.QHAtomQueryAtom([(bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms when QHAtom is True.

C++ signature :RDKit::QueryAtom* QHAtomQueryAtom([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.ReplaceAtomWithQueryAtom((Mol)mol, (Atom)atom) → Atom :¶
Changes the given atom in the molecule to
a query atom and returns the atom which can then be modified, for example
with additional query constraints added.  The new atom is otherwise a copy
of the old.
If the atom already has a query, nothing will be changed.

C++ signature :RDKit::Atom* ReplaceAtomWithQueryAtom(RDKit::ROMol {lvalue},RDKit::Atom {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.RingBondCountEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where RingBondCount is equal to the target value.

C++ signature :RDKit::QueryAtom* RingBondCountEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.RingBondCountGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where RingBondCount is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* RingBondCountGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.RingBondCountLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where RingBondCount is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* RingBondCountLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.TotalDegreeEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where TotalDegree is equal to the target value.

C++ signature :RDKit::QueryAtom* TotalDegreeEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.TotalDegreeGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where TotalDegree is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* TotalDegreeGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.TotalDegreeLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where TotalDegree is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* TotalDegreeLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.TotalValenceEqualsQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where TotalValence is equal to the target value.

C++ signature :RDKit::QueryAtom* TotalValenceEqualsQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.TotalValenceGreaterQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where TotalValence is equal to the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* TotalValenceGreaterQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.TotalValenceLessQueryAtom((int)val[, (bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms where TotalValence is less than the target value.
NOTE: the direction of comparison is reversed relative to the C++ API

C++ signature :RDKit::QueryAtom* TotalValenceLessQueryAtom(int [,bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.XAtomQueryAtom([(bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms when XAtom is True.

C++ signature :RDKit::QueryAtom* XAtomQueryAtom([ bool=False])
--------------------------------------------------------------------------------
rdkit.Chem.rdqueries.XHAtomQueryAtom([(bool)negate=False]) → QueryAtom :¶
Returns a QueryAtom that matches atoms when XHAtom is True.

C++ signature :RDKit::QueryAtom* XHAtomQueryAtom([ bool=False])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdReducedGraphs.GenerateErGFingerprintForReducedGraph((Mol)mol[, (AtomPairsParameters)atomTypes=0[, (float)fuzzIncrement=0.3[, (int)minPath=1[, (int)maxPath=15]]]]) → object :¶
Returns the ErG fingerprint vector for a reduced graph

C++ signature :_object* GenerateErGFingerprintForReducedGraph(RDKit::ROMol [,boost::python::api::object=0 [,double=0.3 [,int=1 [,int=15]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdReducedGraphs.GenerateMolExtendedReducedGraph((Mol)mol[, (AtomPairsParameters)atomTypes=0]) → Mol :¶
Returns the reduced graph for a molecule

C++ signature :RDKit::ROMol* GenerateMolExtendedReducedGraph(RDKit::ROMol [,boost::python::api::object=0])
--------------------------------------------------------------------------------
rdkit.Chem.rdReducedGraphs.GetErGFingerprint((Mol)mol[, (AtomPairsParameters)atomTypes=0[, (float)fuzzIncrement=0.3[, (int)minPath=1[, (int)maxPath=15]]]]) → object :¶
Returns the ErG fingerprint vector for a molecule

C++ signature :_object* GetErGFingerprint(RDKit::ROMol [,boost::python::api::object=0 [,double=0.3 [,int=1 [,int=15]]]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdRGroupDecomposition.RGroupDecompose((AtomPairsParameters)cores, (AtomPairsParameters)mols[, (bool)asSmiles=False[, (bool)asRows=True[, (RGroupDecompositionParameters)options=<rdkit.Chem.rdRGroupDecomposition.RGroupDecompositionParameters object at 0x7614109e9690>]]]) → object :¶

Decompose a collecion of molecules into their Rgroups
ARGUMENTS:

cores: a set of cores from most to least specific.See RGroupDecompositionParameters for more details
on how the cores can be labelled



mols: the molecules to be decomposed
asSmiles: if True return smiles strings, otherwise return molecules [default: False]
asRows: return the results as rows (default) otherwise return columns



RETURNS: row_or_column_results, unmatched


Row structure:rows[idx] = {rgroup_label: molecule_or_smiles}

Column structure:columns[rgroup_label] = [ mols_or_smiles ]


unmatched is a vector of indices in the input mols that were not matched.


C++ signature :boost::python::api::object RGroupDecompose(boost::python::api::object,boost::python::api::object [,bool=False [,bool=True [,RDKit::RGroupDecompositionParameters=<rdkit.Chem.rdRGroupDecomposition.RGroupDecompositionParameters object at 0x7614109e9690>]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdRGroupDecomposition.RelabelMappedDummies((Mol)mol[, (int)inputLabels=rdkit.Chem.rdRGroupDecomposition.RGroupLabelling(7)[, (int)outputLabels=rdkit.Chem.rdRGroupDecomposition.RGroupLabelling.MDLRGroup]]) → None :¶
Relabel dummy atoms bearing an R-group mapping (as
atom map number, isotope or MDLRGroup label) such that
they will be displayed by the rendering code as R# rather
than #*, :#, #:#, etc. By default, only the MDLRGroup label
is retained on output; this may be configured through the
outputLabels parameter.
In case there are multiple potential R-group mappings,
the priority on input is Atom map number > Isotope > MDLRGroup.
The inputLabels parameter allows to configure which mappings
are taken into consideration.

C++ signature :void RelabelMappedDummies(RDKit::ROMol {lvalue} [,unsigned int=rdkit.Chem.rdRGroupDecomposition.RGroupLabelling(7) [,unsigned int=rdkit.Chem.rdRGroupDecomposition.RGroupLabelling.MDLRGroup]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdShapeHelpers.ComputeConfBox((Conformer)conf[, (AtomPairsParameters)trans=None[, (float)padding=2.0]]) → tuple :¶
Compute the lower and upper corners of a cuboid that will fit the conformer

C++ signature :boost::python::tuple ComputeConfBox(RDKit::Conformer [,boost::python::api::object=None [,double=2.0]])
--------------------------------------------------------------------------------
rdkit.Chem.rdShapeHelpers.ComputeConfDimsAndOffset((Conformer)conf[, (AtomPairsParameters)trans=None[, (float)padding=2.0]]) → tuple :¶

Compute the size of the box that can fit the conformations, and offset of the box from the origin

C++ signature :boost::python::tuple ComputeConfDimsAndOffset(RDKit::Conformer [,boost::python::api::object=None [,double=2.0]])
--------------------------------------------------------------------------------
rdkit.Chem.rdShapeHelpers.ComputeUnionBox((tuple)box1, (tuple)box2) → tuple :¶

Compute the union of two boxes, so that all the points in both boxes are contained in the new box

C++ signature :boost::python::tuple ComputeUnionBox(boost::python::tuple,boost::python::tuple)
--------------------------------------------------------------------------------
rdkit.Chem.rdShapeHelpers.EncodeShape((Mol)mol, (UniformGrid3D_)grid[, (int)confId=-1[, (AtomPairsParameters)trans=None[, (float)vdwScale=0.8[, (float)stepSize=0.25[, (int)maxLayers=-1[, (bool)ignoreHs=True]]]]]]) → None :¶
Encode the shape of a molecule (one of its conformer) onto a grid

ARGUMENTS:


mol : the molecule of interest
grid : grid onto which the encoding is written
confId : id of the conformation of interest on mol (defaults to the first one)
trans : any transformation that needs to be used to encode onto the grid (note the molecule remains unchanged)

vdwScaleScaling factor for the radius of the atoms to determine the base radius used in the encoding - grid points inside this sphere carry the maximum occupancy




setpSizethickness of the layers outside the base radius, the occupancy value is decreased from layer to layer from the maximum value




maxLayersthe maximum number of layers - defaults to the number of bits used per grid point - e.g. two bits per grid point will allow 3 layers



ignoreHs : when set, the contribution of Hs to the shape will be ignored




C++ signature :void EncodeShape(RDKit::ROMol,RDGeom::UniformGrid3D {lvalue} [,int=-1 [,boost::python::api::object=None [,double=0.8 [,double=0.25 [,int=-1 [,bool=True]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdShapeHelpers.ShapeProtrudeDist((Mol)mol1, (Mol)mol2[, (int)confId1=-1[, (int)confId2=-1[, (float)gridSpacing=0.5[, (DiscreteValueType)bitsPerPoint=rdkit.DataStructs.cDataStructs.DiscreteValueType.TWOBITVALUE[, (float)vdwScale=0.8[, (float)stepSize=0.25[, (int)maxLayers=-1[, (bool)ignoreHs=True[, (bool)allowReordering=True]]]]]]]]]) → float :¶
Compute the shape protrude distance between two molecule based on a predefined alignment


ARGUMENTS:
mol1 : The first molecule of interest
mol2 : The second molecule of interest
confId1 : Conformer in the first molecule (defaults to first conformer)
confId2 : Conformer in the second molecule (defaults to first conformer)
gridSpacing : resolution of the grid used to encode the molecular shapes

bitsPerPointnumber of bit used to encode the occupancy at each grid point defaults to two bits per grid point




vdwScaleScaling factor for the radius of the atoms to determine the base radius used in the encoding - grid points inside this sphere carry the maximum occupancy




stepSizethickness of the each layer outside the base radius, the occupancy value is decreased from layer to layer from the maximum value




maxLayersthe maximum number of layers - defaults to the number of bits used per grid point - e.g. two bits per grid point will allow 3 layers



ignoreHs : when set, the contribution of Hs to the shape will be ignored

allowReorderingwhen set, the order will be automatically updated so that the value calculatedis the protrusion of the smaller shape from the larger one.








C++ signature :double ShapeProtrudeDist(RDKit::ROMol,RDKit::ROMol [,int=-1 [,int=-1 [,double=0.5 [,RDKit::DiscreteValueVect::DiscreteValueType=rdkit.DataStructs.cDataStructs.DiscreteValueType.TWOBITVALUE [,double=0.8 [,double=0.25 [,int=-1 [,bool=True [,bool=True]]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdShapeHelpers.ShapeTanimotoDist((Mol)mol1, (Mol)mol2[, (int)confId1=-1[, (int)confId2=-1[, (float)gridSpacing=0.5[, (DiscreteValueType)bitsPerPoint=rdkit.DataStructs.cDataStructs.DiscreteValueType.TWOBITVALUE[, (float)vdwScale=0.8[, (float)stepSize=0.25[, (int)maxLayers=-1[, (bool)ignoreHs=True]]]]]]]]) → float :¶
Compute the shape tanimoto distance between two molecule based on a predefined alignment


ARGUMENTS:
mol1 : The first molecule of interest
mol2 : The second molecule of interest
confId1 : Conformer in the first molecule (defaults to first conformer)
confId2 : Conformer in the second molecule (defaults to first conformer)
gridSpacing : resolution of the grid used to encode the molecular shapes

bitsPerPointnumber of bits used to encode the occupancy at each grid point defaults to two bits per grid point




vdwScaleScaling factor for the radius of the atoms to determine the base radius used in the encoding - grid points inside this sphere carry the maximum occupancy




stepSizethickness of the each layer outside the base radius, the occupancy value is decreased from layer to layer from the maximum value




maxLayersthe maximum number of layers - defaults to the number of bits used per grid point - e.g. two bits per grid point will allow 3 layers



ignoreHs : when set, the contribution of Hs to the shape will be ignored





C++ signature :double ShapeTanimotoDist(RDKit::ROMol,RDKit::ROMol [,int=-1 [,int=-1 [,double=0.5 [,RDKit::DiscreteValueVect::DiscreteValueType=rdkit.DataStructs.cDataStructs.DiscreteValueType.TWOBITVALUE [,double=0.8 [,double=0.25 [,int=-1 [,bool=True]]]]]]]])
--------------------------------------------------------------------------------
rdkit.Chem.rdShapeHelpers.ShapeTverskyIndex((Mol)mol1, (Mol)mol2, (float)alpha, (float)beta[, (int)confId1=-1[, (int)confId2=-1[, (float)gridSpacing=0.5[, (DiscreteValueType)bitsPerPoint=rdkit.DataStructs.cDataStructs.DiscreteValueType.TWOBITVALUE[, (float)vdwScale=0.8[, (float)stepSize=0.25[, (int)maxLayers=-1[, (bool)ignoreHs=True]]]]]]]]) → float :¶
Compute the shape tversky index between two molecule based on a predefined alignment


ARGUMENTS:
mol1 : The first molecule of interest
mol2 : The second molecule of interest
alpha : first parameter of the Tversky index
beta : second parameter of the Tversky index
confId1 : Conformer in the first molecule (defaults to first conformer)
confId2 : Conformer in the second molecule (defaults to first conformer)
gridSpacing : resolution of the grid used to encode the molecular shapes

bitsPerPointnumber of bits used to encode the occupancy at each grid point defaults to two bits per grid point




vdwScaleScaling factor for the radius of the atoms to determine the base radius used in the encoding - grid points inside this sphere carry the maximum occupancy




stepSizethickness of the each layer outside the base radius, the occupancy value is decreased from layer to layer from the maximum value




maxLayersthe maximum number of layers - defaults to the number of bits used per grid point - e.g. two bits per grid point will allow 3 layers



ignoreHs : when set, the contribution of Hs to the shape will be ignored





C++ signature :double ShapeTverskyIndex(RDKit::ROMol,RDKit::ROMol,double,double [,int=-1 [,int=-1 [,double=0.5 [,RDKit::DiscreteValueVect::DiscreteValueType=rdkit.DataStructs.cDataStructs.DiscreteValueType.TWOBITVALUE [,double=0.8 [,double=0.25 [,int=-1 [,bool=True]]]]]]]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdSLNParse.MolFromQuerySLN((str)SLN[, (bool)mergeHs=True[, (bool)debugParser=False]]) → Mol :¶
Construct a query molecule from an SLN string.

ARGUMENTS:


SLN: the SLN string
mergeHs: (optional) toggles the merging of explicit Hs in the query into the attached
heavy atoms. Defaults to False.


RETURNS:

a Mol object suitable for using in substructure queries, None on failure.



C++ signature :RDKit::ROMol* MolFromQuerySLN(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=True [,bool=False]])
--------------------------------------------------------------------------------
rdkit.Chem.rdSLNParse.MolFromSLN((str)SLN[, (bool)sanitize=True[, (bool)debugParser=False]]) → Mol :¶
Construct a molecule from an SLN string.


ARGUMENTS:

SLN: the SLN string
sanitize: (optional) toggles sanitization of the molecule.
Defaults to True.


RETURNS:

a Mol object, None on failure.


NOTE: the SLN should not contain query information or properties. To build aquery from SLN, use MolFromQuerySLN.




C++ signature :RDKit::ROMol* MolFromSLN(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=True [,bool=False]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdSubstructLibrary.AddPatterns((SubstructLibrary)sslib[, (int)numThreads=1]) → None :¶
Add pattern fingerprints to the given library, use numThreads=-1 to use all available cores


C++ signature :void AddPatterns(RDKit::SubstructLibraryWrap {lvalue} [,int=1])




AddPatterns( (SubstructLibrary)sslib, (FPHolderBase)patterns [, (int)numThreads=1]) -> None :Add pattern fingerprints to the given library, use numThreads=-1 to use all available cores

C++ signature :void AddPatterns(RDKit::SubstructLibraryWrap {lvalue},boost::shared_ptr<RDKit::FPHolderBase> [,int=1])
--------------------------------------------------------------------------------
rdkit.Chem.rdSubstructLibrary.SubstructLibraryCanSerialize() → bool :¶
Returns True if the SubstructLibrary is serializable (requires boost serialization

C++ signature :bool SubstructLibraryCanSerialize()
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdTautomerQuery.PatternFingerprintTautomerTarget((Mol)target[, (int)fingerprintSize=2048]) → ExplicitBitVect :¶

C++ signature :ExplicitBitVect* PatternFingerprintTautomerTarget(RDKit::ROMol [,unsigned int=2048])
--------------------------------------------------------------------------------
rdkit.Chem.rdTautomerQuery.TautomerQueryCanSerialize() → bool :¶
Returns True if the TautomerQuery is serializable (requires that the RDKit was built with boost::serialization)

C++ signature :bool TautomerQueryCanSerialize()
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.rdtrajectory.ReadAmberTrajectory((str)fName, (Trajectory)traj) → int :¶
reads coordinates from an AMBER trajectory file into the Trajectory object; returns the number of Snapshot objects read in

C++ signature :unsigned int ReadAmberTrajectory(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,RDKit::Trajectory {lvalue})
--------------------------------------------------------------------------------
rdkit.Chem.rdtrajectory.ReadGromosTrajectory((str)fName, (Trajectory)traj) → int :¶
reads coordinates from a GROMOS trajectory file into the Trajectory object; returns the number of Snapshot objects read in

C++ signature :unsigned int ReadGromosTrajectory(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,RDKit::Trajectory {lvalue})
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Recap.RecapDecompose(mol, allNodes=None, minFragmentSize=0, onlyUseReactions=None)¶
returns the recap decomposition for a molecule
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.ReducedGraphs.TanimotoSimilarity(arr1, arr2)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.RegistrationHash.GetMolHash(all_layers, hash_scheme: HashScheme = HashScheme.ALL_LAYERS) → str¶
Generate a molecular hash using a specified set of layers.

Parameters:

all_layers – a dictionary of layers
hash_scheme – enum encoding information layers for the hash


Returns:
hash for the given scheme constructed from the input layers
--------------------------------------------------------------------------------
rdkit.Chem.RegistrationHash.GetMolLayers(original_molecule: Mol, data_field_names: Iterable | None = None, escape: str | None = None, cxflag=1089, enable_tautomer_hash_v2=False) → {<HashLayer.NO_STEREO_SMILES: 4>, <HashLayer.FORMULA: 3>, <HashLayer.CANONICAL_SMILES: 1>, <HashLayer.NO_STEREO_TAUTOMER_HASH: 5>, <HashLayer.SGROUP_DATA: 6>, <HashLayer.TAUTOMER_HASH: 7>, <HashLayer.ESCAPE: 2>}¶
Generate layers of data about that could be used to identify a molecule

Parameters:

original_molecule – molecule to obtain canonicalization layers from
data_field_names – optional sequence of names of SGroup DAT fields which
will be included in the hash.
escape – optional field which can contain arbitrary information
enable_tautomer_hash_v2 – use v2 of the tautomer hash


Returns:
dictionary of HashLayer enum to calculated hash
--------------------------------------------------------------------------------
rdkit.Chem.RegistrationHash.GetNoStereoLayers(mol, enable_tautomer_hash_v2=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.RegistrationHash.GetStereoTautomerHash(molecule, cxflag=1089, enable_tautomer_hash_v2=False)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.SATIS.SATISTypes(mol, neighborsToInclude=4)¶
returns SATIS codes for all atoms in a molecule
The SATIS definition used is from:
J. Chem. Inf. Comput. Sci. _39_ 751-757 (1999)
each SATIS code is a string consisting of _neighborsToInclude_ + 1
2 digit numbers
Arguments


mol: a molecule
neighborsToInclude (optional): the number of neighbors to include
in the SATIS codes


Returns

a list of strings nAtoms long
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Scaffolds.MurckoScaffold.GetScaffoldForMol(mol)¶
Return molecule object containing scaffold of mol
>>> m = Chem.MolFromSmiles('Cc1ccccc1')
>>> GetScaffoldForMol(m)
<rdkit.Chem.rdchem.Mol object at 0x...>
>>> Chem.MolToSmiles(GetScaffoldForMol(m))
'c1ccccc1'


>>> m = Chem.MolFromSmiles('Cc1cc(Oc2nccc(CCC)c2)ccc1')
>>> Chem.MolToSmiles(GetScaffoldForMol(m))
'c1ccc(Oc2ccccn2)cc1'
--------------------------------------------------------------------------------
rdkit.Chem.Scaffolds.MurckoScaffold.MakeScaffoldGeneric(mol)¶
Makes a Murcko scaffold generic (i.e. all atom types->C and all bonds ->single
>>> Chem.MolToSmiles(MakeScaffoldGeneric(Chem.MolFromSmiles('c1ccccc1')))
'C1CCCCC1'
>>> Chem.MolToSmiles(MakeScaffoldGeneric(Chem.MolFromSmiles('c1ncccc1')))
'C1CCCCC1'


The following were associated with sf.net issue 246
>>> Chem.MolToSmiles(MakeScaffoldGeneric(Chem.MolFromSmiles(‘c1[nH]ccc1’)))
‘C1CCCC1’
>>> Chem.MolToSmiles(MakeScaffoldGeneric(Chem.MolFromSmiles(‘C1[NH2+]C1’)))
‘C1CC1’
>>> Chem.MolToSmiles(MakeScaffoldGeneric(Chem.MolFromSmiles(‘C1[C@](Cl)(F)O1’)))
‘CC1(C)CC1’
--------------------------------------------------------------------------------
rdkit.Chem.Scaffolds.MurckoScaffold.MurckoScaffoldSmiles(smiles=None, mol=None, includeChirality=False)¶
Returns MurckScaffold Smiles from smiles
>>> MurckoScaffoldSmiles('Cc1cc(Oc2nccc(CCC)c2)ccc1')
'c1ccc(Oc2ccccn2)cc1'


>>> MurckoScaffoldSmiles(mol=Chem.MolFromSmiles('Cc1cc(Oc2nccc(CCC)c2)ccc1'))
'c1ccc(Oc2ccccn2)cc1'
--------------------------------------------------------------------------------
rdkit.Chem.Scaffolds.MurckoScaffold.MurckoScaffoldSmilesFromSmiles(smiles, includeChirality=False)¶
Returns MurckScaffold Smiles from smiles
>>> MurckoScaffoldSmilesFromSmiles('Cc1cc(Oc2nccc(CCC)c2)ccc1')
'c1ccc(Oc2ccccn2)cc1'
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Scaffolds.rdScaffoldNetwork.BRICSScaffoldParams() → ScaffoldNetworkParams :¶
Returns parameters for generating scaffolds using BRICS fragmentation rules

C++ signature :RDKit::ScaffoldNetwork::ScaffoldNetworkParams* BRICSScaffoldParams()
--------------------------------------------------------------------------------
rdkit.Chem.Scaffolds.rdScaffoldNetwork.CreateScaffoldNetwork((AtomPairsParameters)mols, (ScaffoldNetworkParams)params) → ScaffoldNetwork :¶
create (and return) a new network from a sequence of molecules

C++ signature :RDKit::ScaffoldNetwork::ScaffoldNetwork* CreateScaffoldNetwork(boost::python::api::object,RDKit::ScaffoldNetwork::ScaffoldNetworkParams)
--------------------------------------------------------------------------------
rdkit.Chem.Scaffolds.rdScaffoldNetwork.UpdateScaffoldNetwork((AtomPairsParameters)mols, (ScaffoldNetwork)network, (ScaffoldNetworkParams)params) → None :¶
update an existing network by adding molecules

C++ signature :void UpdateScaffoldNetwork(boost::python::api::object,RDKit::ScaffoldNetwork::ScaffoldNetwork {lvalue},RDKit::ScaffoldNetwork::ScaffoldNetworkParams)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.SimpleEnum.Enumerator.EnumerateReaction(reaction, bbLists, uniqueProductsOnly=False, funcGroupFilename='/scratch/RDKit_2024_03/Data/Functional_Group_Hierarchy.txt', propName='molFileValue')¶
>>> testFile = os.path.join(RDConfig.RDCodeDir, 'Chem', 'SimpleEnum', 'test_data', 'boronic1.rxn')
>>> rxn = AllChem.ReactionFromRxnFile(testFile)
>>> rxn.Initialize()
>>> reacts1 = ['Brc1ccccc1', 'Brc1ncccc1', 'Brc1cnccc1']
>>> reacts1 = [Chem.MolFromSmiles(x) for x in reacts1]
>>> reacts2 = ['CCB(O)O', 'CCCB(O)O']
>>> reacts2 = [Chem.MolFromSmiles(x) for x in reacts2]


>>> prods = EnumerateReaction(rxn, (reacts1, reacts2))
>>> prods = list(prods)


This is a bit nasty because of the symmetry of the boronic acid:
>>> len(prods)
12


>>> smis = list(set([Chem.MolToSmiles(x[0]) for x in prods]))
>>> smis.sort()
>>> len(smis)
6
>>> print(smis)
['CCCc1ccccc1', 'CCCc1ccccn1', 'CCCc1cccnc1', 'CCc1ccccc1', 'CCc1ccccn1', 'CCc1cccnc1']


The nastiness can be avoided at the cost of some memory by asking for only unique products:
>>> prods = EnumerateReaction(rxn, (reacts1, reacts2), uniqueProductsOnly=True)
>>> prods = list(prods)
>>> len(prods)
6
>>> print(sorted([Chem.MolToSmiles(x[0]) for x in prods]))
['CCCc1ccccc1', 'CCCc1ccccn1', 'CCCc1cccnc1', 'CCc1ccccc1', 'CCc1ccccn1', 'CCc1cccnc1']
--------------------------------------------------------------------------------
rdkit.Chem.SimpleEnum.Enumerator.PreprocessReaction(reaction, funcGroupFilename=None, propName='molFileValue')¶
>>> from rdkit.Chem import AllChem
>>> testFile = os.path.join(RDConfig.RDCodeDir, 'Chem', 'SimpleEnum', 'test_data', 'boronic1.rxn')
>>> rxn = AllChem.ReactionFromRxnFile(testFile)
>>> rxn.Initialize()
>>> nWarn, nError, nReacts, nProds, reactantLabels = PreprocessReaction(rxn)
>>> nWarn
0
>>> nError
0
>>> nReacts
2
>>> nProds
1
>>> reactantLabels
(((0, 'halogen.bromine.aromatic'),), ((1, 'boronicacid'),))


If there are functional group labels in the input reaction (via atoms with molFileValue
properties), the corresponding atoms will have queries added to them so that they only
match such things. We can see this here:
>>> rxn = AllChem.ReactionFromRxnFile(testFile)
>>> rxn.Initialize()
>>> r1 = rxn.GetReactantTemplate(0)
>>> m1 = Chem.MolFromSmiles('CCBr')
>>> m2 = Chem.MolFromSmiles('c1ccccc1Br')


These both match because the reaction file itself just has R1-Br:
>>> m1.HasSubstructMatch(r1)
True
>>> m2.HasSubstructMatch(r1)
True


After preprocessing, we only match the aromatic Br:
>>> d = PreprocessReaction(rxn)
>>> m1.HasSubstructMatch(r1)
False
>>> m2.HasSubstructMatch(r1)
True


We also support or queries in the values field (separated by commas):
>>> testFile = os.path.join(RDConfig.RDCodeDir, 'Chem', 'SimpleEnum', 'test_data', 'azide_reaction.rxn')
>>> rxn = AllChem.ReactionFromRxnFile(testFile)
>>> rxn.Initialize()
>>> reactantLabels = PreprocessReaction(rxn)[-1]
>>> reactantLabels
(((1, 'azide'),), ((1, 'carboxylicacid,acidchloride'),))
>>> m1 = Chem.MolFromSmiles('CC(=O)O')
>>> m2 = Chem.MolFromSmiles('CC(=O)Cl')
>>> m3 = Chem.MolFromSmiles('CC(=O)N')
>>> r2 = rxn.GetReactantTemplate(1)
>>> m1.HasSubstructMatch(r2)
True
>>> m2.HasSubstructMatch(r2)
True
>>> m3.HasSubstructMatch(r2)
False


unrecognized final group types are returned as None:
>>> testFile = os.path.join(RDConfig.RDCodeDir, 'Chem', 'SimpleEnum', 'test_data', 'bad_value1.rxn')
>>> rxn = AllChem.ReactionFromRxnFile(testFile)
>>> rxn.Initialize()
>>> nWarn,nError,nReacts,nProds,reactantLabels = PreprocessReaction(rxn)
Traceback (most recent call last):
  File "/usr/prog/python/2.6.6_gnu/lib/python2.6/doctest.py", line 1253, in __run
    compileflags, 1) in test.globs
  File "<doctest __main__.PreprocessReaction[36]>", line 1, in <module>
    nWarn,nError,nReacts,nProds,reactantLabels = PreprocessReaction(rxn)
  File "Enumerator.py", line 105, in PreprocessReaction
    reactantLabels = reaction.AddRecursiveQueriesToReaction(queryDict, propName='molFileValue', getLabels=True)
KeyError: 'boromicacid'


One unrecognized group type in a comma-separated list makes the whole thing fail:
>>> testFile = os.path.join(RDConfig.RDCodeDir, 'Chem', 'SimpleEnum', 'test_data', 'bad_value2.rxn')
>>> rxn = AllChem.ReactionFromRxnFile(testFile)
>>> rxn.Initialize()
>>> nWarn,nError,nReacts,nProds,reactantLabels = PreprocessReaction(rxn)
Traceback (most recent call last):
  File "/usr/prog/python/2.6.6_gnu/lib/python2.6/doctest.py", line 1253, in __run
    compileflags, 1) in test.globs
  File "<doctest __main__.PreprocessReaction[36]>", line 1, in <module>
    nWarn,nError,nReacts,nProds,reactantLabels = PreprocessReaction(rxn)
  File "Enumerator.py", line 105, in PreprocessReaction
    reactantLabels = reaction.AddRecursiveQueriesToReaction(queryDict, propName='molFileValue', getLabels=True)
KeyError: 'carboxylicacid,acidchlroide'
>>> testFile = os.path.join(RDConfig.RDCodeDir, 'Chem', 'SimpleEnum', 'test_data', 'bad_value3.rxn')
>>> rxn = AllChem.ReactionFromRxnFile(testFile)
>>> rxn.Initialize()
>>> nWarn,nError,nReacts,nProds,reactantLabels = PreprocessReaction(rxn)
Traceback (most recent call last):
  File "/usr/prog/python/2.6.6_gnu/lib/python2.6/doctest.py", line 1253, in __run
    compileflags, 1) in test.globs
  File "<doctest __main__.PreprocessReaction[36]>", line 1, in <module>
    nWarn,nError,nReacts,nProds,reactantLabels = PreprocessReaction(rxn)
  File "Enumerator.py", line 105, in PreprocessReaction
    reactantLabels = reaction.AddRecursiveQueriesToReaction(queryDict, propName='molFileValue', getLabels=True)
KeyError: 'carboxyliccaid,acidchloride'
>>> rxn = rdChemReactions.ChemicalReaction()
>>> rxn.Initialize()
>>> nWarn, nError, nReacts, nProds, reactantLabels = PreprocessReaction(rxn)
>>> reactantLabels
()
>>> reactantLabels == ()
True
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.SpacialScore.SPS(mol, normalize=True)¶
Calculates the SpacialScore descriptor. By default, the score is normalized by the number of heavy atoms (nSPS) resulting in a float value,
otherwise (normalize=False) the absolute score is returned as an integer.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Subshape.BuilderUtils.AppendSkeletonPoints(shapeGrid, termPts, winRad, stepDist, maxGridVal=3, maxDistC=15.0, distTol=1.5, symFactor=1.5, verbose=False)¶
--------------------------------------------------------------------------------
rdkit.Chem.Subshape.BuilderUtils.AssignMolFeatsToPoints(pts, mol, featFactory, winRad)¶
--------------------------------------------------------------------------------
rdkit.Chem.Subshape.BuilderUtils.CalculateDirectionsAtPoint(pt, shapeGrid, winRad)¶
--------------------------------------------------------------------------------
rdkit.Chem.Subshape.BuilderUtils.ClusterTerminalPts(pts, winRad, scale)¶
--------------------------------------------------------------------------------
rdkit.Chem.Subshape.BuilderUtils.ComputeGridIndices(shapeGrid, winRad)¶
--------------------------------------------------------------------------------
rdkit.Chem.Subshape.BuilderUtils.ComputeShapeGridCentroid(pt, shapeGrid, winRad)¶
--------------------------------------------------------------------------------
rdkit.Chem.Subshape.BuilderUtils.ExpandTerminalPts(shape, pts, winRad, maxGridVal=3.0, targetNumPts=5)¶
find additional terminal points until a target number is reached
--------------------------------------------------------------------------------
rdkit.Chem.Subshape.BuilderUtils.FindFarthestGridPoint(shape, loc, winRad, maxGridVal)¶
find the grid point with max occupancy that is furthest from a
given location
--------------------------------------------------------------------------------
rdkit.Chem.Subshape.BuilderUtils.FindGridPointBetweenPoints(pt1, pt2, shapeGrid, winRad)¶
--------------------------------------------------------------------------------
rdkit.Chem.Subshape.BuilderUtils.FindTerminalPtsFromConformer(conf, winRad, nbrCount)¶
--------------------------------------------------------------------------------
rdkit.Chem.Subshape.BuilderUtils.FindTerminalPtsFromShape(shape, winRad, fraction, maxGridVal=3)¶
--------------------------------------------------------------------------------
rdkit.Chem.Subshape.BuilderUtils.GetMoreTerminalPoints(shape, pts, winRad, maxGridVal, targetNumber=5)¶
adds a set of new terminal points using a max-min algorithm
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Subshape.SubshapeAligner.ClusterAlignments(mol, alignments, builder, neighborTol=0.1, distMetric=1, tempConfId=1001)¶
clusters a set of alignments and returns the cluster centroid
--------------------------------------------------------------------------------
rdkit.Chem.Subshape.SubshapeAligner.GetShapeShapeDistance(s1, s2, distMetric)¶
returns the distance between two shapes according to the provided metric
--------------------------------------------------------------------------------
rdkit.Chem.Subshape.SubshapeAligner.TransformMol(mol, tform, confId=-1, newConfId=100)¶
Applies the transformation to a molecule and sets it up with a single conformer
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Subshape.SubshapeObjects.DisplaySubshape(viewer, shape, name, showSkelPts=True, color=(1, 0, 1))¶
--------------------------------------------------------------------------------
rdkit.Chem.Subshape.SubshapeObjects.DisplaySubshapeSkeleton(viewer, shape, name, color=(1, 0, 1), colorByOrder=False)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.Suppliers.DbMolSupplier.warning(msg, dest=<_io.TextIOWrapper name='<stderr>' mode='w' encoding='utf-8'>)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.TemplateAlign.AlignMolToTemplate2D(mol, template, match=None, clearConfs=False, templateConfId=-1)¶
Arguments:



mol:      the molecule to be aligned
template: the template to align to

match:    If provided, this should be a sequence of integerscontaining the indices of the atoms in mol that match
those in template. This is the result of calling:

mol.GetSubstructMatch(template)




clearConfs: toggles removing any existing conformers on mol


Returns the confId of the conformer containing the depiction
>>> patt = Chem.MolFromSmiles('C1CC1')
>>> rdDepictor.Compute2DCoords(patt)
0
>>> mol = Chem.MolFromSmiles('OC1CC1CC1CCC1')
>>> rdDepictor.Compute2DCoords(mol)
0
>>> pc = patt.GetConformer(0)
>>> mc = mol.GetConformer(0)


We start out with the molecules not aligned:
>>> vs = [abs(pc.GetAtomPosition(i).x-mc.GetAtomPosition(i+1).x) for i in range(pc.GetNumAtoms())]
>>> [x<1e-4 for x in vs]
[False, False, False]


But then we can replace the conformer of mol:
>>> AlignMolToTemplate2D(mol,patt,clearConfs=True)
0
>>> mol.GetNumConformers()
1
>>> pc = patt.GetConformer(0)
>>> mc = mol.GetConformer(0)
>>> vs = [abs(pc.GetAtomPosition(i).x-mc.GetAtomPosition(i+1).x) for i in range(pc.GetNumAtoms())]
>>> [x<1e-4 for x in vs]
[True, True, True]


If we like, we can specify the atom map explicitly in order to align to the second
matching ring in the probe molecule:
>>> match = (5,6,7)
>>> AlignMolToTemplate2D(mol,patt,clearConfs=True,match=match)
0
>>> mol.GetNumConformers()
1
>>> pc = patt.GetConformer(0)
>>> mc = mol.GetConformer(0)
>>> vs = [abs(pc.GetAtomPosition(i).x-mc.GetAtomPosition(i+1).x) for i in range(pc.GetNumAtoms())]
>>> [x<1e-4 for x in vs]
[False, False, False]
>>> vs = [abs(pc.GetAtomPosition(i).x-mc.GetAtomPosition(i+5).x) for i in range(pc.GetNumAtoms())]
>>> [x<1e-4 for x in vs]
[True, True, True]
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Chem.TorsionFingerprints.CalculateTFD(torsions1, torsions2, weights=None)¶
Calculate the torsion deviation fingerprint (TFD) given two lists of
torsion angles.
Arguments:
- torsions1:  torsion angles of conformation 1
- torsions2:  torsion angles of conformation 2
- weights:    list of torsion weights (default: None)
Return: TFD value (float)
--------------------------------------------------------------------------------
rdkit.Chem.TorsionFingerprints.CalculateTorsionAngles(mol, tors_list, tors_list_rings, confId=-1)¶
Calculate the torsion angles for a list of non-ring and 
a list of ring torsions.
Arguments:
- mol:       the molecule of interest
- tors_list: list of non-ring torsions
- tors_list_rings: list of ring torsions
- confId:    index of the conformation (default: first conformer)
Return: list of torsion angles
--------------------------------------------------------------------------------
rdkit.Chem.TorsionFingerprints.CalculateTorsionLists(mol, maxDev='equal', symmRadius=2, ignoreColinearBonds=True)¶
Calculate a list of torsions for a given molecule. For each torsion
the four atom indices are determined and stored in a set.
Arguments:
- mol:      the molecule of interest
- maxDev:   maximal deviation used for normalization

‘equal’: all torsions are normalized using 180.0 (default)
‘spec’:  each torsion is normalized using its specific

maximal deviation as given in the paper




symmRadius: radius used for calculating the atom invariants(default: 2)




ignoreColinearBonds: if True (default), single bonds adjacent totriple bonds are ignored
if False, alternative not-covalently bound
atoms are used to define the torsion




Return: two lists of torsions: non-ring and ring torsions
--------------------------------------------------------------------------------
rdkit.Chem.TorsionFingerprints.CalculateTorsionWeights(mol, aid1=-1, aid2=-1, ignoreColinearBonds=True)¶
Calculate the weights for the torsions in a molecule.
By default, the highest weight is given to the bond 
connecting the two most central atoms.
If desired, two alternate atoms can be specified (must 
be connected by a bond).
Arguments:
- mol:   the molecule of interest
- aid1:  index of the first atom (default: most central)
- aid2:  index of the second atom (default: second most central)
- ignoreColinearBonds: if True (default), single bonds adjacent to

triple bonds are ignored
if False, alternative not-covalently bound
atoms are used to define the torsion

Return: list of torsion weights (both non-ring and ring)
--------------------------------------------------------------------------------
rdkit.Chem.TorsionFingerprints.GetBestTFDBetweenMolecules(mol1, mol2, confId1=-1, useWeights=True, maxDev='equal', symmRadius=2, ignoreColinearBonds=True)¶
Wrapper to calculate the best TFD between a single conformer of mol1 and all the conformers of mol2
Important: The two molecules must be isomorphic
Arguments:
- mol1:     first instance of the molecule of interest
- mol2:     second instance the molecule of interest
- confId1:  conformer index for mol1 (default: first conformer)
- useWeights: flag for using torsion weights in the TFD calculation
- maxDev:   maximal deviation used for normalization

‘equal’: all torsions are normalized using 180.0 (default)
‘spec’:  each torsion is normalized using its specific

maximal deviation as given in the paper




symmRadius: radius used for calculating the atom invariants(default: 2)




ignoreColinearBonds: if True (default), single bonds adjacent totriple bonds are ignored
if False, alternative not-covalently bound
atoms are used to define the torsion




Return: TFD value
--------------------------------------------------------------------------------
rdkit.Chem.TorsionFingerprints.GetTFDBetweenConformers(mol, confIds1, confIds2, useWeights=True, maxDev='equal', symmRadius=2, ignoreColinearBonds=True)¶
Wrapper to calculate the TFD between two list of conformers 
of a molecule
Arguments:
- mol:      the molecule of interest
- confIds1:  first list of conformer indices
- confIds2:  second list of conformer indices
- useWeights: flag for using torsion weights in the TFD calculation
- maxDev:   maximal deviation used for normalization

‘equal’: all torsions are normalized using 180.0 (default)
‘spec’:  each torsion is normalized using its specific

maximal deviation as given in the paper




symmRadius: radius used for calculating the atom invariants(default: 2)




ignoreColinearBonds: if True (default), single bonds adjacent totriple bonds are ignored
if False, alternative not-covalently bound
atoms are used to define the torsion




Return: list of TFD values
--------------------------------------------------------------------------------
rdkit.Chem.TorsionFingerprints.GetTFDBetweenMolecules(mol1, mol2, confId1=-1, confId2=-1, useWeights=True, maxDev='equal', symmRadius=2, ignoreColinearBonds=True)¶
Wrapper to calculate the TFD between two molecules.
Important: The two molecules must be isomorphic
Arguments:
- mol1:     first instance of the molecule of interest
- mol2:     second instance the molecule of interest
- confId1:  conformer index for mol1 (default: first conformer)
- confId2:  conformer index for mol2 (default: first conformer)
- useWeights: flag for using torsion weights in the TFD calculation
- maxDev:   maximal deviation used for normalization

‘equal’: all torsions are normalized using 180.0 (default)
‘spec’:  each torsion is normalized using its specific

maximal deviation as given in the paper




symmRadius: radius used for calculating the atom invariants(default: 2)




ignoreColinearBonds: if True (default), single bonds adjacent totriple bonds are ignored
if False, alternative not-covalently bound
atoms are used to define the torsion




Return: TFD value
--------------------------------------------------------------------------------
rdkit.Chem.TorsionFingerprints.GetTFDMatrix(mol, useWeights=True, maxDev='equal', symmRadius=2, ignoreColinearBonds=True)¶
Wrapper to calculate the matrix of TFD values for the
conformers of a molecule.
Arguments:
- mol:      the molecule of interest
- useWeights: flag for using torsion weights in the TFD calculation
- maxDev:   maximal deviation used for normalization

‘equal’: all torsions are normalized using 180.0 (default)
‘spec’:  each torsion is normalized using its specific

maximal deviation as given in the paper




symmRadius: radius used for calculating the atom invariants(default: 2)




ignoreColinearBonds: if True (default), single bonds adjacent totriple bonds are ignored
if False, alternative not-covalently bound
atoms are used to define the torsion




Return: matrix of TFD values
Note that the returned matrix is symmetrical, i.e. it is the
lower half of the matrix, e.g. for 5 conformers:
matrix = [ a,

b, c,
d, e, f,
g, h, i, j]
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.DataManip.Metric.rdMetricMatrixCalc.GetEuclideanDistMat((AtomPairsParameters)descripMat) → object :¶
Compute the distance matrix from a descriptor matrix using the Euclidean distance metric

ARGUMENTS:


descripMat - A python object of any one of the following types 

A numeric array of dimensions n by m where n is the number of items in the data set and m is the number of descriptors




A list of Numeric Vectors (or 1D arrays), each entry in the list corresponds to descriptor vector for one item




A list (or tuple) of lists (or tuples) of values, where the values can be extracted to double.








RETURNS: A numeric one-dimensional array containing the lower triangle elements of the symmetric distance matrix




C++ signature :_object* GetEuclideanDistMat(boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataManip.Metric.rdMetricMatrixCalc.GetTanimotoDistMat((AtomPairsParameters)bitVectList) → object :¶
Compute the distance matrix from a list of BitVects using the Tanimoto distance metric

ARGUMENTS:


bitVectList - a list of bit vectors. Currently this works only for a list of explicit bit vectors, needs to be expanded to support a list of SparseBitVects




RETURNS: A numeric 1 dimensional array containing the lower triangle elements of the
symmetric distance matrix




C++ signature :_object* GetTanimotoDistMat(boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataManip.Metric.rdMetricMatrixCalc.GetTanimotoSimMat((AtomPairsParameters)bitVectList) → object :¶
Compute the similarity matrix from a list of BitVects

ARGUMENTS:


bitVectList - a list of bit vectors. Currently this works only for a list of explicit bit vectors, needs to be expanded to support a list of SparseBitVects




RETURNS: A numeric 1 dimensional array containing the lower triangle elements of the symmetric similarity matrix




C++ signature :_object* GetTanimotoSimMat(boost::python::api::object)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.DataStructs.FingerprintSimilarity(fp1, fp2, metric=<Boost.Python.function object>)¶
returns the calculated similarity between two fingerprints,
handles any folding that may need to be done to ensure that they
are compatible
--------------------------------------------------------------------------------
rdkit.DataStructs.FoldToTargetDensity(fp, density=0.3, minLength=64)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.DataStructs.BitUtils.ConstructEnsembleBV(bv, bitsToKeep)¶
>>> from rdkit import DataStructs
>>> bv = DataStructs.ExplicitBitVect(128)
>>> bv.SetBitsFromList((1,5,47,99,120))
>>> r = ConstructEnsembleBV(bv,(0,1,2,3,45,46,47,48,49))
>>> r.GetNumBits()
9
>>> r.GetBit(0)
0
>>> r.GetBit(1)
1
>>> r.GetBit(5)
0
>>> r.GetBit(6)  # old bit 47
1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.AllBitSimilarity((SparseBitVect)v1, (SparseBitVect)v2) → float :¶


C++ signature :double AllBitSimilarity(SparseBitVect,SparseBitVect)




AllBitSimilarity( (ExplicitBitVect)v1, (ExplicitBitVect)v2) -> float :(B(bv1) - B(bv1^bv2)) / B(bv1)

C++ signature :double AllBitSimilarity(ExplicitBitVect,ExplicitBitVect)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.AllProbeBitsMatch((SparseBitVect)probe, (SparseBitVect)ref) → bool :¶


C++ signature :bool AllProbeBitsMatch(SparseBitVect,SparseBitVect)



AllProbeBitsMatch( (ExplicitBitVect)probe, (ExplicitBitVect)ref) -> bool :


C++ signature :bool AllProbeBitsMatch(ExplicitBitVect,ExplicitBitVect)



AllProbeBitsMatch( (SparseBitVect)probe, (str)ref) -> bool :


C++ signature :bool AllProbeBitsMatch(SparseBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)




AllProbeBitsMatch( (ExplicitBitVect)probe, (str)ref) -> bool :
Returns True if all bits in the first argument match all bits in the vector defined by the pickle in the second argument.

C++ signature :bool AllProbeBitsMatch(ExplicitBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.AsymmetricSimilarity((SparseBitVect)bv1, (SparseBitVect)bv2[, (bool)returnDistance=0]) → float :¶


C++ signature :double AsymmetricSimilarity(SparseBitVect,SparseBitVect [,bool=0])




AsymmetricSimilarity( (ExplicitBitVect)bv1, (ExplicitBitVect)bv2 [, (bool)returnDistance=0]) -> float :B(bv1&bv2) / min(B(bv1),B(bv2))

C++ signature :double AsymmetricSimilarity(ExplicitBitVect,ExplicitBitVect [,bool=0])




AsymmetricSimilarity( (SparseBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :


C++ signature :double AsymmetricSimilarity(SparseBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])




AsymmetricSimilarity( (ExplicitBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :B(bv1&bv2) / min(B(bv1),B(bv2))

C++ signature :double AsymmetricSimilarity(ExplicitBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.AsymmetricSimilarityNeighbors((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
B(bv1&bv2) / min(B(bv1),B(bv2))

C++ signature :boost::python::list AsymmetricSimilarityNeighbors(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.AsymmetricSimilarityNeighbors_sparse((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
B(bv1&bv2) / min(B(bv1),B(bv2))

C++ signature :boost::python::list AsymmetricSimilarityNeighbors_sparse(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BitVectToBinaryText((SparseBitVect)bv) → object :¶


C++ signature :boost::python::api::object BitVectToBinaryText(SparseBitVect)




BitVectToBinaryText( (ExplicitBitVect)bv) -> object :Returns a binary string (byte array) representing the bit vector.

C++ signature :boost::python::api::object BitVectToBinaryText(ExplicitBitVect)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BitVectToFPSText((SparseBitVect)bv1) → str :¶


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > BitVectToFPSText(SparseBitVect)




BitVectToFPSText( (ExplicitBitVect)bv1) -> str :Returns an FPS string representing the bit vector.

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > BitVectToFPSText(ExplicitBitVect)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BitVectToText((SparseBitVect)bv1) → str :¶


C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > BitVectToText(SparseBitVect)




BitVectToText( (ExplicitBitVect)bv1) -> str :Returns a string of zeros and ones representing the bit vector.

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > BitVectToText(ExplicitBitVect)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BraunBlanquetSimilarity((SparseBitVect)bv1, (SparseBitVect)bv2[, (bool)returnDistance=0]) → float :¶


C++ signature :double BraunBlanquetSimilarity(SparseBitVect,SparseBitVect [,bool=0])




BraunBlanquetSimilarity( (ExplicitBitVect)bv1, (ExplicitBitVect)bv2 [, (bool)returnDistance=0]) -> float :B(bv1&bv2) / max(B(bv1),B(bv2))

C++ signature :double BraunBlanquetSimilarity(ExplicitBitVect,ExplicitBitVect [,bool=0])




BraunBlanquetSimilarity( (SparseBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :


C++ signature :double BraunBlanquetSimilarity(SparseBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])




BraunBlanquetSimilarity( (ExplicitBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :B(bv1&bv2) / max(B(bv1),B(bv2))

C++ signature :double BraunBlanquetSimilarity(ExplicitBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BraunBlanquetSimilarityNeighbors((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
B(bv1&bv2) / max(B(bv1),B(bv2))

C++ signature :boost::python::list BraunBlanquetSimilarityNeighbors(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BraunBlanquetSimilarityNeighbors_sparse((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
B(bv1&bv2) / max(B(bv1),B(bv2))

C++ signature :boost::python::list BraunBlanquetSimilarityNeighbors_sparse(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BulkAllBitSimilarity((ExplicitBitVect)v1, (AtomPairsParameters)v2[, (bool)returnDistance=0]) → list :¶


C++ signature :boost::python::list BulkAllBitSimilarity(ExplicitBitVect const*,boost::python::api::object [,bool=0])




BulkAllBitSimilarity( (ExplicitBitVect)v1, (AtomPairsParameters)v2 [, (bool)returnDistance=0]) -> list :(B(bv1) - B(bv1^bv2)) / B(bv1)

C++ signature :boost::python::list BulkAllBitSimilarity(ExplicitBitVect const*,boost::python::api::object [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BulkAsymmetricSimilarity((SparseBitVect)bv1, (AtomPairsParameters)bvList[, (bool)returnDistance=0]) → list :¶


C++ signature :boost::python::list BulkAsymmetricSimilarity(SparseBitVect const*,boost::python::api::object [,bool=0])




BulkAsymmetricSimilarity( (ExplicitBitVect)bv1, (AtomPairsParameters)bvList [, (bool)returnDistance=0]) -> list :B(bv1&bv2) / min(B(bv1),B(bv2))

C++ signature :boost::python::list BulkAsymmetricSimilarity(ExplicitBitVect const*,boost::python::api::object [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BulkBraunBlanquetSimilarity((SparseBitVect)bv1, (AtomPairsParameters)bvList[, (bool)returnDistance=0]) → list :¶


C++ signature :boost::python::list BulkBraunBlanquetSimilarity(SparseBitVect const*,boost::python::api::object [,bool=0])




BulkBraunBlanquetSimilarity( (ExplicitBitVect)bv1, (AtomPairsParameters)bvList [, (bool)returnDistance=0]) -> list :B(bv1&bv2) / max(B(bv1),B(bv2))

C++ signature :boost::python::list BulkBraunBlanquetSimilarity(ExplicitBitVect const*,boost::python::api::object [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BulkCosineSimilarity((SparseBitVect)bv1, (AtomPairsParameters)bvList[, (bool)returnDistance=0]) → list :¶


C++ signature :boost::python::list BulkCosineSimilarity(SparseBitVect const*,boost::python::api::object [,bool=0])




BulkCosineSimilarity( (ExplicitBitVect)bv1, (AtomPairsParameters)bvList [, (bool)returnDistance=0]) -> list :B(bv1&bv2) / sqrt(B(bv1) * B(bv2))

C++ signature :boost::python::list BulkCosineSimilarity(ExplicitBitVect const*,boost::python::api::object [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BulkDiceSimilarity((SparseBitVect)bv1, (AtomPairsParameters)bvList[, (bool)returnDistance=0]) → list :¶


C++ signature :boost::python::list BulkDiceSimilarity(SparseBitVect const*,boost::python::api::object [,bool=0])




BulkDiceSimilarity( (ExplicitBitVect)bv1, (AtomPairsParameters)bvList [, (bool)returnDistance=0]) -> list :2*B(bv1&bv2) / (B(bv1) + B(bv2))

C++ signature :boost::python::list BulkDiceSimilarity(ExplicitBitVect const*,boost::python::api::object [,bool=0])



BulkDiceSimilarity( (IntSparseIntVect)v1, (list)v2 [, (bool)returnDistance=False]) -> list :return the Dice similarities between one vector and a sequence of others

C++ signature :boost::python::list BulkDiceSimilarity(RDKit::SparseIntVect<int>,boost::python::list [,bool=False])



BulkDiceSimilarity( (LongSparseIntVect)v1, (list)v2 [, (bool)returnDistance=False]) -> list :return the Dice similarities between one vector and a sequence of others

C++ signature :boost::python::list BulkDiceSimilarity(RDKit::SparseIntVect<long>,boost::python::list [,bool=False])



BulkDiceSimilarity( (UIntSparseIntVect)v1, (list)v2 [, (bool)returnDistance=False]) -> list :return the Dice similarities between one vector and a sequence of others

C++ signature :boost::python::list BulkDiceSimilarity(RDKit::SparseIntVect<unsigned int>,boost::python::list [,bool=False])



BulkDiceSimilarity( (ULongSparseIntVect)v1, (list)v2 [, (bool)returnDistance=False]) -> list :return the Dice similarities between one vector and a sequence of others

C++ signature :boost::python::list BulkDiceSimilarity(RDKit::SparseIntVect<unsigned long>,boost::python::list [,bool=False])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BulkKulczynskiSimilarity((SparseBitVect)bv1, (AtomPairsParameters)bvList[, (bool)returnDistance=0]) → list :¶


C++ signature :boost::python::list BulkKulczynskiSimilarity(SparseBitVect const*,boost::python::api::object [,bool=0])




BulkKulczynskiSimilarity( (ExplicitBitVect)bv1, (AtomPairsParameters)bvList [, (bool)returnDistance=0]) -> list :B(bv1&bv2)*(B(bv1) + B(bv2)) / (2 * B(bv1) * B(bv2))

C++ signature :boost::python::list BulkKulczynskiSimilarity(ExplicitBitVect const*,boost::python::api::object [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BulkMcConnaugheySimilarity((SparseBitVect)bv1, (AtomPairsParameters)bvList[, (bool)returnDistance=0]) → list :¶


C++ signature :boost::python::list BulkMcConnaugheySimilarity(SparseBitVect const*,boost::python::api::object [,bool=0])




BulkMcConnaugheySimilarity( (ExplicitBitVect)bv1, (AtomPairsParameters)bvList [, (bool)returnDistance=0]) -> list :(B(bv1&bv2) * (B(bv1)+B(bv2)) - B(bv1)*B(bv2)) / (B(bv1) * B(bv2))

C++ signature :boost::python::list BulkMcConnaugheySimilarity(ExplicitBitVect const*,boost::python::api::object [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BulkOnBitSimilarity((ExplicitBitVect)v1, (AtomPairsParameters)v2[, (bool)returnDistance=0]) → list :¶


C++ signature :boost::python::list BulkOnBitSimilarity(ExplicitBitVect const*,boost::python::api::object [,bool=0])




BulkOnBitSimilarity( (ExplicitBitVect)v1, (AtomPairsParameters)v2 [, (bool)returnDistance=0]) -> list :B(bv1&bv2) / B(bv1|bv2)

C++ signature :boost::python::list BulkOnBitSimilarity(ExplicitBitVect const*,boost::python::api::object [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BulkRogotGoldbergSimilarity((SparseBitVect)bv1, (AtomPairsParameters)bvList[, (bool)returnDistance=0]) → list :¶


C++ signature :boost::python::list BulkRogotGoldbergSimilarity(SparseBitVect const*,boost::python::api::object [,bool=0])




BulkRogotGoldbergSimilarity( (ExplicitBitVect)bv1, (AtomPairsParameters)bvList [, (bool)returnDistance=0]) -> list :B(bv1&bv2) / B(bv1)

C++ signature :boost::python::list BulkRogotGoldbergSimilarity(ExplicitBitVect const*,boost::python::api::object [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BulkRusselSimilarity((SparseBitVect)bv1, (AtomPairsParameters)bvList[, (bool)returnDistance=0]) → list :¶


C++ signature :boost::python::list BulkRusselSimilarity(SparseBitVect const*,boost::python::api::object [,bool=0])




BulkRusselSimilarity( (ExplicitBitVect)bv1, (AtomPairsParameters)bvList [, (bool)returnDistance=0]) -> list :B(bv1&bv2) / B(bv1)

C++ signature :boost::python::list BulkRusselSimilarity(ExplicitBitVect const*,boost::python::api::object [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BulkSokalSimilarity((SparseBitVect)bv1, (AtomPairsParameters)bvList[, (bool)returnDistance=0]) → list :¶


C++ signature :boost::python::list BulkSokalSimilarity(SparseBitVect const*,boost::python::api::object [,bool=0])




BulkSokalSimilarity( (ExplicitBitVect)bv1, (AtomPairsParameters)bvList [, (bool)returnDistance=0]) -> list :B(bv1&bv2) / (2*B(bv1) + 2*B(bv2) - 3*B(bv1&bv2))

C++ signature :boost::python::list BulkSokalSimilarity(ExplicitBitVect const*,boost::python::api::object [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BulkTanimotoSimilarity((SparseBitVect)bv1, (AtomPairsParameters)bvList[, (bool)returnDistance=0]) → list :¶


C++ signature :boost::python::list BulkTanimotoSimilarity(SparseBitVect const*,boost::python::api::object [,bool=0])




BulkTanimotoSimilarity( (ExplicitBitVect)bv1, (AtomPairsParameters)bvList [, (bool)returnDistance=0]) -> list :B(bv1&bv2) / (B(bv1) + B(bv2) - B(bv1&bv2))

C++ signature :boost::python::list BulkTanimotoSimilarity(ExplicitBitVect const*,boost::python::api::object [,bool=0])



BulkTanimotoSimilarity( (IntSparseIntVect)v1, (list)v2 [, (bool)returnDistance=False]) -> list :return the Tanimoto similarities between one vector and a sequence of others

C++ signature :boost::python::list BulkTanimotoSimilarity(RDKit::SparseIntVect<int>,boost::python::list [,bool=False])



BulkTanimotoSimilarity( (LongSparseIntVect)v1, (list)v2 [, (bool)returnDistance=False]) -> list :return the Tanimoto similarities between one vector and a sequence of others

C++ signature :boost::python::list BulkTanimotoSimilarity(RDKit::SparseIntVect<long>,boost::python::list [,bool=False])



BulkTanimotoSimilarity( (UIntSparseIntVect)v1, (list)v2 [, (bool)returnDistance=False]) -> list :return the Tanimoto similarities between one vector and a sequence of others

C++ signature :boost::python::list BulkTanimotoSimilarity(RDKit::SparseIntVect<unsigned int>,boost::python::list [,bool=False])



BulkTanimotoSimilarity( (ULongSparseIntVect)v1, (list)v2 [, (bool)returnDistance=False]) -> list :return the Tanimoto similarities between one vector and a sequence of others

C++ signature :boost::python::list BulkTanimotoSimilarity(RDKit::SparseIntVect<unsigned long>,boost::python::list [,bool=False])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.BulkTverskySimilarity((SparseBitVect)bv1, (AtomPairsParameters)bvList, (float)a, (float)b[, (bool)returnDistance=0]) → list :¶


C++ signature :boost::python::list BulkTverskySimilarity(SparseBitVect const*,boost::python::api::object,double,double [,bool=0])




BulkTverskySimilarity( (ExplicitBitVect)bv1, (AtomPairsParameters)bvList, (float)a, (float)b [, (bool)returnDistance=0]) -> list :B(bv1&bv2) / (a*B(bv1)+b*B(bv2)+(1-a-b)*B(bv1&bv2)

C++ signature :boost::python::list BulkTverskySimilarity(ExplicitBitVect const*,boost::python::api::object,double,double [,bool=0])



BulkTverskySimilarity( (IntSparseIntVect)v1, (list)v2, (float)a, (float)b [, (bool)returnDistance=False]) -> list :return the Tversky similarities between one vector and a sequence of others

C++ signature :boost::python::list BulkTverskySimilarity(RDKit::SparseIntVect<int>,boost::python::list,double,double [,bool=False])



BulkTverskySimilarity( (LongSparseIntVect)v1, (list)v2, (float)a, (float)b [, (bool)returnDistance=False]) -> list :return the Tversky similarities between one vector and a sequence of others

C++ signature :boost::python::list BulkTverskySimilarity(RDKit::SparseIntVect<long>,boost::python::list,double,double [,bool=False])



BulkTverskySimilarity( (UIntSparseIntVect)v1, (list)v2, (float)a, (float)b [, (bool)returnDistance=False]) -> list :return the Tversky similarities between one vector and a sequence of others

C++ signature :boost::python::list BulkTverskySimilarity(RDKit::SparseIntVect<unsigned int>,boost::python::list,double,double [,bool=False])



BulkTverskySimilarity( (ULongSparseIntVect)v1, (list)v2, (float)a, (float)b [, (bool)returnDistance=False]) -> list :return the Tversky similarities between one vector and a sequence of others

C++ signature :boost::python::list BulkTverskySimilarity(RDKit::SparseIntVect<unsigned long>,boost::python::list,double,double [,bool=False])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.ComputeL1Norm((DiscreteValueVect)v1, (DiscreteValueVect)v2) → int :¶
Compute the distance between two discrete vector values

C++ signature :unsigned int ComputeL1Norm(RDKit::DiscreteValueVect,RDKit::DiscreteValueVect)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.ConvertToExplicit((SparseBitVect)sbv) → ExplicitBitVect :¶
Converts a SparseBitVector to an ExplicitBitVector and returns the ExplicitBitVector

C++ signature :ExplicitBitVect* ConvertToExplicit(SparseBitVect const*)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.ConvertToNumpyArray((ExplicitBitVect)bv, (AtomPairsParameters)destArray) → None :¶


C++ signature :void ConvertToNumpyArray(ExplicitBitVect,boost::python::api::object)



ConvertToNumpyArray( (DiscreteValueVect)bv, (AtomPairsParameters)destArray) -> None :


C++ signature :void ConvertToNumpyArray(RDKit::DiscreteValueVect,boost::python::api::object)



ConvertToNumpyArray( (IntSparseIntVect)bv, (AtomPairsParameters)destArray) -> None :


C++ signature :void ConvertToNumpyArray(RDKit::SparseIntVect<int>,boost::python::api::object)



ConvertToNumpyArray( (LongSparseIntVect)bv, (AtomPairsParameters)destArray) -> None :


C++ signature :void ConvertToNumpyArray(RDKit::SparseIntVect<long>,boost::python::api::object)



ConvertToNumpyArray( (UIntSparseIntVect)bv, (AtomPairsParameters)destArray) -> None :


C++ signature :void ConvertToNumpyArray(RDKit::SparseIntVect<unsigned int>,boost::python::api::object)



ConvertToNumpyArray( (ULongSparseIntVect)bv, (AtomPairsParameters)destArray) -> None :


C++ signature :void ConvertToNumpyArray(RDKit::SparseIntVect<unsigned long>,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.CosineSimilarity((SparseBitVect)bv1, (SparseBitVect)bv2[, (bool)returnDistance=0]) → float :¶


C++ signature :double CosineSimilarity(SparseBitVect,SparseBitVect [,bool=0])




CosineSimilarity( (ExplicitBitVect)bv1, (ExplicitBitVect)bv2 [, (bool)returnDistance=0]) -> float :B(bv1&bv2) / sqrt(B(bv1) * B(bv2))

C++ signature :double CosineSimilarity(ExplicitBitVect,ExplicitBitVect [,bool=0])




CosineSimilarity( (SparseBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :


C++ signature :double CosineSimilarity(SparseBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])




CosineSimilarity( (ExplicitBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :B(bv1&bv2) / sqrt(B(bv1) * B(bv2))

C++ signature :double CosineSimilarity(ExplicitBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.CosineSimilarityNeighbors((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
B(bv1&bv2) / sqrt(B(bv1) * B(bv2))

C++ signature :boost::python::list CosineSimilarityNeighbors(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.CosineSimilarityNeighbors_sparse((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
B(bv1&bv2) / sqrt(B(bv1) * B(bv2))

C++ signature :boost::python::list CosineSimilarityNeighbors_sparse(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.CreateFromBinaryText((str)fps) → ExplicitBitVect :¶
Creates an ExplicitBitVect from a binary string (byte array).

C++ signature :ExplicitBitVect* CreateFromBinaryText(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.CreateFromBitString((str)bits) → ExplicitBitVect :¶
Creates an ExplicitBitVect from a bit string (string of 0s and 1s).

C++ signature :ExplicitBitVect* CreateFromBitString(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.CreateFromFPSText((str)fps) → ExplicitBitVect :¶
Creates an ExplicitBitVect from an FPS string.

C++ signature :ExplicitBitVect* CreateFromFPSText(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.DiceSimilarity((SparseBitVect)bv1, (SparseBitVect)bv2[, (bool)returnDistance=0]) → float :¶


C++ signature :double DiceSimilarity(SparseBitVect,SparseBitVect [,bool=0])




DiceSimilarity( (ExplicitBitVect)bv1, (ExplicitBitVect)bv2 [, (bool)returnDistance=0]) -> float :2*B(bv1&bv2) / (B(bv1) + B(bv2))

C++ signature :double DiceSimilarity(ExplicitBitVect,ExplicitBitVect [,bool=0])




DiceSimilarity( (SparseBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :


C++ signature :double DiceSimilarity(SparseBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])




DiceSimilarity( (ExplicitBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :2*B(bv1&bv2) / (B(bv1) + B(bv2))

C++ signature :double DiceSimilarity(ExplicitBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])



DiceSimilarity( (IntSparseIntVect)siv1, (IntSparseIntVect)siv2 [, (bool)returnDistance=False [, (float)bounds=0.0]]) -> float :return the Dice similarity between two vectors

C++ signature :double DiceSimilarity(RDKit::SparseIntVect<int>,RDKit::SparseIntVect<int> [,bool=False [,double=0.0]])



DiceSimilarity( (LongSparseIntVect)siv1, (LongSparseIntVect)siv2 [, (bool)returnDistance=False [, (float)bounds=0.0]]) -> float :return the Dice similarity between two vectors

C++ signature :double DiceSimilarity(RDKit::SparseIntVect<long>,RDKit::SparseIntVect<long> [,bool=False [,double=0.0]])



DiceSimilarity( (UIntSparseIntVect)siv1, (UIntSparseIntVect)siv2 [, (bool)returnDistance=False [, (float)bounds=0.0]]) -> float :return the Dice similarity between two vectors

C++ signature :double DiceSimilarity(RDKit::SparseIntVect<unsigned int>,RDKit::SparseIntVect<unsigned int> [,bool=False [,double=0.0]])



DiceSimilarity( (ULongSparseIntVect)siv1, (ULongSparseIntVect)siv2 [, (bool)returnDistance=False [, (float)bounds=0.0]]) -> float :return the Dice similarity between two vectors

C++ signature :double DiceSimilarity(RDKit::SparseIntVect<unsigned long>,RDKit::SparseIntVect<unsigned long> [,bool=False [,double=0.0]])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.DiceSimilarityNeighbors((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
2*B(bv1&bv2) / (B(bv1) + B(bv2))

C++ signature :boost::python::list DiceSimilarityNeighbors(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.DiceSimilarityNeighbors_sparse((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
2*B(bv1&bv2) / (B(bv1) + B(bv2))

C++ signature :boost::python::list DiceSimilarityNeighbors_sparse(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.FoldFingerprint((SparseBitVect)bv[, (int)foldFactor=2]) → SparseBitVect :¶


C++ signature :SparseBitVect* FoldFingerprint(SparseBitVect [,unsigned int=2])




FoldFingerprint( (ExplicitBitVect)bv [, (int)foldFactor=2]) -> ExplicitBitVect :Folds the fingerprint by the provided amount. The default, foldFactor=2, returns a fingerprint that is half the size of the original.

C++ signature :ExplicitBitVect* FoldFingerprint(ExplicitBitVect [,unsigned int=2])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.InitFromDaylightString((SparseBitVect)sbv, (str)s) → None :¶


C++ signature :void InitFromDaylightString(SparseBitVect {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)




InitFromDaylightString( (ExplicitBitVect)sbv, (str)s) -> None :Fill a BitVect using an ASCII (Daylight) encoding of a fingerprint.


Arguments
bv: either a _SparseBitVect_ or an _ExplicitBitVect_

txt: a string with the Daylight encoding (this is the text thatthe Daylight tools put in the FP field of a TDT)








C++ signature :void InitFromDaylightString(ExplicitBitVect {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.KulczynskiSimilarity((SparseBitVect)bv1, (SparseBitVect)bv2[, (bool)returnDistance=0]) → float :¶


C++ signature :double KulczynskiSimilarity(SparseBitVect,SparseBitVect [,bool=0])




KulczynskiSimilarity( (ExplicitBitVect)bv1, (ExplicitBitVect)bv2 [, (bool)returnDistance=0]) -> float :B(bv1&bv2)*(B(bv1) + B(bv2)) / (2 * B(bv1) * B(bv2))

C++ signature :double KulczynskiSimilarity(ExplicitBitVect,ExplicitBitVect [,bool=0])




KulczynskiSimilarity( (SparseBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :


C++ signature :double KulczynskiSimilarity(SparseBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])




KulczynskiSimilarity( (ExplicitBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :B(bv1&bv2)*(B(bv1) + B(bv2)) / (2 * B(bv1) * B(bv2))

C++ signature :double KulczynskiSimilarity(ExplicitBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.KulczynskiSimilarityNeighbors((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
B(bv1&bv2)*(B(bv1) + B(bv2)) / (2 * B(bv1) * B(bv2))

C++ signature :boost::python::list KulczynskiSimilarityNeighbors(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.KulczynskiSimilarityNeighbors_sparse((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
B(bv1&bv2)*(B(bv1) + B(bv2)) / (2 * B(bv1) * B(bv2))

C++ signature :boost::python::list KulczynskiSimilarityNeighbors_sparse(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.McConnaugheySimilarity((SparseBitVect)bv1, (SparseBitVect)bv2[, (bool)returnDistance=0]) → float :¶


C++ signature :double McConnaugheySimilarity(SparseBitVect,SparseBitVect [,bool=0])




McConnaugheySimilarity( (ExplicitBitVect)bv1, (ExplicitBitVect)bv2 [, (bool)returnDistance=0]) -> float :(B(bv1&bv2) * (B(bv1)+B(bv2)) - B(bv1)*B(bv2)) / (B(bv1) * B(bv2))

C++ signature :double McConnaugheySimilarity(ExplicitBitVect,ExplicitBitVect [,bool=0])




McConnaugheySimilarity( (SparseBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :


C++ signature :double McConnaugheySimilarity(SparseBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])




McConnaugheySimilarity( (ExplicitBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :(B(bv1&bv2) * (B(bv1)+B(bv2)) - B(bv1)*B(bv2)) / (B(bv1) * B(bv2))

C++ signature :double McConnaugheySimilarity(ExplicitBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.McConnaugheySimilarityNeighbors((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
(B(bv1&bv2) * (B(bv1)+B(bv2)) - B(bv1)*B(bv2)) / (B(bv1) * B(bv2))

C++ signature :boost::python::list McConnaugheySimilarityNeighbors(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.McConnaugheySimilarityNeighbors_sparse((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
(B(bv1&bv2) * (B(bv1)+B(bv2)) - B(bv1)*B(bv2)) / (B(bv1) * B(bv2))

C++ signature :boost::python::list McConnaugheySimilarityNeighbors_sparse(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.NumBitsInCommon((SparseBitVect)bv1, (SparseBitVect)bv2) → int :¶


C++ signature :int NumBitsInCommon(SparseBitVect,SparseBitVect)




NumBitsInCommon( (ExplicitBitVect)bv1, (ExplicitBitVect)bv2) -> int :Returns the total number of bits in common between the two bit vectors

C++ signature :int NumBitsInCommon(ExplicitBitVect,ExplicitBitVect)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.OffBitProjSimilarity((SparseBitVect)bv1, (SparseBitVect)bv2) → _vectd :¶


C++ signature :std::vector<double, std::allocator<double> > OffBitProjSimilarity(SparseBitVect,SparseBitVect)



OffBitProjSimilarity( (ExplicitBitVect)bv1, (ExplicitBitVect)bv2) -> _vectd :


C++ signature :std::vector<double, std::allocator<double> > OffBitProjSimilarity(ExplicitBitVect,ExplicitBitVect)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.OffBitsInCommon((SparseBitVect)bv1, (SparseBitVect)bv2) → _vecti :¶


C++ signature :std::vector<int, std::allocator<int> > OffBitsInCommon(SparseBitVect,SparseBitVect)




OffBitsInCommon( (ExplicitBitVect)bv1, (ExplicitBitVect)bv2) -> _vecti :Returns the number of off bits in common between the two bit vectors

C++ signature :std::vector<int, std::allocator<int> > OffBitsInCommon(ExplicitBitVect,ExplicitBitVect)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.OnBitProjSimilarity((SparseBitVect)bv1, (SparseBitVect)bv2) → _vectd :¶


C++ signature :std::vector<double, std::allocator<double> > OnBitProjSimilarity(SparseBitVect,SparseBitVect)




OnBitProjSimilarity( (ExplicitBitVect)bv1, (ExplicitBitVect)bv2) -> _vectd :Returns a 2-tuple: (B(bv1&bv2) / B(bv1), B(bv1&bv2) / B(bv2))

C++ signature :std::vector<double, std::allocator<double> > OnBitProjSimilarity(ExplicitBitVect,ExplicitBitVect)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.OnBitSimilarity((SparseBitVect)v1, (SparseBitVect)v2) → float :¶


C++ signature :double OnBitSimilarity(SparseBitVect,SparseBitVect)




OnBitSimilarity( (ExplicitBitVect)v1, (ExplicitBitVect)v2) -> float :B(bv1&bv2) / B(bv1|bv2)

C++ signature :double OnBitSimilarity(ExplicitBitVect,ExplicitBitVect)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.OnBitsInCommon((SparseBitVect)bv1, (SparseBitVect)bv2) → _vecti :¶


C++ signature :std::vector<int, std::allocator<int> > OnBitsInCommon(SparseBitVect,SparseBitVect)




OnBitsInCommon( (ExplicitBitVect)bv1, (ExplicitBitVect)bv2) -> _vecti :Returns the number of on bits in common between the two bit vectors

C++ signature :std::vector<int, std::allocator<int> > OnBitsInCommon(ExplicitBitVect,ExplicitBitVect)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.RogotGoldbergSimilarity((SparseBitVect)bv1, (SparseBitVect)bv2[, (bool)returnDistance=0]) → float :¶


C++ signature :double RogotGoldbergSimilarity(SparseBitVect,SparseBitVect [,bool=0])




RogotGoldbergSimilarity( (ExplicitBitVect)bv1, (ExplicitBitVect)bv2 [, (bool)returnDistance=0]) -> float :B(bv1&bv2) / B(bv1)

C++ signature :double RogotGoldbergSimilarity(ExplicitBitVect,ExplicitBitVect [,bool=0])




RogotGoldbergSimilarity( (SparseBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :


C++ signature :double RogotGoldbergSimilarity(SparseBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])




RogotGoldbergSimilarity( (ExplicitBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :B(bv1&bv2) / B(bv1)

C++ signature :double RogotGoldbergSimilarity(ExplicitBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.RogotGoldbergSimilarityNeighbors((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
B(bv1&bv2) / B(bv1)

C++ signature :boost::python::list RogotGoldbergSimilarityNeighbors(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.RogotGoldbergSimilarityNeighbors_sparse((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
B(bv1&bv2) / B(bv1)

C++ signature :boost::python::list RogotGoldbergSimilarityNeighbors_sparse(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.RusselSimilarity((SparseBitVect)bv1, (SparseBitVect)bv2[, (bool)returnDistance=0]) → float :¶


C++ signature :double RusselSimilarity(SparseBitVect,SparseBitVect [,bool=0])




RusselSimilarity( (ExplicitBitVect)bv1, (ExplicitBitVect)bv2 [, (bool)returnDistance=0]) -> float :B(bv1&bv2) / B(bv1)

C++ signature :double RusselSimilarity(ExplicitBitVect,ExplicitBitVect [,bool=0])




RusselSimilarity( (SparseBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :


C++ signature :double RusselSimilarity(SparseBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])




RusselSimilarity( (ExplicitBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :B(bv1&bv2) / B(bv1)

C++ signature :double RusselSimilarity(ExplicitBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.RusselSimilarityNeighbors((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
B(bv1&bv2) / B(bv1)

C++ signature :boost::python::list RusselSimilarityNeighbors(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.RusselSimilarityNeighbors_sparse((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
B(bv1&bv2) / B(bv1)

C++ signature :boost::python::list RusselSimilarityNeighbors_sparse(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.SokalSimilarity((SparseBitVect)bv1, (SparseBitVect)bv2[, (bool)returnDistance=0]) → float :¶


C++ signature :double SokalSimilarity(SparseBitVect,SparseBitVect [,bool=0])




SokalSimilarity( (ExplicitBitVect)bv1, (ExplicitBitVect)bv2 [, (bool)returnDistance=0]) -> float :B(bv1&bv2) / (2*B(bv1) + 2*B(bv2) - 3*B(bv1&bv2))

C++ signature :double SokalSimilarity(ExplicitBitVect,ExplicitBitVect [,bool=0])




SokalSimilarity( (SparseBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :


C++ signature :double SokalSimilarity(SparseBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])




SokalSimilarity( (ExplicitBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :B(bv1&bv2) / (2*B(bv1) + 2*B(bv2) - 3*B(bv1&bv2))

C++ signature :double SokalSimilarity(ExplicitBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.SokalSimilarityNeighbors((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
B(bv1&bv2) / (2*B(bv1) + 2*B(bv2) - 3*B(bv1&bv2))

C++ signature :boost::python::list SokalSimilarityNeighbors(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.SokalSimilarityNeighbors_sparse((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
B(bv1&bv2) / (2*B(bv1) + 2*B(bv2) - 3*B(bv1&bv2))

C++ signature :boost::python::list SokalSimilarityNeighbors_sparse(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.TanimotoSimilarity((SparseBitVect)bv1, (SparseBitVect)bv2[, (bool)returnDistance=0]) → float :¶


C++ signature :double TanimotoSimilarity(SparseBitVect,SparseBitVect [,bool=0])




TanimotoSimilarity( (ExplicitBitVect)bv1, (ExplicitBitVect)bv2 [, (bool)returnDistance=0]) -> float :B(bv1&bv2) / (B(bv1) + B(bv2) - B(bv1&bv2))

C++ signature :double TanimotoSimilarity(ExplicitBitVect,ExplicitBitVect [,bool=0])




TanimotoSimilarity( (SparseBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :


C++ signature :double TanimotoSimilarity(SparseBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])




TanimotoSimilarity( (ExplicitBitVect)bv1, (str)pkl [, (bool)returnDistance=0]) -> float :B(bv1&bv2) / (B(bv1) + B(bv2) - B(bv1&bv2))

C++ signature :double TanimotoSimilarity(ExplicitBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=0])



TanimotoSimilarity( (IntSparseIntVect)siv1, (IntSparseIntVect)siv2 [, (bool)returnDistance=False [, (float)bounds=0.0]]) -> float :return the Tanimoto similarity between two vectors

C++ signature :double TanimotoSimilarity(RDKit::SparseIntVect<int>,RDKit::SparseIntVect<int> [,bool=False [,double=0.0]])



TanimotoSimilarity( (LongSparseIntVect)siv1, (LongSparseIntVect)siv2 [, (bool)returnDistance=False [, (float)bounds=0.0]]) -> float :return the Tanimoto similarity between two vectors

C++ signature :double TanimotoSimilarity(RDKit::SparseIntVect<long>,RDKit::SparseIntVect<long> [,bool=False [,double=0.0]])



TanimotoSimilarity( (UIntSparseIntVect)siv1, (UIntSparseIntVect)siv2 [, (bool)returnDistance=False [, (float)bounds=0.0]]) -> float :return the Tanimoto similarity between two vectors

C++ signature :double TanimotoSimilarity(RDKit::SparseIntVect<unsigned int>,RDKit::SparseIntVect<unsigned int> [,bool=False [,double=0.0]])



TanimotoSimilarity( (ULongSparseIntVect)siv1, (ULongSparseIntVect)siv2 [, (bool)returnDistance=False [, (float)bounds=0.0]]) -> float :return the Tanimoto similarity between two vectors

C++ signature :double TanimotoSimilarity(RDKit::SparseIntVect<unsigned long>,RDKit::SparseIntVect<unsigned long> [,bool=False [,double=0.0]])
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.TanimotoSimilarityNeighbors((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
B(bv1&bv2) / (B(bv1) + B(bv2) - B(bv1&bv2))

C++ signature :boost::python::list TanimotoSimilarityNeighbors(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.TanimotoSimilarityNeighbors_sparse((AtomPairsParameters)bvqueries, (AtomPairsParameters)bvList) → list :¶
B(bv1&bv2) / (B(bv1) + B(bv2) - B(bv1&bv2))

C++ signature :boost::python::list TanimotoSimilarityNeighbors_sparse(boost::python::api::object,boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.DataStructs.cDataStructs.TverskySimilarity((SparseBitVect)bv1, (SparseBitVect)bv2, (float)a, (float)b[, (bool)returnDistance=0]) → float :¶


C++ signature :double TverskySimilarity(SparseBitVect,SparseBitVect,double,double [,bool=0])




TverskySimilarity( (ExplicitBitVect)bv1, (ExplicitBitVect)bv2, (float)a, (float)b [, (bool)returnDistance=0]) -> float :B(bv1&bv2) / (a*B(bv1)+b*B(bv2)+(1-a-b)*B(bv1&bv2)

C++ signature :double TverskySimilarity(ExplicitBitVect,ExplicitBitVect,double,double [,bool=0])




TverskySimilarity( (SparseBitVect)bv1, (str)pkl, (float)a, (float)b [, (bool)returnDistance=0]) -> float :


C++ signature :double TverskySimilarity(SparseBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,double,double [,bool=0])




TverskySimilarity( (ExplicitBitVect)bv1, (str)pkl, (float)a, (float)b [, (bool)returnDistance=0]) -> float :B(bv1&bv2) / (a*B(bv1)+b*B(bv2)+(1-a-b)*B(bv1&bv2)

C++ signature :double TverskySimilarity(ExplicitBitVect,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,double,double [,bool=0])



TverskySimilarity( (IntSparseIntVect)siv1, (IntSparseIntVect)siv2, (float)a, (float)b [, (bool)returnDistance=False [, (float)bounds=0.0]]) -> float :return the Tversky similarity between two vectors

C++ signature :double TverskySimilarity(RDKit::SparseIntVect<int>,RDKit::SparseIntVect<int>,double,double [,bool=False [,double=0.0]])



TverskySimilarity( (LongSparseIntVect)siv1, (LongSparseIntVect)siv2, (float)a, (float)b [, (bool)returnDistance=False [, (float)bounds=0.0]]) -> float :return the Tversky similarity between two vectors

C++ signature :double TverskySimilarity(RDKit::SparseIntVect<long>,RDKit::SparseIntVect<long>,double,double [,bool=False [,double=0.0]])



TverskySimilarity( (UIntSparseIntVect)siv1, (UIntSparseIntVect)siv2, (float)a, (float)b [, (bool)returnDistance=False [, (float)bounds=0.0]]) -> float :return the Tversky similarity between two vectors

C++ signature :double TverskySimilarity(RDKit::SparseIntVect<unsigned int>,RDKit::SparseIntVect<unsigned int>,double,double [,bool=False [,double=0.0]])



TverskySimilarity( (ULongSparseIntVect)siv1, (ULongSparseIntVect)siv2, (float)a, (float)b [, (bool)returnDistance=False [, (float)bounds=0.0]]) -> float :return the Tversky similarity between two vectors

C++ signature :double TverskySimilarity(RDKit::SparseIntVect<unsigned long>,RDKit::SparseIntVect<unsigned long>,double,double [,bool=False [,double=0.0]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Dbase.DbInfo.GetColumnInfoFromCursor(cursor)¶
--------------------------------------------------------------------------------
rdkit.Dbase.DbInfo.GetColumnNames(dBase, table, user='sysdba', password='masterkey', join='', what='*', cn=None)¶
gets a list of columns available in a DB table
Arguments


dBase: the name of the DB file to be used
table: the name of the table to query
user: the username for DB access
password: the password to be used for DB access
join: an optional join clause  (omit the verb ‘join’)
what: an optional clause indicating what to select


Returns


a list of column names
--------------------------------------------------------------------------------
rdkit.Dbase.DbInfo.GetColumnNamesAndTypes(dBase, table, user='sysdba', password='masterkey', join='', what='*', cn=None)¶
gets a list of columns available in a DB table along with their types
Arguments


dBase: the name of the DB file to be used
table: the name of the table to query
user: the username for DB access
password: the password to be used for DB access
join: an optional join clause (omit the verb ‘join’)
what: an optional clause indicating what to select


Returns


a list of 2-tuples containing:


column name
column type
--------------------------------------------------------------------------------
rdkit.Dbase.DbInfo.GetDbNames(user='sysdba', password='masterkey', dirName='.', dBase='::template1', cn=None)¶
returns a list of databases that are available
Arguments


user: the username for DB access
password: the password to be used for DB access


Returns


a list of db names (strings)
--------------------------------------------------------------------------------
rdkit.Dbase.DbInfo.GetTableNames(dBase, user='sysdba', password='masterkey', includeViews=0, cn=None)¶
returns a list of tables available in a database
Arguments


dBase: the name of the DB file to be used
user: the username for DB access
password: the password to be used for DB access
includeViews: if this is non-null, the views in the db will
also be returned


Returns


a list of table names (strings)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Dbase.DbModule.connect(x, *args)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Dbase.DbUtils.DatabaseToDatabase(fromDb, fromTbl, toDb, toTbl, fields='*', join='', where='', user='sysdba', password='masterkey', keyCol=None, nullMarker='None')¶
FIX: at the moment this is a hack
--------------------------------------------------------------------------------
rdkit.Dbase.DbUtils.DatabaseToText(dBase, table, fields='*', join='', where='', user='sysdba', password='masterkey', delim=',', cn=None)¶
Pulls the contents of a database and makes a deliminted text file from them

Arguments
dBase: the name of the DB file to be used
table: the name of the table to query
fields: the fields to select with the SQL query
join: the join clause of the SQL query
(e.g. ‘join foo on foo.bar=base.bar’)
where: the where clause of the SQL query
(e.g. ‘where foo = 2’ or ‘where bar > 17.6’)
user: the username for DB access
password: the password to be used for DB access



Returns


the CSV data (as text)
--------------------------------------------------------------------------------
rdkit.Dbase.DbUtils.GetColumns(dBase, table, fieldString, user='sysdba', password='masterkey', join='', cn=None)¶
gets a set of data from a table
Arguments


dBase: database name
table: table name

fieldString: a string with the names of the fields to be extracted,this should be a comma delimited list



user and  password:
join: a join clause (omit the verb ‘join’)


Returns


a list of the data
--------------------------------------------------------------------------------
rdkit.Dbase.DbUtils.GetData(dBase, table, fieldString='*', whereString='', user='sysdba', password='masterkey', removeDups=-1, join='', forceList=0, transform=None, randomAccess=1, extras=None, cn=None)¶
a more flexible method to get a set of data from a table
Arguments



fields: a string with the names of the fields to be extracted,this should be a comma delimited list



where: the SQL where clause to be used with the DB query

removeDups indicates the column which should be used to screenout duplicates.  Only the first appearance of a duplicate will
be left in the dataset.





Returns


a list of the data


Notes


EFF: this isn’t particularly efficient
--------------------------------------------------------------------------------
rdkit.Dbase.DbUtils.GetTypeStrings(colHeadings, colTypes, keyCol=None)¶
returns a list of SQL type strings
--------------------------------------------------------------------------------
rdkit.Dbase.DbUtils.TextFileToDatabase(dBase, table, inF, delim=',', user='sysdba', password='masterkey', maxColLabelLen=31, keyCol=None, nullMarker=None)¶
loads the contents of the text file into a database.
Arguments


dBase: the name of the DB to use
table: the name of the table to create/overwrite
inF: the file like object from which the data should
be pulled (must support readline())
delim: the delimiter used to separate fields
user: the user name to use in connecting to the DB
password: the password to use in connecting to the DB
maxColLabelLen: the maximum length a column label should be
allowed to have (truncation otherwise)
keyCol: the column to be used as an index for the db


Notes


if _table_ already exists, it is destroyed before we write
the new data
we assume that the first row of the file contains the column names
--------------------------------------------------------------------------------
rdkit.Dbase.DbUtils.TypeFinder(data, nRows, nCols, nullMarker=None)¶
finds the types of the columns in _data_

if nullMarker is not None, elements of the data table which areequal to nullMarker will not count towards setting the type of
their columns.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Dbase.StorageUtils.GetNextId(conn, table, idColName='Id')¶
returns the next available Id in the database
see RegisterItem for testing/documentation
--------------------------------------------------------------------------------
rdkit.Dbase.StorageUtils.GetNextRDId(conn, table, idColName='Id', leadText='')¶
returns the next available RDId in the database
see RegisterItem for testing/documentation
--------------------------------------------------------------------------------
rdkit.Dbase.StorageUtils.IndexToRDId(idx, leadText='RDCmpd')¶
Converts an integer index into an RDId

The format of the ID is:leadText-xxx-xxx-xxx-y


The number blocks are zero padded and the final digit (y)
is a checksum:
>>> str(IndexToRDId(9))
'RDCmpd-000-009-9'
>>> str(IndexToRDId(9009))
'RDCmpd-009-009-8'


A millions block is included if it’s nonzero:
>>> str(IndexToRDId(9000009))
'RDCmpd-009-000-009-8'


The text at the beginning can be altered:
>>> str(IndexToRDId(9,leadText='RDAlt'))
'RDAlt-000-009-9'


Negative indices are errors:
>>> try:
...   IndexToRDId(-1)
... except ValueError:
...   print('ok')
... else:
...   print('failed')
ok
--------------------------------------------------------------------------------
rdkit.Dbase.StorageUtils.RDIdToInt(ID, validate=1)¶
Returns the integer index for a given RDId
Throws a ValueError on error
>>> RDIdToInt('RDCmpd-000-009-9')
9
>>> RDIdToInt('RDCmpd-009-000-009-8')
9000009
>>> RDIdToInt('RDData_000_009_9')
9
>>> try:
...   RDIdToInt('RDCmpd-009-000-109-8')
... except ValueError:
...   print('ok')
... else:
...   print('failed')
ok
>>> try:
...   RDIdToInt('bogus')
... except ValueError:
...   print('ok')
... else:
...   print('failed')
ok
--------------------------------------------------------------------------------
rdkit.Dbase.StorageUtils.RegisterItem(conn, table, value, columnName, data=None, id='', idColName='Id', leadText='RDCmpd')¶
>>> from rdkit.Dbase.DbConnection import DbConnect
>>> conn = DbConnect(tempDbName)
>>> tblName = 'StorageTest'
>>> conn.AddTable(tblName,'id varchar(32) not null primary key,label varchar(40),val int')
>>> RegisterItem(conn,tblName,'label1','label',['label1',1])==(1, 'RDCmpd-000-001-1')
True
>>> RegisterItem(conn,tblName,'label2','label',['label2',1])==(1, 'RDCmpd-000-002-2')
True
>>> RegisterItem(conn,tblName,'label1','label',['label1',1])==(0, 'RDCmpd-000-001-1')
True
>>> str(GetNextRDId(conn,tblName))
'RDCmpd-000-003-3'
>>> tuple(conn.GetData(table=tblName)[0])==('RDCmpd-000-001-1', 'label1', 1)
True


It’s also possible to provide ids by hand:
>>> RegisterItem(conn,tblName,'label10','label',['label10',1],
...              id='RDCmpd-000-010-1')==(1, 'RDCmpd-000-010-1')
True
>>> str(GetNextRDId(conn,tblName))
'RDCmpd-000-011-2'
--------------------------------------------------------------------------------
rdkit.Dbase.StorageUtils.RegisterItems(conn, table, values, columnName, rows, startId='', idColName='Id', leadText='RDCmpd')¶
--------------------------------------------------------------------------------
rdkit.Dbase.StorageUtils.ValidateRDId(ID)¶
returns whether or not an RDId is valid
>>> ValidateRDId('RDCmpd-000-009-9')
1
>>> ValidateRDId('RDCmpd-009-000-009-8')
1
>>> ValidateRDId('RDCmpd-009-000-109-8')
0
>>> ValidateRDId('bogus')
0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.DistanceGeometry.DistGeom.DoTriangleSmoothing((AtomPairsParameters)boundsMatrix[, (float)tol=0.0]) → bool :¶
Do triangle smoothing on a bounds matrix

ARGUMENTS:



mat: a square Numeric array of doubles containing the bounds matrix, this matrixis modified by the smoothing





RETURNS:

a boolean indicating whether or not the smoothing worked.



C++ signature :bool DoTriangleSmoothing(boost::python::api::object [,double=0.0])
--------------------------------------------------------------------------------
rdkit.DistanceGeometry.DistGeom.EmbedBoundsMatrix((AtomPairsParameters)boundsMatrix[, (int)maxIters=10[, (bool)randomizeOnFailure=False[, (int)numZeroFail=2[, (list)weights=[][, (int)randomSeed=-1]]]]]) → object :¶
Embed a bounds matrix and return the coordinates

ARGUMENTS:



boundsMatrix: a square Numeric array of doubles containing the bounds matrix, this matrixshould already be smoothed



maxIters: (optional) the maximum number of random distance matrices to try
randomizeOnFailure: (optional) toggles using random coords if a matrix fails to embed
numZeroFail: (optional) sets the number of zero eigenvalues to be considered a failure

weights: (optional) a sequence of 3 sequences (i,j,weight) indicating elements of the bounds matrix whose weights should be adjusted



randomSeed: (optional) sets the random number seed used for embedding


RETURNS:

a Numeric array of doubles with the coordinates



C++ signature :_object* EmbedBoundsMatrix(boost::python::api::object [,int=10 [,bool=False [,int=2 [,boost::python::list=[] [,int=-1]]]]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Geometry.rdGeometry.ComputeDihedralAngle((Point3D)pt1, (Point3D)pt2, (Point3D)pt3, (Point3D)pt4) → float :¶
calculates the dihedral angle determined by four Point3D objects

C++ signature :double ComputeDihedralAngle(RDGeom::Point3D,RDGeom::Point3D,RDGeom::Point3D,RDGeom::Point3D)
--------------------------------------------------------------------------------
rdkit.Geometry.rdGeometry.ComputeGridCentroid((UniformGrid3D_)grid, (Point3D)pt, (float)windowRadius) → tuple :¶
Compute the grid point at the center of sphere around a Point3D

C++ signature :boost::python::tuple ComputeGridCentroid(RDGeom::UniformGrid3D,RDGeom::Point3D,double)
--------------------------------------------------------------------------------
rdkit.Geometry.rdGeometry.ComputeSignedDihedralAngle((Point3D)pt1, (Point3D)pt2, (Point3D)pt3, (Point3D)pt4) → float :¶
calculates the signed dihedral angle determined by four Point3D objects

C++ signature :double ComputeSignedDihedralAngle(RDGeom::Point3D,RDGeom::Point3D,RDGeom::Point3D,RDGeom::Point3D)
--------------------------------------------------------------------------------
rdkit.Geometry.rdGeometry.FindGridTerminalPoints((UniformGrid3D_)grid, (float)windowRadius, (float)inclusionFraction) → tuple :¶
Find a grid’s terminal points (defined in the subshape algorithm).

C++ signature :boost::python::tuple FindGridTerminalPoints(RDGeom::UniformGrid3D,double,double)
--------------------------------------------------------------------------------
rdkit.Geometry.rdGeometry.ProtrudeDistance((UniformGrid3D_)grid1, (UniformGrid3D_)grid2) → float :¶
Compute the protrude distance between two grid objects

C++ signature :double ProtrudeDistance(RDGeom::UniformGrid3D,RDGeom::UniformGrid3D)
--------------------------------------------------------------------------------
rdkit.Geometry.rdGeometry.TanimotoDistance((UniformGrid3D_)grid1, (UniformGrid3D_)grid2) → float :¶
Compute the tanimoto distance between two grid objects

C++ signature :double TanimotoDistance(RDGeom::UniformGrid3D,RDGeom::UniformGrid3D)
--------------------------------------------------------------------------------
rdkit.Geometry.rdGeometry.TverskyIndex((UniformGrid3D_)grid1, (UniformGrid3D_)grid2, (float)alpha, (float)beta) → float :¶
Compute the tversky index between two grid objects

C++ signature :double TverskyIndex(RDGeom::UniformGrid3D,RDGeom::UniformGrid3D,double,double)
--------------------------------------------------------------------------------
rdkit.Geometry.rdGeometry.UniformGrid3D((float)dimX, (float)dimY, (float)dimZ[, (float)spacing=0.5[, (DiscreteValueType)valType=rdkit.DataStructs.cDataStructs.DiscreteValueType.TWOBITVALUE[, (Point3D)offSet=None]]]) → UniformGrid3D_ :¶
Faking the constructor

C++ signature :RDGeom::UniformGrid3D* UniformGrid3D(double,double,double [,double=0.5 [,RDKit::DiscreteValueVect::DiscreteValueType=rdkit.DataStructs.cDataStructs.DiscreteValueType.TWOBITVALUE [,RDGeom::Point3D const*=None]]])
--------------------------------------------------------------------------------
rdkit.Geometry.rdGeometry.WriteGridToFile((UniformGrid3D_)grid, (str)filename) → None :¶
Write the grid to a grid file

C++ signature :void WriteGridToFile(RDGeom::UniformGrid3D,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Cluster.Butina.ClusterData(data, nPts, distThresh, isDistData=False, distFunc=<function EuclideanDist>, reordering=False)¶
clusters the data points passed in and returns the list of clusters
Arguments


data: a list of items with the input data
(see discussion of _isDistData_ argument for the exception)
nPts: the number of points to be used
distThresh: elements within this range of each other are considered
to be neighbors

isDistData: set this toggle when the data passed in is adistance matrix.  The distance matrix should be stored
symmetrically. An example of how to do this:

dists = []
for i in range(nPts):


for j in range(i):dists.append( distfunc(i,j) )








distFunc: a function to calculate distances between points.Receives 2 points as arguments, should return a float




reordering: if this toggle is set, the number of neighbors is updatedfor the unassigned molecules after a new cluster is created such
that always the molecule with the largest number of unassigned
neighbors is selected as the next cluster center.





Returns



a tuple of tuples containing information about the clusters:
( (cluster1_elem1, cluster1_elem2, …),(cluster2_elem1, cluster2_elem2, …),
…


)
The first element for each cluster is its centroid.
--------------------------------------------------------------------------------
rdkit.ML.Cluster.Butina.EuclideanDist(pi, pj)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Cluster.Clustering.MurtaghCluster((AtomPairsParameters)data, (int)nPts, (int)sz, (int)option) → object :¶
TODO: provide docstring

C++ signature :_object* MurtaghCluster(boost::python::api::object,int,int,int)
--------------------------------------------------------------------------------
rdkit.ML.Cluster.Clustering.MurtaghDistCluster((AtomPairsParameters)data, (int)nPts, (int)option) → object :¶
TODO: provide docstring

C++ signature :_object* MurtaghDistCluster(boost::python::api::object,int,int)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Cluster.Clusters.cmp(t1, t2)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Cluster.ClusterUtils.FindClusterCentroidFromDists(cluster, dists)¶

find the point in a cluster which has the smallest summedEuclidean distance to all others


Arguments


cluster: the cluster to work with
dists: the distance matrix to use for the points


Returns


the index of the centroid point
--------------------------------------------------------------------------------
rdkit.ML.Cluster.ClusterUtils.GetNodeList(cluster)¶
returns an ordered list of all nodes below cluster
the ordering is done using the lengths of the child nodes

Arguments


cluster: the cluster in question


Returns


a list of the leaves below this cluster
--------------------------------------------------------------------------------
rdkit.ML.Cluster.ClusterUtils.GetNodesDownToCentroids(cluster, above=1)¶
returns an ordered list of all nodes below cluster
--------------------------------------------------------------------------------
rdkit.ML.Cluster.ClusterUtils.SplitIntoNClusters(cluster, n, breadthFirst=True)¶
splits a cluster tree into a set of branches
Arguments


cluster: the root of the cluster tree
n: the number of clusters to include in the split
breadthFirst: toggles breadth first (vs depth first) cleavage
of the cluster tree.


Returns


a list of sub clusters
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Cluster.ClusterVis.ClusterToImg(cluster, fileName, size=(300, 300), ptColors=[], lineWidth=None, showIndices=0, stopAtCentroids=0, logScale=0)¶
handles the work of drawing a cluster tree to an image file

Arguments


cluster: the cluster tree to be drawn
fileName: the name of the file to be created
size: the size of output canvas
ptColors: if this is specified, the _colors_ will be used to color
the terminal nodes of the cluster tree.  (color == _pid.Color_)
lineWidth: if specified, it will be used for the widths of the lines
used to draw the tree



Notes


The extension on  _fileName_ determines the type of image file created.
All formats supported by PIL can be used.
if _ptColors_ is the wrong length for the number of possible terminal
node types, this will throw an IndexError
terminal node types are determined using their _GetData()_ methods
--------------------------------------------------------------------------------
rdkit.ML.Cluster.ClusterVis.ClusterToPDF(cluster, fileName, size=(300, 300), ptColors=[], lineWidth=None, showIndices=0, stopAtCentroids=0, logScale=0)¶
handles the work of drawing a cluster tree to an PDF file

Arguments


cluster: the cluster tree to be drawn
fileName: the name of the file to be created
size: the size of output canvas
ptColors: if this is specified, the _colors_ will be used to color
the terminal nodes of the cluster tree.  (color == _pid.Color_)
lineWidth: if specified, it will be used for the widths of the lines
used to draw the tree



Notes


if _ptColors_ is the wrong length for the number of possible terminal
node types, this will throw an IndexError
terminal node types are determined using their _GetData()_ methods
--------------------------------------------------------------------------------
rdkit.ML.Cluster.ClusterVis.ClusterToSVG(cluster, fileName, size=(300, 300), ptColors=[], lineWidth=None, showIndices=0, stopAtCentroids=0, logScale=0)¶
handles the work of drawing a cluster tree to an SVG file

Arguments


cluster: the cluster tree to be drawn
fileName: the name of the file to be created
size: the size of output canvas
ptColors: if this is specified, the _colors_ will be used to color
the terminal nodes of the cluster tree.  (color == _pid.Color_)
lineWidth: if specified, it will be used for the widths of the lines
used to draw the tree



Notes


if _ptColors_ is the wrong length for the number of possible terminal
node types, this will throw an IndexError
terminal node types are determined using their _GetData()_ methods
--------------------------------------------------------------------------------
rdkit.ML.Cluster.ClusterVis.DrawClusterTree(cluster, canvas, size, ptColors=[], lineWidth=None, showIndices=0, showNodes=1, stopAtCentroids=0, logScale=0, tooClose=-1)¶
handles the work of drawing a cluster tree on a Sping canvas

Arguments


cluster: the cluster tree to be drawn
canvas:  the Sping canvas on which to draw
size: the size of _canvas_
ptColors: if this is specified, the _colors_ will be used to color
the terminal nodes of the cluster tree.  (color == _pid.Color_)
lineWidth: if specified, it will be used for the widths of the lines
used to draw the tree



Notes


_Canvas_ is neither _save_d nor _flush_ed at the end of this
if _ptColors_ is the wrong length for the number of possible terminal
node types, this will throw an IndexError
terminal node types are determined using their _GetData()_ methods
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Cluster.Murtagh.ClusterData(data, nPts, method, isDistData=0)¶
clusters the data points passed in and returns the cluster tree
Arguments


data: a list of lists (or array, or whatever) with the input
data (see discussion of _isDistData_ argument for the exception)
nPts: the number of points to be used

method: determines which clustering algorithm should be used.The defined constants for these are:
‘WARDS, SLINK, CLINK, UPGMA’




isDistData: set this toggle when the data passed in is adistance matrix.  The distance matrix should be stored
symmetrically so that _LookupDist (above) can retrieve
the results:

for i<j: d_ij = dists[j*(j-1)//2 + i]






Returns


a single entry list with the cluster tree
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Cluster.Resemblance.CalcMetricMatrix(inData, metricFunc)¶
generates a metric matrix

Arguments
inData is assumed to be a list of clusters (or anything with
a GetPosition() method)
metricFunc is the function to be used to generate the matrix



Returns

the metric matrix as a Numeric array
--------------------------------------------------------------------------------
rdkit.ML.Cluster.Resemblance.EuclideanDistance(inData)¶
returns the euclidean metricMat between the points in _inData_
Arguments


inData: a Numeric array of data points


Returns

a Numeric array with the metric matrix.  See the module documentation
for the format.
--------------------------------------------------------------------------------
rdkit.ML.Cluster.Resemblance.FindMinValInList(mat, nObjs, minIdx=None)¶
finds the minimum value in a metricMatrix and returns it and its indices
Arguments


mat: the metric matrix
nObjs: the number of objects to be considered
minIdx: the index of the minimum value (value, row and column still need
to be calculated


Returns

a 3-tuple containing:


the row
the column
the minimum value itself



Notes

-this probably ain’t the speediest thing on earth
--------------------------------------------------------------------------------
rdkit.ML.Cluster.Resemblance.ShowMetricMat(metricMat, nObjs)¶
displays a metric matrix
Arguments


metricMat: the matrix to be displayed
nObjs: the number of objects to display
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Cluster.Standardize.StdDev(mat)¶
the standard deviation classifier
This uses _ML.Data.Stats.StandardizeMatrix()_ to do the work
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.BuildDataSet(fileName)¶
builds a data set from a .dat file
Arguments


fileName: the name of the .dat file


Returns

an _MLData.MLDataSet_
--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.BuildQuantDataSet(fileName)¶
builds a data set from a .qdat file
Arguments


fileName: the name of the .qdat file


Returns

an _MLData.MLQuantDataSet_
--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.CalcNPossibleUsingMap(data, order, qBounds, nQBounds=None, silent=True)¶
calculates the number of possible values for each variable in a data set
Arguments


data: a list of examples
order: the ordering map between the variables in _data_ and _qBounds_
qBounds: the quantization bounds for the variables


Returns

a list with the number of possible values each variable takes on in the data set

Notes


variables present in _qBounds_ will have their _nPossible_ number read
from _qbounds
_nPossible_ for other numeric variables will be calculated
--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.CountResults(inData, col=-1, bounds=None)¶
#DOC
--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.DBToData(dbName, tableName, user='sysdba', password='masterkey', dupCol=-1, what='*', where='', join='', pickleCol=-1, pickleClass=None, ensembleIds=None)¶
constructs  an _MLData.MLDataSet_ from a database
Arguments


dbName: the name of the database to be opened
tableName: the table name containing the data in the database
user: the user name to be used to connect to the database
password: the password to be used to connect to the database
dupCol: if nonzero specifies which column should be used to recognize
duplicates.


Returns

an _MLData.MLDataSet_

Notes


this uses Dbase.DataUtils functionality
--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.FilterData(inData, val, frac, col=-1, indicesToUse=None, indicesOnly=0)¶
#DOC
--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.InitRandomNumbers(seed)¶
Seeds the random number generators
Arguments


seed: a 2-tuple containing integers to be used as the random number seeds


Notes

this seeds both the RDRandom generator and the one in the standard
Python _random_ module
--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.RandomizeActivities(dataSet, shuffle=0, runDetails=None)¶
randomizes the activity values of a dataset
Arguments


dataSet: a _ML.Data.MLQuantDataSet_, the activities here will be randomized
shuffle: an optional toggle. If this is set, the activity values
will be shuffled (so the number in each class remains constant)
runDetails: an optional CompositeRun object


Note


_examples_ are randomized in place
--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.ReadGeneralExamples(inFile)¶
reads the examples from a .dat file
Arguments


inFile: a file object


Returns

a 2-tuple containing:


the names of the examples
a list of lists containing the examples themselves



Note


this attempts to convert variable values to ints, then floats.
if those both fail, they are left as strings
--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.ReadQuantExamples(inFile)¶
reads the examples from a .qdat file
Arguments


inFile: a file object


Returns

a 2-tuple containing:


the names of the examples
a list of lists containing the examples themselves



Note

because this is reading a .qdat file, it assumed that all variable values
are integers
--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.ReadVars(inFile)¶
reads the variables and quantization bounds from a .qdat or .dat file
Arguments


inFile: a file object


Returns

a 2-tuple containing:


varNames: a list of the variable names
qbounds: the list of quantization bounds for each variable
--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.TakeEnsemble(vect, ensembleIds, isDataVect=False)¶
>>> v = [10,20,30,40,50]
>>> TakeEnsemble(v,(1,2,3))
[20, 30, 40]
>>> v = ['foo',10,20,30,40,50,1]
>>> TakeEnsemble(v,(1,2,3),isDataVect=True)
['foo', 20, 30, 40, 1]
--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.TextFileToData(fName, onlyCols=None)¶
#DOC
--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.TextToData(reader, ignoreCols=[], onlyCols=None)¶
constructs  an _MLData.MLDataSet_ from a bunch of text
#DOC


Arguments
reader needs to be iterable and return lists of elements
(like a csv.reader)



Returns

an _MLData.MLDataSet_
--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.WriteData(outFile, varNames, qBounds, examples)¶
writes out a .qdat file
Arguments


outFile: a file object
varNames: a list of variable names

qBounds: the list of quantization bounds (should be the same lengthas _varNames_)



examples: the data to be written
--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.WritePickledData(outName, data)¶
writes either a .qdat.pkl or a .dat.pkl file
Arguments


outName: the name of the file to be used
data: either an _MLData.MLDataSet_ or an _MLData.MLQuantDataSet_
--------------------------------------------------------------------------------
rdkit.ML.Data.DataUtils.permutation(nToDo)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Data.FindQuantBounds.Usage()¶
--------------------------------------------------------------------------------
rdkit.ML.Data.FindQuantBounds.runIt(namesAndTypes, dbConnect, nBounds, resCol, typesToDo=['float'])¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Data.Quantize.FindVarMultQuantBounds(vals, nBounds, results, nPossibleRes)¶
finds multiple quantization bounds for a single variable
Arguments


vals: sequence of variable values (assumed to be floats)
nBounds: the number of quantization bounds to find
results: a list of result codes (should be integers)
nPossibleRes: an integer with the number of possible values of the
result variable


Returns


a 2-tuple containing:

a list of the quantization bounds (floats)
the information gain associated with this quantization
--------------------------------------------------------------------------------
rdkit.ML.Data.Quantize.FindVarQuantBound(vals, results, nPossibleRes)¶
Uses FindVarMultQuantBounds, only here for historic reasons
--------------------------------------------------------------------------------
rdkit.ML.Data.Quantize.feq(v1, v2, tol=1e-08)¶
floating point equality with a tolerance factor
Arguments


v1: a float
v2: a float
tol: the tolerance for comparison


Returns

0 or 1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Data.SplitData.SplitDataSet(data, frac, silent=0)¶
splits a data set into two pieces

Arguments


data: a list of examples to be split
frac: the fraction of the data to be put in the first data set
silent: controls the amount of visual noise produced.



Returns

a 2-tuple containing the two new data sets.
--------------------------------------------------------------------------------
rdkit.ML.Data.SplitData.SplitDbData(conn, fracs, table='', fields='*', where='', join='', labelCol='', useActs=0, nActs=2, actCol='', actBounds=[], silent=0)¶
“splits” a data set held in a DB by returning lists of ids
Arguments:


conn: a DbConnect object
frac: the split fraction. This can optionally be specified as a
sequence with a different fraction for each activity value.
table,fields,where,join: (optional) SQL query parameters
useActs: (optional) toggles splitting based on activities
(ensuring that a given fraction of each activity class ends
up in the hold-out set)
Defaults to 0
nActs: (optional) number of possible activity values, only
used if _useActs_ is nonzero
Defaults to 2
actCol: (optional) name of the activity column
Defaults to use the last column returned by the query
actBounds: (optional) sequence of activity bounds
(for cases where the activity isn’t quantized in the db)
Defaults to an empty sequence
silent: controls the amount of visual noise produced.


Usage:
Set up the db connection, the simple tables we’re using have actives with even
ids and inactives with odd ids:
>>> from rdkit.ML.Data import DataUtils
>>> from rdkit.Dbase.DbConnection import DbConnect
>>> from rdkit import RDConfig
>>> conn = DbConnect(RDConfig.RDTestDatabase)
Pull a set of points from a simple table… take 33% of all points:
>>> DataUtils.InitRandomNumbers((23,42))
>>> train,test = SplitDbData(conn,1./3.,’basic_2class’)
>>> [str(x) for x in train]
[‘id-7’, ‘id-6’, ‘id-2’, ‘id-8’]
…take 50% of actives and 50% of inactives:
>>> DataUtils.InitRandomNumbers((23,42))
>>> train,test = SplitDbData(conn,.5,’basic_2class’,useActs=1)
>>> [str(x) for x in train]
[‘id-5’, ‘id-3’, ‘id-1’, ‘id-4’, ‘id-10’, ‘id-8’]
Notice how the results came out sorted by activity
We can be asymmetrical: take 33% of actives and 50% of inactives:
>>> DataUtils.InitRandomNumbers((23,42))
>>> train,test = SplitDbData(conn,[.5,1./3.],’basic_2class’,useActs=1)
>>> [str(x) for x in train]
[‘id-5’, ‘id-3’, ‘id-1’, ‘id-4’, ‘id-10’]
And we can pull from tables with non-quantized activities by providing
activity quantization bounds:
>>> DataUtils.InitRandomNumbers((23,42))
>>> train,test = SplitDbData(conn,.5,’float_2class’,useActs=1,actBounds=[1.0])
>>> [str(x) for x in train]
[‘id-5’, ‘id-3’, ‘id-1’, ‘id-4’, ‘id-10’, ‘id-8’]
--------------------------------------------------------------------------------
rdkit.ML.Data.SplitData.SplitIndices(nPts, frac, silent=1, legacy=0, replacement=0)¶
splits a set of indices into a data set into 2 pieces


Arguments


nPts: the total number of points
frac: the fraction of the data to be put in the first data set
silent: (optional) toggles display of stats
legacy: (optional) use the legacy splitting approach
replacement: (optional) use selection with replacement



Returns

a 2-tuple containing the two sets of indices.

Notes


the _legacy_ splitting approach uses randomly-generated floats
and compares them to _frac_.  This is provided for
backwards-compatibility reasons.
the default splitting approach uses a random permutation of
indices which is split into two parts.
selection with replacement can generate duplicates.



Usage:
We’ll start with a set of indices and pick from them using
the three different approaches:
>>> from rdkit.ML.Data import DataUtils
The base approach always returns the same number of compounds in
each set and has no duplicates:
>>> DataUtils.InitRandomNumbers((23,42))
>>> test,train = SplitIndices(10,.5)
>>> test
[1, 5, 6, 4, 2]
>>> train
[3, 0, 7, 8, 9]
>>> test,train = SplitIndices(10,.5)
>>> test
[5, 2, 9, 8, 7]
>>> train
[6, 0, 3, 1, 4]


The legacy approach can return varying numbers, but still has no
duplicates.  Note the indices come back ordered:
>>> DataUtils.InitRandomNumbers((23,42))
>>> test,train = SplitIndices(10,.5,legacy=1)
>>> test
[3, 5, 7, 8, 9]
>>> train
[0, 1, 2, 4, 6]
>>> test,train = SplitIndices(10,.5,legacy=1)
>>> test
[0, 1, 2, 3, 5, 8, 9]
>>> train
[4, 6, 7]


The replacement approach returns a fixed number in the training set,
a variable number in the test set and can contain duplicates in the
training set.
>>> DataUtils.InitRandomNumbers((23,42))
>>> test,train = SplitIndices(10,.5,replacement=1)
>>> test
[9, 9, 8, 0, 5]
>>> train
[1, 2, 3, 4, 6, 7]
>>> test,train = SplitIndices(10,.5,replacement=1)
>>> test
[4, 5, 1, 1, 4]
>>> train
[0, 2, 3, 6, 7, 8, 9]
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Data.Stats.FormCorrelationMatrix(mat)¶
form and return the covariance matrix
--------------------------------------------------------------------------------
rdkit.ML.Data.Stats.FormCovarianceMatrix(mat)¶
form and return the covariance matrix
--------------------------------------------------------------------------------
rdkit.ML.Data.Stats.GetConfidenceInterval(sd, n, level=95)¶
--------------------------------------------------------------------------------
rdkit.ML.Data.Stats.MeanAndDev(vect, sampleSD=1)¶
returns the mean and standard deviation of a vector
--------------------------------------------------------------------------------
rdkit.ML.Data.Stats.PrincipalComponents(mat, reverseOrder=1)¶
do a principal components analysis
--------------------------------------------------------------------------------
rdkit.ML.Data.Stats.R2(orig, residSum)¶
returns the R2 value for a set of predictions
--------------------------------------------------------------------------------
rdkit.ML.Data.Stats.StandardizeMatrix(mat)¶
This is the standard subtract off the average and divide by the deviation
standardization function.

Arguments


mat: a numpy array


Notes


in addition to being returned, _mat_ is modified in place, so beware
--------------------------------------------------------------------------------
rdkit.ML.Data.Stats.TransformPoints(tFormMat, pts)¶
transforms a set of points using tFormMat
Arguments


tFormMat: a numpy array
pts: a list of numpy arrays (or a 2D array)


Returns

a list of numpy arrays
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Data.Transforms.GetAvailTransforms()¶
returns the list of available data transformations
Returns

a list of 3-tuples


name of the transform (text)
function describing the transform (should take an
_MLDataSet_ as an argument)
description of the transform (text)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Descriptors.CompoundDescriptors.GetAllDescriptorNames(db, tbl1, tbl2, user='sysdba', password='masterkey')¶
gets possible descriptor names from a database
Arguments


db: the name of the database to use
tbl1: the name of the table to be used for reading descriptor values
tbl2: the name of the table to be used for reading notes about the
descriptors (descriptions of the descriptors if you like)
user: the user name for DB access
password: the password for DB access


Returns

a 2-tuple containing:


a list of column names
a list of column descriptors



Notes


this uses _Dbase.DbInfo_  and Dfunctionality for querying the database
it is assumed that tbl2 includes ‘property’ and ‘notes’ columns
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Descriptors.Parser.AVG(strArg, composList, atomDict)¶
Calculator Method
calculates the average of a descriptor across a composition
Arguments


strArg: the arguments in string form
compos: the composition vector
atomDict: the atomic dictionary


Returns

a float
--------------------------------------------------------------------------------
rdkit.ML.Descriptors.Parser.CalcMultipleCompoundsDescriptor(composVect, argVect, atomDict, propDictList)¶
calculates the value of the descriptor for a list of compounds
ARGUMENTS:



composVect: a vector of vector/tuple containing the compositioninformation.
See _CalcSingleCompoundDescriptor()_ for an explanation of the elements.



argVect: a vector/tuple with three elements:


AtomicDescriptorNames:  a list/tuple of the names of the


atomic descriptors being used. These determine the
meaning of $1, $2, etc. in the expression


CompoundDsscriptorNames:  a list/tuple of the names of the


compound descriptors being used. These determine the
meaning of $a, $b, etc. in the expression


Expr: a string containing the expression to be used to


evaluate the final result.




atomDict:a dictionary of atomic descriptors.  Each atomic entry is
another dictionary containing the individual descriptors
and their values




propVectList:a vector of vectors of descriptors for the composition.





RETURNS:

a vector containing the values of the descriptor for each
compound.  Any given entry will be -666 if problems were
encountered
--------------------------------------------------------------------------------
rdkit.ML.Descriptors.Parser.CalcSingleCompoundDescriptor(compos, argVect, atomDict, propDict)¶
calculates the value of the descriptor for a single compound
ARGUMENTS:



compos: a vector/tuple containing the compositioninformation… in the form:
‘[(“Fe”,1.),(“Pt”,2.),(“Rh”,0.02)]’



argVect: a vector/tuple with three elements:


AtomicDescriptorNames:  a list/tuple of the names of the


atomic descriptors being used. These determine the
meaning of $1, $2, etc. in the expression


CompoundDescriptorNames:  a list/tuple of the names of the


compound descriptors being used. These determine the
meaning of $a, $b, etc. in the expression


Expr: a string containing the expression to be used to


evaluate the final result.




atomDict:a dictionary of atomic descriptors.  Each atomic entry is
another dictionary containing the individual descriptors
and their values




propVect:a list of descriptors for the composition.





RETURNS:

the value of the descriptor, -666 if a problem was encountered

NOTE:



because it takes rather a lot of work to get everything setup to calculate a descriptor, if you are calculating the
same descriptor for multiple compounds, you probably want to
be calling _CalcMultipleCompoundsDescriptor()_.
--------------------------------------------------------------------------------
rdkit.ML.Descriptors.Parser.DEV(strArg, composList, atomDict)¶
Calculator Method
calculates the average deviation of a descriptor across a composition
Arguments


strArg: the arguments in string form
compos: the composition vector
atomDict: the atomic dictionary


Returns

a float
--------------------------------------------------------------------------------
rdkit.ML.Descriptors.Parser.HAS(strArg, composList, atomDict)¶
Calculator Method
does a string search
Arguments


strArg: the arguments in string form
composList: the composition vector
atomDict: the atomic dictionary


Returns

1 or 0
--------------------------------------------------------------------------------
rdkit.ML.Descriptors.Parser.MAX(strArg, composList, atomDict)¶
Calculator Method
calculates the maximum value of a descriptor across a composition
Arguments


strArg: the arguments in string form
compos: the composition vector
atomDict: the atomic dictionary


Returns

a float
--------------------------------------------------------------------------------
rdkit.ML.Descriptors.Parser.MEAN(strArg, composList, atomDict)¶
Calculator Method
calculates the average of a descriptor across a composition
Arguments


strArg: the arguments in string form
compos: the composition vector
atomDict: the atomic dictionary


Returns

a float
--------------------------------------------------------------------------------
rdkit.ML.Descriptors.Parser.MIN(strArg, composList, atomDict)¶
Calculator Method
calculates the minimum value of a descriptor across a composition
Arguments


strArg: the arguments in string form
compos: the composition vector
atomDict: the atomic dictionary


Returns

a float
--------------------------------------------------------------------------------
rdkit.ML.Descriptors.Parser.SUM(strArg, composList, atomDict)¶
Calculator Method
calculates the sum of a descriptor across a composition
Arguments


strArg: the arguments in string form
compos: the composition vector
atomDict: the atomic dictionary


Returns

a float
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.files.ReadDataFile(fileName, comment='#', depVarCol=0, dataType=<class 'float'>)¶
read in the data file and return a tuple of two Numeric arrays:
(independent variables, dependant variables).
ARGUMENTS:

fileName: the fileName
comment: the comment character for the file
depVarcol: the column number containing the dependant variable
dataType: the Numeric short-hand for the data type

RETURNS:

a tuple of two Numeric arrays:

(independent variables, dependant variables).
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.InfoTheory.BitRank.AnalyzeSparseVects(bitVects, actVals)¶
#DOC
Arguments



bitVects: a sequence containing SBVs
actVals: a sequence


Returns

a list of floats

Notes


these need to be bit vects and binary activities
--------------------------------------------------------------------------------
rdkit.ML.InfoTheory.BitRank.CalcInfoGains(bitVects, actVals, nPossibleActs, nPossibleBitVals=2)¶
Calculates the information gain for a set of points and activity values
Arguments



bitVects: a sequence containing IntVectors
actVals: a sequence
nPossibleActs: the (integer) number of possible activity values.
nPossibleBitVals: (optional) if specified, this integer provides the maximum
value attainable by the (increasingly inaccurately named) bits in _bitVects_.


Returns

a list of floats
--------------------------------------------------------------------------------
rdkit.ML.InfoTheory.BitRank.FormCounts(bitVects, actVals, whichBit, nPossibleActs, nPossibleBitVals=2)¶
generates the counts matrix for a particular bit
Arguments


bitVects: a sequence containing IntVectors
actVals: a sequence
whichBit: an integer, the bit number to use.
nPossibleActs: the (integer) number of possible activity values.
nPossibleBitVals: (optional) if specified, this integer provides the maximum
value attainable by the (increasingly inaccurately named) bits in _bitVects_.


Returns

a Numeric array with the counts

Notes

This is really intended for internal use.
--------------------------------------------------------------------------------
rdkit.ML.InfoTheory.BitRank.RankBits(bitVects, actVals, nPossibleBitVals=2, metricFunc=<function CalcInfoGains>)¶
Rank a set of bits according to a metric function
Arguments



bitVects: a sequence containing IntVectors
actVals: a sequence
nPossibleBitVals: (optional) if specified, this integer provides the maximum
value attainable by the (increasingly inaccurately named) bits in _bitVects_.
metricFunc: (optional) the metric function to be used.  See _CalcInfoGains()_
for a description of the signature of this function.


Returns

A 2-tuple containing:


the relative order of the bits (a list of ints)
the metric calculated for each bit (a list of floats)
--------------------------------------------------------------------------------
rdkit.ML.InfoTheory.BitRank.SparseRankBits(bitVects, actVals, metricFunc=<function AnalyzeSparseVects>)¶
Rank a set of bits according to a metric function
Arguments



bitVects: a sequence containing SBVs
actVals: a sequence
metricFunc: (optional) the metric function to be used.  See _SparseCalcInfoGains()_
for a description of the signature of this function.


Returns


A 2-tuple containing:


the relative order of the bits (a list of ints)
the metric calculated for each bit (a list of floats)



Notes


these need to be bit vects and binary activities
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.InfoTheory.entropy.PyInfoEntropy(results)¶
Calculates the informational entropy of a set of results.
Arguments

results is a 1D Numeric array containing the number of times a
given set hits each possible result.
For example, if a function has 3 possible results, and the

variable in question hits them 5, 6 and 1 times each,
results would be [5,6,1]


Returns

the informational entropy
--------------------------------------------------------------------------------
rdkit.ML.InfoTheory.entropy.PyInfoGain(varMat)¶
calculates the information gain for a variable
Arguments


varMat is a Numeric array with the number of possible occurrencesof each result for reach possible value of the given variable.

So, for a variable which adopts 4 possible values and a result whichhas 3 possible values, varMat would be 4x3



Returns

The expected information gain
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.InfoTheory.rdInfoTheory.ChiSquare((AtomPairsParameters)resArr) → float :¶
Calculates the chi squared value for a variable

ARGUMENTS:


varMat: a Numeric Array object
varMat is a Numeric array with the number of possible occurrences

of each result for reach possible value of the given variable.


So, for a variable which adopts 4 possible values and a result whichhas 3 possible values, varMat would be 4x3





RETURNS:


a Python float object




C++ signature :double ChiSquare(boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.ML.InfoTheory.rdInfoTheory.InfoEntropy((AtomPairsParameters)resArr) → float :¶
calculates the informational entropy of the values in an array

ARGUMENTS:


resMat: pointer to a long int array containing the data
dim: long int containing the length of the _tPtr_ array.


RETURNS:

a double



C++ signature :double InfoEntropy(boost::python::api::object)
--------------------------------------------------------------------------------
rdkit.ML.InfoTheory.rdInfoTheory.InfoGain((AtomPairsParameters)resArr) → float :¶
Calculates the information gain for a variable

ARGUMENTS:


varMat: a Numeric Array object
varMat is a Numeric array with the number of possible occurrences

of each result for reach possible value of the given variable.


So, for a variable which adopts 4 possible values and a result whichhas 3 possible values, varMat would be 4x3





RETURNS:


a Python float object


NOTES


this is a dropin replacement for _PyInfoGain()_ in entropy.py




C++ signature :double InfoGain(boost::python::api::object)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.MLUtils.VoteImg.BuildVoteImage(nModels, data, values, trueValues=[], sortTrueVals=0, xScale=10, yScale=2, addLine=1)¶
constructs the actual image
Arguments


nModels: the number of models in the composite
data: the results of voting
values: predicted values for each example
trueValues: true values for each example
sortTrueVals: if nonzero the votes will be sorted so
that the _trueValues_ are in order, otherwise the sort
is by _values_
xScale: number of pixels per vote in the x direction
yScale: number of pixels per example in the y direction

addLine: if nonzero, a purple line is drawn separatingthe votes from the examples





Returns

a PIL image
--------------------------------------------------------------------------------
rdkit.ML.MLUtils.VoteImg.CollectVotes(composite, data, badOnly)¶
collects the votes from _composite_ for the examples in _data_

Arguments


composite: a composite model
data: a list of examples to run through _composite_
badOnly: if set only bad (misclassified) examples will be kept


Returns

a 4-tuple containing:


the expanded list of vote details (see below)
the list of predicted results
the list of true results
the number of miscounted examples



Notes

pp      - the expanded list of vote details consists of:

‘[ vote1, vote2, … voteN, 0, res, trueRes]’
where _res_ is the predicted results and _trueRes_ is the actual result.
The extra zero is included to allow a line to be drawn between the votes
and the results.
--------------------------------------------------------------------------------
rdkit.ML.MLUtils.VoteImg.Usage()¶
provides a list of arguments for when this is used from the command line
--------------------------------------------------------------------------------
rdkit.ML.MLUtils.VoteImg.VoteAndBuildImage(composite, data, badOnly=0, sortTrueVals=0, xScale=10, yScale=2, addLine=1)¶
collects votes on the examples and constructs an image
Arguments


composte: a composite model
data: the examples to be voted upon
badOnly: if nonzero only the incorrect votes will be shown
sortTrueVals: if nonzero the votes will be sorted so
that the _trueValues_ are in order, otherwise the sort
is by _values_
xScale: number of pixels per vote in the x direction
yScale: number of pixels per example in the y direction

addLine: if nonzero, a purple line is drawn separatingthe votes from the examples





Returns

a PIL image
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.Scoring.Scoring.CalcAUC(scores, col)¶
Determines the area under the ROC curve
--------------------------------------------------------------------------------
rdkit.ML.Scoring.Scoring.CalcBEDROC(scores, col, alpha)¶
BEDROC original defined here:
Truchon, J. & Bayly, C.I.
Evaluating Virtual Screening Methods: Good and Bad Metric for the “Early Recognition”
Problem. J. Chem. Inf. Model. 47, 488-508 (2007).
** Arguments**




scores: 2d list or numpy array0th index representing sample
scores must be in sorted order with low indexes “better”
scores[sample_id] = vector of sample data




col: intIndex of sample data which reflects true label of a sample
scores[sample_id][col] = True iff that sample is active




alpha: floathyper parameter from the initial paper for how much to enrich the top






Returnsfloat BedROC score
--------------------------------------------------------------------------------
rdkit.ML.Scoring.Scoring.CalcEnrichment(scores, col, fractions)¶
Determines the enrichment factor for a set of fractions
--------------------------------------------------------------------------------
rdkit.ML.Scoring.Scoring.CalcRIE(scores, col, alpha)¶
RIE original definded here:
Sheridan, R.P., Singh, S.B., Fluder, E.M. & Kearsley, S.K.
Protocols for Bridging the Peptide to Nonpeptide Gap in Topological Similarity Searches.
J. Chem. Inf. Comp. Sci. 41, 1395-1406 (2001).
--------------------------------------------------------------------------------
rdkit.ML.Scoring.Scoring.CalcROC(scores, col)¶
Determines a ROC curve
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.ML.SLT.Risk.BurgesRiskBound(VCDim, nData, nWrong, conf)¶
Calculates Burges’s formulation of the risk bound
The formulation is from Eqn. 3 of Burges’s review
article “A Tutorial on Support Vector Machines for Pattern Recognition”

In _Data Mining and Knowledge Discovery_ Kluwer Academic Publishers
(1998) Vol. 2

Arguments


VCDim: the VC dimension of the system
nData: the number of data points used
nWrong: the number of data points misclassified
conf: the confidence to be used for this risk bound


Returns


a float


Notes


This has been validated against the Burges paper
I believe that this is only technically valid for binary classification
--------------------------------------------------------------------------------
rdkit.ML.SLT.Risk.CherkasskyRiskBound(VCDim, nData, nWrong, conf, a1=1.0, a2=2.0)¶
The formulation here is from Eqns 4.22 and 4.23 on pg 108 of
Cherkassky and Mulier’s book “Learning From Data” Wiley, 1998.
Arguments


VCDim: the VC dimension of the system
nData: the number of data points used
nWrong: the number of data points misclassified
conf: the confidence to be used for this risk bound
a1, a2: constants in the risk equation. Restrictions on these values:


0 <= a1 <= 4
0 <= a2 <= 2





Returns


a float


Notes


This appears to behave reasonably
the equality a1=1.0 is by analogy to Burges’s paper.
--------------------------------------------------------------------------------
rdkit.ML.SLT.Risk.CristianiRiskBound(VCDim, nData, nWrong, conf)¶
the formulation here is from pg 58, Theorem 4.6 of the book
“An Introduction to Support Vector Machines” by Cristiani and Shawe-Taylor
Cambridge University Press, 2000
Arguments


VCDim: the VC dimension of the system
nData: the number of data points used
nWrong: the number of data points misclassified
conf: the confidence to be used for this risk bound


Returns


a float


Notes


this generates odd (mismatching) values
--------------------------------------------------------------------------------
rdkit.ML.SLT.Risk.log2(x)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.Numerics.rdAlignment.GetAlignmentTransform((AtomPairsParameters)refPoints, (AtomPairsParameters)probePoints[, (AtomPairsParameters)weights=[][, (bool)reflect=False[, (int)maxIterations=50]]]) → object :¶
Compute the optimal alignment (minimum RMSD) between two set of points

ARGUMENTS:



refPointsreference points specified as a N by 3 Numeric array or sequence of 3-sequences or sequence of Point3Ds




probePointsprobe points to align to reference points - same format restrictions as reference points apply here



weights : optional numeric vector or list of weights to associate to each pair of points
reflect : reflect the probe points before attempting alignment
maxIteration : maximum number of iterations to try to minimize RMSD


RETURNS:


a 2-tuple:
SSD value for the alignment
the 4x4 transform matrix, as a Numeric array






C++ signature :_object* GetAlignmentTransform(boost::python::api::object,boost::python::api::object [,boost::python::api::object=[] [,bool=False [,unsigned int=50]]])
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.rdBase.AttachFileToLog((str)spec, (str)filename[, (int)delay=100]) → None :¶
Causes the log to write to a file

C++ signature :void AttachFileToLog(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,int=100])
--------------------------------------------------------------------------------
rdkit.rdBase.DisableLog((str)spec) → None :¶

C++ signature :void DisableLog(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.rdBase.EnableLog((str)spec) → None :¶

C++ signature :void EnableLog(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.rdBase.LogDebugMsg((str)msg) → None :¶
Log a message to the RDKit debug logs

C++ signature :void LogDebugMsg(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.rdBase.LogErrorMsg((str)msg) → None :¶
Log a message to the RDKit error logs

C++ signature :void LogErrorMsg(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.rdBase.LogInfoMsg((str)msg) → None :¶
Log a message to the RDKit info logs

C++ signature :void LogInfoMsg(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.rdBase.LogMessage((str)spec, (str)msg) → None :¶
Log a message to any rdApp.* log

C++ signature :void LogMessage(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.rdBase.LogStatus() → str :¶

C++ signature :std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > LogStatus()
--------------------------------------------------------------------------------
rdkit.rdBase.LogToCppStreams() → None :¶
Initialize RDKit logs with C++ streams

C++ signature :void LogToCppStreams()
--------------------------------------------------------------------------------
rdkit.rdBase.LogToPythonLogger() → None :¶
Initialize RDKit logs with Python’s logging module

C++ signature :void LogToPythonLogger()
--------------------------------------------------------------------------------
rdkit.rdBase.LogToPythonStderr() → None :¶
Initialize RDKit logs with Python’s stderr stream

C++ signature :void LogToPythonStderr()
--------------------------------------------------------------------------------
rdkit.rdBase.LogWarningMsg((str)msg) → None :¶
Log a message to the RDKit warning logs

C++ signature :void LogWarningMsg(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
--------------------------------------------------------------------------------
rdkit.rdBase.SeedRandomNumberGenerator((int)seed) → None :¶
Provides a seed to the standard C random number generator
This does not affect pure Python code, but is relevant to some of the RDKit C++ components.

C++ signature :void SeedRandomNumberGenerator(unsigned int)
--------------------------------------------------------------------------------
rdkit.rdBase.WrapLogs() → None :¶
Tee the RDKit logs to Python’s stderr stream

C++ signature :void WrapLogs()
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.RDRandom.random() → x in the interval [0, 1).¶
--------------------------------------------------------------------------------
rdkit.RDRandom.shuffle(x, random=None)¶
Shuffle list x in place, and return None.
Optional argument random is a 0-argument function returning a
random float in [0.0, 1.0); if it is the default None, the
standard random.random will be used.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.TestRunner.isDebugBuild()¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.utils.cactvs.SmilesToGif(smiles, fileNames, size=(200, 200), cmd=None, dblSize=0, frame=0)¶
--------------------------------------------------------------------------------
rdkit.utils.cactvs.SmilesToImage(smiles, **kwargs)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.utils.chemutils.ConfigToNumElectrons(config, ignoreFullD=0, ignoreFullF=0)¶
counts the number of electrons appearing in a configuration string
Arguments


config: the configuration string (e.g. ‘2s^2 2p^4’)
ignoreFullD: toggles not counting full d shells
ignoreFullF: toggles not counting full f shells


Returns

the number of valence electrons
--------------------------------------------------------------------------------
rdkit.utils.chemutils.GetAtomicData(atomDict, descriptorsDesired, dBase='/scratch/RDKit_2024_03/Data/atomdb.gdb', table='atomic_data', where='', user='sysdba', password='masterkey', includeElCounts=0)¶
pulls atomic data from a database
Arguments


atomDict: the dictionary to populate
descriptorsDesired: the descriptors to pull for each atom
dBase: the DB to use
table: the DB table to use
where: the SQL where clause
user: the user name to use with the DB
password: the password to use with the DB

includeElCounts: if nonzero, valence electron count fields are added tothe _atomDict_
--------------------------------------------------------------------------------
rdkit.utils.chemutils.SplitComposition(compStr)¶
Takes a simple chemical composition and turns into a list of element,# pairs.
i.e. ‘Fe3Al’ -> [(‘Fe’,3),(‘Al’,1)]
Arguments


compStr: the composition string to be processed


Returns


the composVect corresponding to _compStr_


Note


-this isn’t smart enough by half to deal with anything evenremotely subtle, so be gentle.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.utils.fileutils.MoveToMatchingLine(inFile, matchStr, fullMatch=0)¶
skip forward in a file until a given string is found
Arguments


inFile: a file object (or anything supporting a _readline()_ method)
matchStr: the string to search for
fullMatch: if nonzero, _matchStr_ must match the entire line


Returns

the matching line

Notes:


if _matchStr_ is not found in the file, a NoMatchFound exception
will be raised
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.utils.listutils.CompactListRepr(lst)¶
>>> CompactListRepr([0,1,1,1,1,0])
'[0]+[1]*4+[0]'
>>> CompactListRepr([0,1,1,2,1,1])
'[0]+[1]*2+[2]+[1]*2'
>>> CompactListRepr([])
'[]'
>>> CompactListRepr((0,1,1,1,1))
'[0]+[1]*4'
>>> CompactListRepr('foo')
"['f']+['o']*2"
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.utils.spiral.DrawSpiral(canvas, startColor, endColor, startRadius, endRadius, nLoops, degsPerSlice=70, degsPerStep=1, startAngle=0, centerPos=None, dir=1)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.VLib.NodeLib.DbMolSupply.GetNode(dbName, tableName)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
rdkit.VLib.NodeLib.DbPickleSupplier.GetNode(dbName, tableName)¶
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
